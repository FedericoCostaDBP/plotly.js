var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/two-product/two-product.js
var require_two_product = __commonJS({
  "node_modules/two-product/two-product.js"(exports2, module2) {
    "use strict";
    module2.exports = twoProduct;
    var SPLITTER = +(Math.pow(2, 27) + 1);
    function twoProduct(a, b, result) {
      var x = a * b;
      var c = SPLITTER * a;
      var abig = c - a;
      var ahi = c - abig;
      var alo = a - ahi;
      var d = SPLITTER * b;
      var bbig = d - b;
      var bhi = d - bbig;
      var blo = b - bhi;
      var err1 = x - ahi * bhi;
      var err2 = err1 - alo * bhi;
      var err3 = err2 - ahi * blo;
      var y = alo * blo - err3;
      if (result) {
        result[0] = y;
        result[1] = x;
        return result;
      }
      return [y, x];
    }
  }
});

// node_modules/robust-sum/robust-sum.js
var require_robust_sum = __commonJS({
  "node_modules/robust-sum/robust-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = linearExpansionSum;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function linearExpansionSum(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/two-sum/two-sum.js
var require_two_sum = __commonJS({
  "node_modules/two-sum/two-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = fastTwoSum;
    function fastTwoSum(a, b, result) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      if (result) {
        result[0] = ar + br;
        result[1] = x;
        return result;
      }
      return [ar + br, x];
    }
  }
});

// node_modules/robust-scale/robust-scale.js
var require_robust_scale = __commonJS({
  "node_modules/robust-scale/robust-scale.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var twoSum = require_two_sum();
    module2.exports = scaleLinearExpansion;
    function scaleLinearExpansion(e, scale) {
      var n = e.length;
      if (n === 1) {
        var ts = twoProduct(e[0], scale);
        if (ts[0]) {
          return ts;
        }
        return [ts[1]];
      }
      var g = new Array(2 * n);
      var q = [0.1, 0.1];
      var t = [0.1, 0.1];
      var count = 0;
      twoProduct(e[0], scale, q);
      if (q[0]) {
        g[count++] = q[0];
      }
      for (var i = 1; i < n; ++i) {
        twoProduct(e[i], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if (q[0]) {
          g[count++] = q[0];
        }
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if (y) {
          g[count++] = y;
        }
      }
      if (q[1]) {
        g[count++] = q[1];
      }
      if (count === 0) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-subtract/robust-diff.js
var require_robust_diff = __commonJS({
  "node_modules/robust-subtract/robust-diff.js"(exports2, module2) {
    "use strict";
    module2.exports = robustSubtract;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function robustSubtract(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], -f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = -f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = -f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-orientation/orientation.js
var require_orientation = __commonJS({
  "node_modules/robust-orientation/orientation.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    var robustSubtract = require_robust_diff();
    var NUM_EXPAND = 5;
    var EPSILON = 11102230246251565e-32;
    var ERRBOUND3 = (3 + 16 * EPSILON) * EPSILON;
    var ERRBOUND4 = (7 + 56 * EPSILON) * EPSILON;
    function orientation_3(sum, prod, scale, sub) {
      return function orientation3Exact2(m0, m1, m2) {
        var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
        var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_4(sum, prod, scale, sub) {
      return function orientation4Exact2(m0, m1, m2, m3) {
        var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
        var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_5(sum, prod, scale, sub) {
      return function orientation5Exact(m0, m1, m2, m3, m4) {
        var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));
        var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation(n) {
      var fn = n === 3 ? orientation_3 : n === 4 ? orientation_4 : orientation_5;
      return fn(robustSum, twoProduct, robustScale, robustSubtract);
    }
    var orientation3Exact = orientation(3);
    var orientation4Exact = orientation(4);
    var CACHED = [
      function orientation0() {
        return 0;
      },
      function orientation1() {
        return 0;
      },
      function orientation2(a, b) {
        return b[0] - a[0];
      },
      function orientation3(a, b, c) {
        var l = (a[1] - c[1]) * (b[0] - c[0]);
        var r = (a[0] - c[0]) * (b[1] - c[1]);
        var det = l - r;
        var s;
        if (l > 0) {
          if (r <= 0) {
            return det;
          } else {
            s = l + r;
          }
        } else if (l < 0) {
          if (r >= 0) {
            return det;
          } else {
            s = -(l + r);
          }
        } else {
          return det;
        }
        var tol = ERRBOUND3 * s;
        if (det >= tol || det <= -tol) {
          return det;
        }
        return orientation3Exact(a, b, c);
      },
      function orientation4(a, b, c, d) {
        var adx = a[0] - d[0];
        var bdx = b[0] - d[0];
        var cdx = c[0] - d[0];
        var ady = a[1] - d[1];
        var bdy = b[1] - d[1];
        var cdy = c[1] - d[1];
        var adz = a[2] - d[2];
        var bdz = b[2] - d[2];
        var cdz = c[2] - d[2];
        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;
        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
        var tol = ERRBOUND4 * permanent;
        if (det > tol || -det > tol) {
          return det;
        }
        return orientation4Exact(a, b, c, d);
      }
    ];
    function slowOrient(args) {
      var proc2 = CACHED[args.length];
      if (!proc2) {
        proc2 = CACHED[args.length] = orientation(args.length);
      }
      return proc2.apply(void 0, args);
    }
    function proc(slow, o0, o1, o2, o3, o4, o5) {
      return function getOrientation(a0, a1, a2, a3, a4) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return o2(a0, a1);
          case 3:
            return o3(a0, a1, a2);
          case 4:
            return o4(a0, a1, a2, a3);
          case 5:
            return o5(a0, a1, a2, a3, a4);
        }
        var s = new Array(arguments.length);
        for (var i = 0; i < arguments.length; ++i) {
          s[i] = arguments[i];
        }
        return slow(s);
      };
    }
    function generateOrientationProc() {
      while (CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      module2.exports = proc.apply(void 0, [slowOrient].concat(CACHED));
      for (var i = 0; i <= NUM_EXPAND; ++i) {
        module2.exports[i] = CACHED[i];
      }
    }
    generateOrientationProc();
  }
});

// node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "node_modules/bit-twiddle/twiddle.js"(exports2) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports2.INT_BITS = INT_BITS;
    exports2.INT_MAX = 2147483647;
    exports2.INT_MIN = -1 << INT_BITS - 1;
    exports2.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports2.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports2.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports2.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports2.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports2.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports2.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports2.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    }
    exports2.countTrailingZeros = countTrailingZeros;
    exports2.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports2.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports2.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports2.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports2.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports2.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports2.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports2.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports2.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/union-find/index.js
var require_union_find = __commonJS({
  "node_modules/union-find/index.js"(exports2, module2) {
    "use strict";
    "use restrict";
    module2.exports = UnionFind;
    function UnionFind(count) {
      this.roots = new Array(count);
      this.ranks = new Array(count);
      for (var i = 0; i < count; ++i) {
        this.roots[i] = i;
        this.ranks[i] = 0;
      }
    }
    var proto = UnionFind.prototype;
    Object.defineProperty(proto, "length", {
      "get": function() {
        return this.roots.length;
      }
    });
    proto.makeSet = function() {
      var n = this.roots.length;
      this.roots.push(n);
      this.ranks.push(0);
      return n;
    };
    proto.find = function(x) {
      var x0 = x;
      var roots = this.roots;
      while (roots[x] !== x) {
        x = roots[x];
      }
      while (roots[x0] !== x) {
        var y = roots[x0];
        roots[x0] = x;
        x0 = y;
      }
      return x;
    };
    proto.link = function(x, y) {
      var xr = this.find(x), yr = this.find(y);
      if (xr === yr) {
        return;
      }
      var ranks = this.ranks, roots = this.roots, xd = ranks[xr], yd = ranks[yr];
      if (xd < yd) {
        roots[xr] = yr;
      } else if (yd < xd) {
        roots[yr] = xr;
      } else {
        roots[yr] = xr;
        ++ranks[xr];
      }
    };
  }
});

// node_modules/simplicial-complex/topology.js
var require_topology = __commonJS({
  "node_modules/simplicial-complex/topology.js"(exports2) {
    "use strict";
    "use restrict";
    var bits = require_twiddle();
    var UnionFind = require_union_find();
    function dimension(cells) {
      var d = 0, max = Math.max;
      for (var i = 0, il = cells.length; i < il; ++i) {
        d = max(d, cells[i].length);
      }
      return d - 1;
    }
    exports2.dimension = dimension;
    function countVertices(cells) {
      var vc = -1, max = Math.max;
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i];
        for (var j = 0, jl = c.length; j < jl; ++j) {
          vc = max(vc, c[j]);
        }
      }
      return vc + 1;
    }
    exports2.countVertices = countVertices;
    function cloneCells(cells) {
      var ncells = new Array(cells.length);
      for (var i = 0, il = cells.length; i < il; ++i) {
        ncells[i] = cells[i].slice(0);
      }
      return ncells;
    }
    exports2.cloneCells = cloneCells;
    function compareCells(a, b) {
      var n = a.length, t = a.length - b.length, min = Math.min;
      if (t) {
        return t;
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          return a[0] - b[0];
        case 2:
          var d = a[0] + a[1] - b[0] - b[1];
          if (d) {
            return d;
          }
          return min(a[0], a[1]) - min(b[0], b[1]);
        case 3:
          var l1 = a[0] + a[1], m1 = b[0] + b[1];
          d = l1 + a[2] - (m1 + b[2]);
          if (d) {
            return d;
          }
          var l0 = min(a[0], a[1]), m0 = min(b[0], b[1]), d = min(l0, a[2]) - min(m0, b[2]);
          if (d) {
            return d;
          }
          return min(l0 + a[2], l1) - min(m0 + b[2], m1);
        //TODO: Maybe optimize n=4 as well?
        default:
          var as = a.slice(0);
          as.sort();
          var bs = b.slice(0);
          bs.sort();
          for (var i = 0; i < n; ++i) {
            t = as[i] - bs[i];
            if (t) {
              return t;
            }
          }
          return 0;
      }
    }
    exports2.compareCells = compareCells;
    function compareZipped(a, b) {
      return compareCells(a[0], b[0]);
    }
    function normalize(cells, attr) {
      if (attr) {
        var len = cells.length;
        var zipped = new Array(len);
        for (var i = 0; i < len; ++i) {
          zipped[i] = [cells[i], attr[i]];
        }
        zipped.sort(compareZipped);
        for (var i = 0; i < len; ++i) {
          cells[i] = zipped[i][0];
          attr[i] = zipped[i][1];
        }
        return cells;
      } else {
        cells.sort(compareCells);
        return cells;
      }
    }
    exports2.normalize = normalize;
    function unique(cells) {
      if (cells.length === 0) {
        return [];
      }
      var ptr = 1, len = cells.length;
      for (var i = 1; i < len; ++i) {
        var a = cells[i];
        if (compareCells(a, cells[i - 1])) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          cells[ptr++] = a;
        }
      }
      cells.length = ptr;
      return cells;
    }
    exports2.unique = unique;
    function findCell(cells, c) {
      var lo = 0, hi = cells.length - 1, r = -1;
      while (lo <= hi) {
        var mid = lo + hi >> 1, s = compareCells(cells[mid], c);
        if (s <= 0) {
          if (s === 0) {
            r = mid;
          }
          lo = mid + 1;
        } else if (s > 0) {
          hi = mid - 1;
        }
      }
      return r;
    }
    exports2.findCell = findCell;
    function incidence(from_cells, to_cells) {
      var index = new Array(from_cells.length);
      for (var i = 0, il = index.length; i < il; ++i) {
        index[i] = [];
      }
      var b = [];
      for (var i = 0, n = to_cells.length; i < n; ++i) {
        var c = to_cells[i];
        var cl = c.length;
        for (var k = 1, kn = 1 << cl; k < kn; ++k) {
          b.length = bits.popCount(k);
          var l = 0;
          for (var j = 0; j < cl; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          var idx = findCell(from_cells, b);
          if (idx < 0) {
            continue;
          }
          while (true) {
            index[idx++].push(i);
            if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
              break;
            }
          }
        }
      }
      return index;
    }
    exports2.incidence = incidence;
    function dual(cells, vertex_count) {
      if (!vertex_count) {
        return incidence(unique(skeleton(cells, 0)), cells, 0);
      }
      var res = new Array(vertex_count);
      for (var i = 0; i < vertex_count; ++i) {
        res[i] = [];
      }
      for (var i = 0, len = cells.length; i < len; ++i) {
        var c = cells[i];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          res[c[j]].push(i);
        }
      }
      return res;
    }
    exports2.dual = dual;
    function explode(cells) {
      var result = [];
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i], cl = c.length | 0;
        for (var j = 1, jl = 1 << cl; j < jl; ++j) {
          var b = [];
          for (var k = 0; k < cl; ++k) {
            if (j >>> k & 1) {
              b.push(c[k]);
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports2.explode = explode;
    function skeleton(cells, n) {
      if (n < 0) {
        return [];
      }
      var result = [], k0 = (1 << n + 1) - 1;
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {
          var b = new Array(n + 1), l = 0;
          for (var j = 0; j < c.length; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports2.skeleton = skeleton;
    function boundary(cells) {
      var res = [];
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          var b = new Array(c.length - 1);
          for (var k = 0, l = 0; k < cl; ++k) {
            if (k !== j) {
              b[l++] = c[k];
            }
          }
          res.push(b);
        }
      }
      return normalize(res);
    }
    exports2.boundary = boundary;
    function connectedComponents_dense(cells, vertex_count) {
      var labels = new UnionFind(vertex_count);
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var j = 0; j < c.length; ++j) {
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(c[j], c[k]);
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i = 0; i < component_labels.length; ++i) {
        component_labels[i] = -1;
      }
      for (var i = 0; i < cells.length; ++i) {
        var l = labels.find(cells[i][0]);
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i].slice(0));
        }
      }
      return components;
    }
    function connectedComponents_sparse(cells) {
      var vertices = unique(normalize(skeleton(cells, 0))), labels = new UnionFind(vertices.length);
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var j = 0; j < c.length; ++j) {
          var vj = findCell(vertices, [c[j]]);
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(vj, findCell(vertices, [c[k]]));
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i = 0; i < component_labels.length; ++i) {
        component_labels[i] = -1;
      }
      for (var i = 0; i < cells.length; ++i) {
        var l = labels.find(findCell(vertices, [cells[i][0]]));
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i].slice(0));
        }
      }
      return components;
    }
    function connectedComponents(cells, vertex_count) {
      if (vertex_count) {
        return connectedComponents_dense(cells, vertex_count);
      }
      return connectedComponents_sparse(cells);
    }
    exports2.connectedComponents = connectedComponents;
  }
});

// node_modules/incremental-convex-hull/ich.js
var require_ich = __commonJS({
  "node_modules/incremental-convex-hull/ich.js"(exports2, module2) {
    "use strict";
    module2.exports = incrementalConvexHull;
    var orient = require_orientation();
    var compareCell = require_topology().compareCells;
    function Simplex(vertices, adjacent, boundary) {
      this.vertices = vertices;
      this.adjacent = adjacent;
      this.boundary = boundary;
      this.lastVisited = -1;
    }
    Simplex.prototype.flip = function() {
      var t = this.vertices[0];
      this.vertices[0] = this.vertices[1];
      this.vertices[1] = t;
      var u = this.adjacent[0];
      this.adjacent[0] = this.adjacent[1];
      this.adjacent[1] = u;
    };
    function GlueFacet(vertices, cell, index) {
      this.vertices = vertices;
      this.cell = cell;
      this.index = index;
    }
    function compareGlue(a, b) {
      return compareCell(a.vertices, b.vertices);
    }
    function wrapper(test) {
      return function() {
        var tuple = this.tuple;
        return test.apply(this, tuple);
      };
    }
    function bakeOrient(d) {
      var test = orient[d + 1];
      if (!test) {
        test = orient;
      }
      return wrapper(test);
    }
    var BAKED = [];
    function Triangulation(dimension, vertices, simplices) {
      this.dimension = dimension;
      this.vertices = vertices;
      this.simplices = simplices;
      this.interior = simplices.filter(function(c) {
        return !c.boundary;
      });
      this.tuple = new Array(dimension + 1);
      for (var i = 0; i <= dimension; ++i) {
        this.tuple[i] = this.vertices[i];
      }
      var o = BAKED[dimension];
      if (!o) {
        o = BAKED[dimension] = bakeOrient(dimension);
      }
      this.orient = o;
    }
    var proto = Triangulation.prototype;
    proto.handleBoundaryDegeneracy = function(cell, point) {
      var d = this.dimension;
      var n = this.vertices.length - 1;
      var tuple = this.tuple;
      var verts = this.vertices;
      var toVisit = [cell];
      cell.lastVisited = -n;
      while (toVisit.length > 0) {
        cell = toVisit.pop();
        var cellAdj = cell.adjacent;
        for (var i = 0; i <= d; ++i) {
          var neighbor = cellAdj[i];
          if (!neighbor.boundary || neighbor.lastVisited <= -n) {
            continue;
          }
          var nv = neighbor.vertices;
          for (var j = 0; j <= d; ++j) {
            var vv = nv[j];
            if (vv < 0) {
              tuple[j] = point;
            } else {
              tuple[j] = verts[vv];
            }
          }
          var o = this.orient();
          if (o > 0) {
            return neighbor;
          }
          neighbor.lastVisited = -n;
          if (o === 0) {
            toVisit.push(neighbor);
          }
        }
      }
      return null;
    };
    proto.walk = function(point, random) {
      var n = this.vertices.length - 1;
      var d = this.dimension;
      var verts = this.vertices;
      var tuple = this.tuple;
      var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;
      var cell = this.interior[initIndex];
      outerLoop:
        while (!cell.boundary) {
          var cellVerts = cell.vertices;
          var cellAdj = cell.adjacent;
          for (var i = 0; i <= d; ++i) {
            tuple[i] = verts[cellVerts[i]];
          }
          cell.lastVisited = n;
          for (var i = 0; i <= d; ++i) {
            var neighbor = cellAdj[i];
            if (neighbor.lastVisited >= n) {
              continue;
            }
            var prev = tuple[i];
            tuple[i] = point;
            var o = this.orient();
            tuple[i] = prev;
            if (o < 0) {
              cell = neighbor;
              continue outerLoop;
            } else {
              if (!neighbor.boundary) {
                neighbor.lastVisited = n;
              } else {
                neighbor.lastVisited = -n;
              }
            }
          }
          return;
        }
      return cell;
    };
    proto.addPeaks = function(point, cell) {
      var n = this.vertices.length - 1;
      var d = this.dimension;
      var verts = this.vertices;
      var tuple = this.tuple;
      var interior = this.interior;
      var simplices = this.simplices;
      var tovisit = [cell];
      cell.lastVisited = n;
      cell.vertices[cell.vertices.indexOf(-1)] = n;
      cell.boundary = false;
      interior.push(cell);
      var glueFacets = [];
      while (tovisit.length > 0) {
        var cell = tovisit.pop();
        var cellVerts = cell.vertices;
        var cellAdj = cell.adjacent;
        var indexOfN = cellVerts.indexOf(n);
        if (indexOfN < 0) {
          continue;
        }
        for (var i = 0; i <= d; ++i) {
          if (i === indexOfN) {
            continue;
          }
          var neighbor = cellAdj[i];
          if (!neighbor.boundary || neighbor.lastVisited >= n) {
            continue;
          }
          var nv = neighbor.vertices;
          if (neighbor.lastVisited !== -n) {
            var indexOfNeg1 = 0;
            for (var j = 0; j <= d; ++j) {
              if (nv[j] < 0) {
                indexOfNeg1 = j;
                tuple[j] = point;
              } else {
                tuple[j] = verts[nv[j]];
              }
            }
            var o = this.orient();
            if (o > 0) {
              nv[indexOfNeg1] = n;
              neighbor.boundary = false;
              interior.push(neighbor);
              tovisit.push(neighbor);
              neighbor.lastVisited = n;
              continue;
            } else {
              neighbor.lastVisited = -n;
            }
          }
          var na = neighbor.adjacent;
          var vverts = cellVerts.slice();
          var vadj = cellAdj.slice();
          var ncell = new Simplex(vverts, vadj, true);
          simplices.push(ncell);
          var opposite = na.indexOf(cell);
          if (opposite < 0) {
            continue;
          }
          na[opposite] = ncell;
          vadj[indexOfN] = neighbor;
          vverts[i] = -1;
          vadj[i] = cell;
          cellAdj[i] = ncell;
          ncell.flip();
          for (var j = 0; j <= d; ++j) {
            var uu = vverts[j];
            if (uu < 0 || uu === n) {
              continue;
            }
            var nface = new Array(d - 1);
            var nptr = 0;
            for (var k = 0; k <= d; ++k) {
              var vv = vverts[k];
              if (vv < 0 || k === j) {
                continue;
              }
              nface[nptr++] = vv;
            }
            glueFacets.push(new GlueFacet(nface, ncell, j));
          }
        }
      }
      glueFacets.sort(compareGlue);
      for (var i = 0; i + 1 < glueFacets.length; i += 2) {
        var a = glueFacets[i];
        var b = glueFacets[i + 1];
        var ai = a.index;
        var bi = b.index;
        if (ai < 0 || bi < 0) {
          continue;
        }
        a.cell.adjacent[a.index] = b.cell;
        b.cell.adjacent[b.index] = a.cell;
      }
    };
    proto.insert = function(point, random) {
      var verts = this.vertices;
      verts.push(point);
      var cell = this.walk(point, random);
      if (!cell) {
        return;
      }
      var d = this.dimension;
      var tuple = this.tuple;
      for (var i = 0; i <= d; ++i) {
        var vv = cell.vertices[i];
        if (vv < 0) {
          tuple[i] = point;
        } else {
          tuple[i] = verts[vv];
        }
      }
      var o = this.orient(tuple);
      if (o < 0) {
        return;
      } else if (o === 0) {
        cell = this.handleBoundaryDegeneracy(cell, point);
        if (!cell) {
          return;
        }
      }
      this.addPeaks(point, cell);
    };
    proto.boundary = function() {
      var d = this.dimension;
      var boundary = [];
      var cells = this.simplices;
      var nc = cells.length;
      for (var i = 0; i < nc; ++i) {
        var c = cells[i];
        if (c.boundary) {
          var bcell = new Array(d);
          var cv = c.vertices;
          var ptr = 0;
          var parity = 0;
          for (var j = 0; j <= d; ++j) {
            if (cv[j] >= 0) {
              bcell[ptr++] = cv[j];
            } else {
              parity = j & 1;
            }
          }
          if (parity === (d & 1)) {
            var t = bcell[0];
            bcell[0] = bcell[1];
            bcell[1] = t;
          }
          boundary.push(bcell);
        }
      }
      return boundary;
    };
    function incrementalConvexHull(points, randomSearch) {
      var n = points.length;
      if (n === 0) {
        throw new Error("Must have at least d+1 points");
      }
      var d = points[0].length;
      if (n <= d) {
        throw new Error("Must input at least d+1 points");
      }
      var initialSimplex = points.slice(0, d + 1);
      var o = orient.apply(void 0, initialSimplex);
      if (o === 0) {
        throw new Error("Input not in general position");
      }
      var initialCoords = new Array(d + 1);
      for (var i = 0; i <= d; ++i) {
        initialCoords[i] = i;
      }
      if (o < 0) {
        initialCoords[0] = 1;
        initialCoords[1] = 0;
      }
      var initialCell = new Simplex(initialCoords, new Array(d + 1), false);
      var boundary = initialCell.adjacent;
      var list = new Array(d + 2);
      for (var i = 0; i <= d; ++i) {
        var verts = initialCoords.slice();
        for (var j = 0; j <= d; ++j) {
          if (j === i) {
            verts[j] = -1;
          }
        }
        var t = verts[0];
        verts[0] = verts[1];
        verts[1] = t;
        var cell = new Simplex(verts, new Array(d + 1), true);
        boundary[i] = cell;
        list[i] = cell;
      }
      list[d + 1] = initialCell;
      for (var i = 0; i <= d; ++i) {
        var verts = boundary[i].vertices;
        var adj = boundary[i].adjacent;
        for (var j = 0; j <= d; ++j) {
          var v = verts[j];
          if (v < 0) {
            adj[j] = initialCell;
            continue;
          }
          for (var k = 0; k <= d; ++k) {
            if (boundary[k].vertices.indexOf(v) < 0) {
              adj[j] = boundary[k];
            }
          }
        }
      }
      var triangles = new Triangulation(d, initialSimplex, list);
      var useRandom = !!randomSearch;
      for (var i = d + 1; i < n; ++i) {
        triangles.insert(points[i], useRandom);
      }
      return triangles.boundary();
    }
  }
});

// node_modules/uniq/uniq.js
var require_uniq = __commonJS({
  "node_modules/uniq/uniq.js"(exports2, module2) {
    "use strict";
    function unique_pred(list, compare) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i) {
        b = a;
        a = list[i];
        if (compare(a, b)) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique_eq(list) {
      var ptr = 1, len = list.length, a = list[0], b = list[0];
      for (var i = 1; i < len; ++i, b = a) {
        b = a;
        a = list[i];
        if (a !== b) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          list[ptr++] = a;
        }
      }
      list.length = ptr;
      return list;
    }
    function unique(list, compare, sorted) {
      if (list.length === 0) {
        return list;
      }
      if (compare) {
        if (!sorted) {
          list.sort(compare);
        }
        return unique_pred(list, compare);
      }
      if (!sorted) {
        list.sort();
      }
      return unique_eq(list);
    }
    module2.exports = unique;
  }
});

// node_modules/delaunay-triangulate/triangulate.js
var require_triangulate = __commonJS({
  "node_modules/delaunay-triangulate/triangulate.js"(exports2, module2) {
    "use strict";
    var ch = require_ich();
    var uniq = require_uniq();
    module2.exports = triangulate;
    function LiftedPoint(p, i) {
      this.point = p;
      this.index = i;
    }
    function compareLifted(a, b) {
      var ap = a.point;
      var bp = b.point;
      var d = ap.length;
      for (var i = 0; i < d; ++i) {
        var s = bp[i] - ap[i];
        if (s) {
          return s;
        }
      }
      return 0;
    }
    function triangulate1D(n, points, includePointAtInfinity) {
      if (n === 1) {
        if (includePointAtInfinity) {
          return [[-1, 0]];
        } else {
          return [];
        }
      }
      var lifted = points.map(function(p, i2) {
        return [p[0], i2];
      });
      lifted.sort(function(a2, b2) {
        return a2[0] - b2[0];
      });
      var cells = new Array(n - 1);
      for (var i = 1; i < n; ++i) {
        var a = lifted[i - 1];
        var b = lifted[i];
        cells[i - 1] = [a[1], b[1]];
      }
      if (includePointAtInfinity) {
        cells.push(
          [-1, cells[0][1]],
          [cells[n - 1][1], -1]
        );
      }
      return cells;
    }
    function triangulate(points, includePointAtInfinity) {
      var n = points.length;
      if (n === 0) {
        return [];
      }
      var d = points[0].length;
      if (d < 1) {
        return [];
      }
      if (d === 1) {
        return triangulate1D(n, points, includePointAtInfinity);
      }
      var lifted = new Array(n);
      var upper = 1;
      for (var i = 0; i < n; ++i) {
        var p = points[i];
        var x = new Array(d + 1);
        var l = 0;
        for (var j = 0; j < d; ++j) {
          var v = p[j];
          x[j] = v;
          l += v * v;
        }
        x[d] = l;
        lifted[i] = new LiftedPoint(x, i);
        upper = Math.max(l, upper);
      }
      uniq(lifted, compareLifted);
      n = lifted.length;
      var dpoints = new Array(n + d + 1);
      var dindex = new Array(n + d + 1);
      var u = (d + 1) * (d + 1) * upper;
      var y = new Array(d + 1);
      for (var i = 0; i <= d; ++i) {
        y[i] = 0;
      }
      y[d] = u;
      dpoints[0] = y.slice();
      dindex[0] = -1;
      for (var i = 0; i <= d; ++i) {
        var x = y.slice();
        x[i] = 1;
        dpoints[i + 1] = x;
        dindex[i + 1] = -1;
      }
      for (var i = 0; i < n; ++i) {
        var h = lifted[i];
        dpoints[i + d + 1] = h.point;
        dindex[i + d + 1] = h.index;
      }
      var hull = ch(dpoints, false);
      if (includePointAtInfinity) {
        hull = hull.filter(function(cell) {
          var count = 0;
          for (var j2 = 0; j2 <= d; ++j2) {
            var v2 = dindex[cell[j2]];
            if (v2 < 0) {
              if (++count >= 2) {
                return false;
              }
            }
            cell[j2] = v2;
          }
          return true;
        });
      } else {
        hull = hull.filter(function(cell) {
          for (var i2 = 0; i2 <= d; ++i2) {
            var v2 = dindex[cell[i2]];
            if (v2 < 0) {
              return false;
            }
            cell[i2] = v2;
          }
          return true;
        });
      }
      if (d & 1) {
        for (var i = 0; i < hull.length; ++i) {
          var h = hull[i];
          var x = h[0];
          h[0] = h[1];
          h[1] = x;
        }
      }
      return hull;
    }
  }
});

// node_modules/dup/dup.js
var require_dup = __commonJS({
  "node_modules/dup/dup.js"(exports2, module2) {
    "use strict";
    function dupe_array(count, value, i) {
      var c = count[i] | 0;
      if (c <= 0) {
        return [];
      }
      var result = new Array(c), j;
      if (i === count.length - 1) {
        for (j = 0; j < c; ++j) {
          result[j] = value;
        }
      } else {
        for (j = 0; j < c; ++j) {
          result[j] = dupe_array(count, value, i + 1);
        }
      }
      return result;
    }
    function dupe_number(count, value) {
      var result, i;
      result = new Array(count);
      for (i = 0; i < count; ++i) {
        result[i] = value;
      }
      return result;
    }
    function dupe(count, value) {
      if (typeof value === "undefined") {
        value = 0;
      }
      switch (typeof count) {
        case "number":
          if (count > 0) {
            return dupe_number(count | 0, value);
          }
          break;
        case "object":
          if (typeof count.length === "number") {
            return dupe_array(count, value, 0);
          }
          break;
      }
      return [];
    }
    module2.exports = dupe;
  }
});

// node_modules/robust-compress/compress.js
var require_compress = __commonJS({
  "node_modules/robust-compress/compress.js"(exports2, module2) {
    "use strict";
    module2.exports = compressExpansion;
    function compressExpansion(e) {
      var m = e.length;
      var Q = e[e.length - 1];
      var bottom = m;
      for (var i = m - 2; i >= 0; --i) {
        var a = Q;
        var b = e[i];
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) {
          e[--bottom] = Q;
          Q = q;
        }
      }
      var top = 0;
      for (var i = bottom; i < m; ++i) {
        var a = e[i];
        var b = Q;
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) {
          e[top++] = q;
        }
      }
      e[top++] = Q;
      e.length = top;
      return e;
    }
  }
});

// node_modules/robust-determinant/robust-determinant.js
var require_robust_determinant = __commonJS({
  "node_modules/robust-determinant/robust-determinant.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    var compress = require_compress();
    var NUM_EXPANDED = 6;
    function determinant_2(sum, scale, prod, compress2) {
      return function robustDeterminant2(m) {
        return compress2(sum(prod(m[0][0], m[1][1]), prod(-m[0][1], m[1][0])));
      };
    }
    function determinant_3(sum, scale, prod, compress2) {
      return function robustDeterminant3(m) {
        return compress2(sum(scale(sum(prod(m[1][1], m[2][2]), prod(-m[1][2], m[2][1])), m[0][0]), sum(scale(sum(prod(m[1][0], m[2][2]), prod(-m[1][2], m[2][0])), -m[0][1]), scale(sum(prod(m[1][0], m[2][1]), prod(-m[1][1], m[2][0])), m[0][2]))));
      };
    }
    function determinant_4(sum, scale, prod, compress2) {
      return function robustDeterminant4(m) {
        return compress2(sum(sum(scale(sum(scale(sum(prod(m[2][2], m[3][3]), prod(-m[2][3], m[3][2])), m[1][1]), sum(scale(sum(prod(m[2][1], m[3][3]), prod(-m[2][3], m[3][1])), -m[1][2]), scale(sum(prod(m[2][1], m[3][2]), prod(-m[2][2], m[3][1])), m[1][3]))), m[0][0]), scale(sum(scale(sum(prod(m[2][2], m[3][3]), prod(-m[2][3], m[3][2])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][3]), prod(-m[2][3], m[3][0])), -m[1][2]), scale(sum(prod(m[2][0], m[3][2]), prod(-m[2][2], m[3][0])), m[1][3]))), -m[0][1])), sum(scale(sum(scale(sum(prod(m[2][1], m[3][3]), prod(-m[2][3], m[3][1])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][3]), prod(-m[2][3], m[3][0])), -m[1][1]), scale(sum(prod(m[2][0], m[3][1]), prod(-m[2][1], m[3][0])), m[1][3]))), m[0][2]), scale(sum(scale(sum(prod(m[2][1], m[3][2]), prod(-m[2][2], m[3][1])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][2]), prod(-m[2][2], m[3][0])), -m[1][1]), scale(sum(prod(m[2][0], m[3][1]), prod(-m[2][1], m[3][0])), m[1][2]))), -m[0][3]))));
      };
    }
    function determinant_5(sum, scale, prod, compress2) {
      return function robustDeterminant5(m) {
        return compress2(sum(sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][2]), sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), -m[2][3]), scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][4]))), m[1][1]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][3]), scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][4]))), -m[1][2])), sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][3]))), -m[1][4]))), m[0][0]), scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][2]), sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), -m[2][3]), scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][3]), scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), m[2][4]))), -m[1][2])), sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][3]))), -m[1][4]))), -m[0][1])), sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][3]), scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][3]), scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), m[2][4]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][3]))), -m[1][4]))), m[0][2]), sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][4]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][4]))), m[1][2]), scale(sum(scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][2]))), -m[1][4]))), -m[0][3]), scale(sum(sum(scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][3]))), m[1][0]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][3]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][3]))), m[1][2]), scale(sum(scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][2]))), -m[1][3]))), m[0][4])))));
      };
    }
    function compileDeterminant(n) {
      var fn = n === 2 ? determinant_2 : n === 3 ? determinant_3 : n === 4 ? determinant_4 : n === 5 ? determinant_5 : void 0;
      return fn(robustSum, robustScale, twoProduct, compress);
    }
    var CACHE = [
      function robustDeterminant0() {
        return [0];
      },
      function robustDeterminant1(m) {
        return [m[0][0]];
      }
    ];
    function proc(det0, det1, det2, det3, det4, det5, CACHE2, gen) {
      return function robustDeterminant(m) {
        switch (m.length) {
          case 0:
            return det0(m);
          case 1:
            return det1(m);
          case 2:
            return det2(m);
          case 3:
            return det3(m);
          case 4:
            return det4(m);
          case 5:
            return det5(m);
        }
        var det = CACHE2[m.length];
        if (!det) det = CACHE2[m.length] = gen(m.length);
        return det(m);
      };
    }
    function generateDispatch() {
      while (CACHE.length < NUM_EXPANDED) {
        CACHE.push(compileDeterminant(CACHE.length));
      }
      module2.exports = proc.apply(void 0, CACHE.concat([CACHE, compileDeterminant]));
      for (var i = 0; i < CACHE.length; ++i) {
        module2.exports[i] = CACHE[i];
      }
    }
    generateDispatch();
  }
});

// node_modules/robust-linear-solve/linsolve.js
var require_linsolve = __commonJS({
  "node_modules/robust-linear-solve/linsolve.js"(exports2, module2) {
    "use strict";
    var determinant = require_robust_determinant();
    var NUM_EXPAND = 6;
    function generateSolver(n) {
      var fn = n === 2 ? solve2d : n === 3 ? solve3d : n === 4 ? solve4d : n === 5 ? solve5d : solve6d;
      if (n < 6) {
        return fn(determinant[n]);
      }
      return fn(determinant);
    }
    function robustLinearSolve0d() {
      return [[0]];
    }
    function robustLinearSolve1d(A, b) {
      return [[b[0]], [A[0][0]]];
    }
    function solve2d(det) {
      return function robustLinearSolve2d(A, b) {
        return [det([[+b[0], +A[0][1]], [+b[1], +A[1][1]]]), det([[+A[0][0], +b[0]], [+A[1][0], +b[1]]]), det(A)];
      };
    }
    function solve3d(det) {
      return function robustLinearSolve3d(A, b) {
        return [det([[+b[0], +A[0][1], +A[0][2]], [+b[1], +A[1][1], +A[1][2]], [+b[2], +A[2][1], +A[2][2]]]), det([[+A[0][0], +b[0], +A[0][2]], [+A[1][0], +b[1], +A[1][2]], [+A[2][0], +b[2], +A[2][2]]]), det([[+A[0][0], +A[0][1], +b[0]], [+A[1][0], +A[1][1], +b[1]], [+A[2][0], +A[2][1], +b[2]]]), det(A)];
      };
    }
    function solve4d(det) {
      return function robustLinearSolve4d(A, b) {
        return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3]], [+b[1], +A[1][1], +A[1][2], +A[1][3]], [+b[2], +A[2][1], +A[2][2], +A[2][3]], [+b[3], +A[3][1], +A[3][2], +A[3][3]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3]], [+A[1][0], +b[1], +A[1][2], +A[1][3]], [+A[2][0], +b[2], +A[2][2], +A[2][3]], [+A[3][0], +b[3], +A[3][2], +A[3][3]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3]], [+A[1][0], +A[1][1], +b[1], +A[1][3]], [+A[2][0], +A[2][1], +b[2], +A[2][3]], [+A[3][0], +A[3][1], +b[3], +A[3][3]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +b[3]]]), det(A)];
      };
    }
    function solve5d(det) {
      return function robustLinearSolve5d(A, b) {
        return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3], +A[0][4]], [+b[1], +A[1][1], +A[1][2], +A[1][3], +A[1][4]], [+b[2], +A[2][1], +A[2][2], +A[2][3], +A[2][4]], [+b[3], +A[3][1], +A[3][2], +A[3][3], +A[3][4]], [+b[4], +A[4][1], +A[4][2], +A[4][3], +A[4][4]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3], +A[0][4]], [+A[1][0], +b[1], +A[1][2], +A[1][3], +A[1][4]], [+A[2][0], +b[2], +A[2][2], +A[2][3], +A[2][4]], [+A[3][0], +b[3], +A[3][2], +A[3][3], +A[3][4]], [+A[4][0], +b[4], +A[4][2], +A[4][3], +A[4][4]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3], +A[0][4]], [+A[1][0], +A[1][1], +b[1], +A[1][3], +A[1][4]], [+A[2][0], +A[2][1], +b[2], +A[2][3], +A[2][4]], [+A[3][0], +A[3][1], +b[3], +A[3][3], +A[3][4]], [+A[4][0], +A[4][1], +b[4], +A[4][3], +A[4][4]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0], +A[0][4]], [+A[1][0], +A[1][1], +A[1][2], +b[1], +A[1][4]], [+A[2][0], +A[2][1], +A[2][2], +b[2], +A[2][4]], [+A[3][0], +A[3][1], +A[3][2], +b[3], +A[3][4]], [+A[4][0], +A[4][1], +A[4][2], +b[4], +A[4][4]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +b[3]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +b[4]]]), det(A)];
      };
    }
    function solve6d(det) {
      return function robustLinearSolve6d(A, b) {
        return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3], +A[0][4], +A[0][5]], [+b[1], +A[1][1], +A[1][2], +A[1][3], +A[1][4], +A[1][5]], [+b[2], +A[2][1], +A[2][2], +A[2][3], +A[2][4], +A[2][5]], [+b[3], +A[3][1], +A[3][2], +A[3][3], +A[3][4], +A[3][5]], [+b[4], +A[4][1], +A[4][2], +A[4][3], +A[4][4], +A[4][5]], [+b[5], +A[5][1], +A[5][2], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3], +A[0][4], +A[0][5]], [+A[1][0], +b[1], +A[1][2], +A[1][3], +A[1][4], +A[1][5]], [+A[2][0], +b[2], +A[2][2], +A[2][3], +A[2][4], +A[2][5]], [+A[3][0], +b[3], +A[3][2], +A[3][3], +A[3][4], +A[3][5]], [+A[4][0], +b[4], +A[4][2], +A[4][3], +A[4][4], +A[4][5]], [+A[5][0], +b[5], +A[5][2], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3], +A[0][4], +A[0][5]], [+A[1][0], +A[1][1], +b[1], +A[1][3], +A[1][4], +A[1][5]], [+A[2][0], +A[2][1], +b[2], +A[2][3], +A[2][4], +A[2][5]], [+A[3][0], +A[3][1], +b[3], +A[3][3], +A[3][4], +A[3][5]], [+A[4][0], +A[4][1], +b[4], +A[4][3], +A[4][4], +A[4][5]], [+A[5][0], +A[5][1], +b[5], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0], +A[0][4], +A[0][5]], [+A[1][0], +A[1][1], +A[1][2], +b[1], +A[1][4], +A[1][5]], [+A[2][0], +A[2][1], +A[2][2], +b[2], +A[2][4], +A[2][5]], [+A[3][0], +A[3][1], +A[3][2], +b[3], +A[3][4], +A[3][5]], [+A[4][0], +A[4][1], +A[4][2], +b[4], +A[4][4], +A[4][5]], [+A[5][0], +A[5][1], +A[5][2], +b[5], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +b[0], +A[0][5]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +b[1], +A[1][5]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +b[2], +A[2][5]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +b[3], +A[3][5]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +b[4], +A[4][5]], [+A[5][0], +A[5][1], +A[5][2], +A[5][3], +b[5], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +A[0][4], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +A[1][4], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +A[2][4], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +A[3][4], +b[3]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +A[4][4], +b[4]], [+A[5][0], +A[5][1], +A[5][2], +A[5][3], +A[5][4], +b[5]]]), det(A)];
      };
    }
    var CACHE = [
      robustLinearSolve0d,
      robustLinearSolve1d
    ];
    function proc(s0, s1, s2, s3, s4, s5, CACHE2, g) {
      return function dispatchLinearSolve(A, b) {
        switch (A.length) {
          case 0:
            return s0(A, b);
          case 1:
            return s1(A, b);
          case 2:
            return s2(A, b);
          case 3:
            return s3(A, b);
          case 4:
            return s4(A, b);
          case 5:
            return s5(A, b);
        }
        var s = CACHE2[A.length];
        if (!s) s = CACHE2[A.length] = g(A.length);
        return s(A, b);
      };
    }
    function generateDispatch() {
      while (CACHE.length < NUM_EXPAND) {
        CACHE.push(generateSolver(CACHE.length));
      }
      module2.exports = proc.apply(void 0, CACHE.concat([CACHE, generateSolver]));
      for (var i = 0; i < NUM_EXPAND; ++i) {
        module2.exports[i] = CACHE[i];
      }
    }
    generateDispatch();
  }
});

// node_modules/circumcenter/circumcenter.js
var require_circumcenter = __commonJS({
  "node_modules/circumcenter/circumcenter.js"(exports2, module2) {
    "use strict";
    var dup = require_dup();
    var solve = require_linsolve();
    function dot(a, b) {
      var s = 0;
      var d = a.length;
      for (var i = 0; i < d; ++i) {
        s += a[i] * b[i];
      }
      return s;
    }
    function barycentricCircumcenter(points) {
      var N = points.length;
      if (N === 0) {
        return [];
      }
      var D = points[0].length;
      var A = dup([points.length + 1, points.length + 1], 1);
      var b = dup([points.length + 1], 1);
      A[N][N] = 0;
      for (var i = 0; i < N; ++i) {
        for (var j = 0; j <= i; ++j) {
          A[j][i] = A[i][j] = 2 * dot(points[i], points[j]);
        }
        b[i] = dot(points[i], points[i]);
      }
      var x = solve(A, b);
      var denom = 0;
      var h = x[N + 1];
      for (var i = 0; i < h.length; ++i) {
        denom += h[i];
      }
      var y = new Array(N);
      for (var i = 0; i < N; ++i) {
        var h = x[i];
        var numer = 0;
        for (var j = 0; j < h.length; ++j) {
          numer += h[j];
        }
        y[i] = numer / denom;
      }
      return y;
    }
    function circumcenter(points) {
      if (points.length === 0) {
        return [];
      }
      var D = points[0].length;
      var result = dup([D]);
      var weights = barycentricCircumcenter(points);
      for (var i = 0; i < points.length; ++i) {
        for (var j = 0; j < D; ++j) {
          result[j] += points[i][j] * weights[i];
        }
      }
      return result;
    }
    circumcenter.barycenetric = barycentricCircumcenter;
    module2.exports = circumcenter;
  }
});

// node_modules/circumradius/crad.js
var require_crad = __commonJS({
  "node_modules/circumradius/crad.js"(exports2, module2) {
    module2.exports = circumradius;
    var circumcenter = require_circumcenter();
    function circumradius(points) {
      var center = circumcenter(points);
      var avgDist = 0;
      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        for (var j = 0; j < center.length; ++j) {
          avgDist += Math.pow(p[j] - center[j], 2);
        }
      }
      return Math.sqrt(avgDist / points.length);
    }
  }
});

// node_modules/alpha-complex/alpha.js
var require_alpha = __commonJS({
  "node_modules/alpha-complex/alpha.js"(exports2, module2) {
    "use strict";
    module2.exports = alphaComplex;
    var delaunay = require_triangulate();
    var circumradius = require_crad();
    function alphaComplex(alpha, points) {
      return delaunay(points).filter(function(cell) {
        var simplex = new Array(cell.length);
        for (var i = 0; i < cell.length; ++i) {
          simplex[i] = points[cell[i]];
        }
        return circumradius(simplex) * alpha < 1;
      });
    }
  }
});

// node_modules/boundary-cells/boundary.js
var require_boundary = __commonJS({
  "node_modules/boundary-cells/boundary.js"(exports2, module2) {
    "use strict";
    module2.exports = boundary;
    function boundary(cells) {
      var i, j, k;
      var n = cells.length;
      var sz = 0;
      for (i = 0; i < n; ++i) {
        sz += cells[i].length;
      }
      var result = new Array(sz);
      var ptr = 0;
      for (i = 0; i < n; ++i) {
        var c = cells[i];
        var d = c.length;
        for (j = 0; j < d; ++j) {
          var b = result[ptr++] = new Array(d - 1);
          var p = 0;
          for (k = 0; k < d; ++k) {
            if (k === j) {
              continue;
            }
            b[p++] = c[k];
          }
          if (j & 1) {
            var tmp = b[1];
            b[1] = b[0];
            b[0] = tmp;
          }
        }
      }
      return result;
    }
  }
});

// node_modules/compare-cell/compare.js
var require_compare = __commonJS({
  "node_modules/compare-cell/compare.js"(exports2, module2) {
    module2.exports = compareCells;
    var min = Math.min;
    function compareInt(a, b) {
      return a - b;
    }
    function compareCells(a, b) {
      var n = a.length, t = a.length - b.length;
      if (t) {
        return t;
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          return a[0] - b[0];
        case 2:
          return a[0] + a[1] - b[0] - b[1] || min(a[0], a[1]) - min(b[0], b[1]);
        case 3:
          var l1 = a[0] + a[1], m1 = b[0] + b[1];
          t = l1 + a[2] - (m1 + b[2]);
          if (t) {
            return t;
          }
          var l0 = min(a[0], a[1]), m0 = min(b[0], b[1]);
          return min(l0, a[2]) - min(m0, b[2]) || min(l0 + a[2], l1) - min(m0 + b[2], m1);
        case 4:
          var aw = a[0], ax = a[1], ay = a[2], az = a[3], bw = b[0], bx = b[1], by = b[2], bz = b[3];
          return aw + ax + ay + az - (bw + bx + by + bz) || min(aw, ax, ay, az) - min(bw, bx, by, bz, bw) || min(aw + ax, aw + ay, aw + az, ax + ay, ax + az, ay + az) - min(bw + bx, bw + by, bw + bz, bx + by, bx + bz, by + bz) || min(aw + ax + ay, aw + ax + az, aw + ay + az, ax + ay + az) - min(bw + bx + by, bw + bx + bz, bw + by + bz, bx + by + bz);
        default:
          var as = a.slice().sort(compareInt);
          var bs = b.slice().sort(compareInt);
          for (var i = 0; i < n; ++i) {
            t = as[i] - bs[i];
            if (t) {
              return t;
            }
          }
          return 0;
      }
    }
  }
});

// node_modules/cell-orientation/orientation.js
var require_orientation2 = __commonJS({
  "node_modules/cell-orientation/orientation.js"(exports2, module2) {
    "use strict";
    module2.exports = orientation;
    function orientation(s) {
      var p = 1;
      for (var i = 1; i < s.length; ++i) {
        for (var j = 0; j < i; ++j) {
          if (s[i] < s[j]) {
            p = -p;
          } else if (s[j] === s[i]) {
            return 0;
          }
        }
      }
      return p;
    }
  }
});

// node_modules/compare-oriented-cell/compare.js
var require_compare2 = __commonJS({
  "node_modules/compare-oriented-cell/compare.js"(exports2, module2) {
    "use strict";
    var compareCells = require_compare();
    var parity = require_orientation2();
    module2.exports = compareOrientedCells;
    function compareOrientedCells(a, b) {
      return compareCells(a, b) || parity(a) - parity(b);
    }
  }
});

// node_modules/reduce-simplicial-complex/reduce.js
var require_reduce = __commonJS({
  "node_modules/reduce-simplicial-complex/reduce.js"(exports2, module2) {
    "use strict";
    var compareCell = require_compare();
    var compareOrientedCell = require_compare2();
    var orientation = require_orientation2();
    module2.exports = reduceCellComplex;
    function reduceCellComplex(cells) {
      cells.sort(compareOrientedCell);
      var n = cells.length;
      var ptr = 0;
      for (var i = 0; i < n; ++i) {
        var c = cells[i];
        var o = orientation(c);
        if (o === 0) {
          continue;
        }
        if (ptr > 0) {
          var f = cells[ptr - 1];
          if (compareCell(c, f) === 0 && orientation(f) !== o) {
            ptr -= 1;
            continue;
          }
        }
        cells[ptr++] = c;
      }
      cells.length = ptr;
      return cells;
    }
  }
});

// node_modules/simplicial-complex-boundary/boundary.js
var require_boundary2 = __commonJS({
  "node_modules/simplicial-complex-boundary/boundary.js"(exports2, module2) {
    "use strict";
    module2.exports = boundary;
    var bnd = require_boundary();
    var reduce = require_reduce();
    function boundary(cells) {
      return reduce(bnd(cells));
    }
  }
});

// node_modules/alpha-shape/alpha.js
var require_alpha2 = __commonJS({
  "node_modules/alpha-shape/alpha.js"(exports2, module2) {
    module2.exports = alphaShape;
    var ac = require_alpha();
    var bnd = require_boundary2();
    function alphaShape(alpha, points) {
      return bnd(ac(alpha, points));
    }
  }
});

// node_modules/convex-hull/lib/ch1d.js
var require_ch1d = __commonJS({
  "node_modules/convex-hull/lib/ch1d.js"(exports2, module2) {
    "use strict";
    module2.exports = convexHull1d;
    function convexHull1d(points) {
      var lo = 0;
      var hi = 0;
      for (var i = 1; i < points.length; ++i) {
        if (points[i][0] < points[lo][0]) {
          lo = i;
        }
        if (points[i][0] > points[hi][0]) {
          hi = i;
        }
      }
      if (lo < hi) {
        return [[lo], [hi]];
      } else if (lo > hi) {
        return [[hi], [lo]];
      } else {
        return [[lo]];
      }
    }
  }
});

// node_modules/monotone-convex-hull-2d/index.js
var require_monotone_convex_hull_2d = __commonJS({
  "node_modules/monotone-convex-hull-2d/index.js"(exports2, module2) {
    "use strict";
    module2.exports = monotoneConvexHull2D;
    var orient = require_orientation()[3];
    function monotoneConvexHull2D(points) {
      var n = points.length;
      if (n < 3) {
        var result = new Array(n);
        for (var i = 0; i < n; ++i) {
          result[i] = i;
        }
        if (n === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {
          return [0];
        }
        return result;
      }
      var sorted = new Array(n);
      for (var i = 0; i < n; ++i) {
        sorted[i] = i;
      }
      sorted.sort(function(a, b) {
        var d = points[a][0] - points[b][0];
        if (d) {
          return d;
        }
        return points[a][1] - points[b][1];
      });
      var lower = [sorted[0], sorted[1]];
      var upper = [sorted[0], sorted[1]];
      for (var i = 2; i < n; ++i) {
        var idx = sorted[i];
        var p = points[idx];
        var m = lower.length;
        while (m > 1 && orient(
          points[lower[m - 2]],
          points[lower[m - 1]],
          p
        ) <= 0) {
          m -= 1;
          lower.pop();
        }
        lower.push(idx);
        m = upper.length;
        while (m > 1 && orient(
          points[upper[m - 2]],
          points[upper[m - 1]],
          p
        ) >= 0) {
          m -= 1;
          upper.pop();
        }
        upper.push(idx);
      }
      var result = new Array(upper.length + lower.length - 2);
      var ptr = 0;
      for (var i = 0, nl = lower.length; i < nl; ++i) {
        result[ptr++] = lower[i];
      }
      for (var j = upper.length - 2; j > 0; --j) {
        result[ptr++] = upper[j];
      }
      return result;
    }
  }
});

// node_modules/convex-hull/lib/ch2d.js
var require_ch2d = __commonJS({
  "node_modules/convex-hull/lib/ch2d.js"(exports2, module2) {
    "use strict";
    module2.exports = convexHull2D;
    var monotoneHull = require_monotone_convex_hull_2d();
    function convexHull2D(points) {
      var hull = monotoneHull(points);
      var h = hull.length;
      if (h <= 2) {
        return [];
      }
      var edges = new Array(h);
      var a = hull[h - 1];
      for (var i = 0; i < h; ++i) {
        var b = hull[i];
        edges[i] = [a, b];
        a = b;
      }
      return edges;
    }
  }
});

// node_modules/affine-hull/aff.js
var require_aff = __commonJS({
  "node_modules/affine-hull/aff.js"(exports2, module2) {
    "use strict";
    module2.exports = affineHull;
    var orient = require_orientation();
    function linearlyIndependent(points, d) {
      var nhull = new Array(d + 1);
      for (var i = 0; i < points.length; ++i) {
        nhull[i] = points[i];
      }
      for (var i = 0; i <= points.length; ++i) {
        for (var j = points.length; j <= d; ++j) {
          var x = new Array(d);
          for (var k = 0; k < d; ++k) {
            x[k] = Math.pow(j + 1 - i, k);
          }
          nhull[j] = x;
        }
        var o = orient.apply(void 0, nhull);
        if (o) {
          return true;
        }
      }
      return false;
    }
    function affineHull(points) {
      var n = points.length;
      if (n === 0) {
        return [];
      }
      if (n === 1) {
        return [0];
      }
      var d = points[0].length;
      var frame = [points[0]];
      var index = [0];
      for (var i = 1; i < n; ++i) {
        frame.push(points[i]);
        if (!linearlyIndependent(frame, d)) {
          frame.pop();
          continue;
        }
        index.push(i);
        if (index.length === d + 1) {
          return index;
        }
      }
      return index;
    }
  }
});

// node_modules/convex-hull/lib/chnd.js
var require_chnd = __commonJS({
  "node_modules/convex-hull/lib/chnd.js"(exports2, module2) {
    "use strict";
    module2.exports = convexHullnD;
    var ich = require_ich();
    var aff = require_aff();
    function permute(points, front) {
      var n = points.length;
      var npoints = new Array(n);
      for (var i = 0; i < front.length; ++i) {
        npoints[i] = points[front[i]];
      }
      var ptr = front.length;
      for (var i = 0; i < n; ++i) {
        if (front.indexOf(i) < 0) {
          npoints[ptr++] = points[i];
        }
      }
      return npoints;
    }
    function invPermute(cells, front) {
      var nc = cells.length;
      var nf = front.length;
      for (var i = 0; i < nc; ++i) {
        var c = cells[i];
        for (var j = 0; j < c.length; ++j) {
          var x = c[j];
          if (x < nf) {
            c[j] = front[x];
          } else {
            x = x - nf;
            for (var k = 0; k < nf; ++k) {
              if (x >= front[k]) {
                x += 1;
              }
            }
            c[j] = x;
          }
        }
      }
      return cells;
    }
    function convexHullnD(points, d) {
      try {
        return ich(points, true);
      } catch (e) {
        var ah = aff(points);
        if (ah.length <= d) {
          return [];
        }
        var npoints = permute(points, ah);
        var nhull = ich(npoints, true);
        return invPermute(nhull, ah);
      }
    }
  }
});

// node_modules/convex-hull/ch.js
var require_ch = __commonJS({
  "node_modules/convex-hull/ch.js"(exports2, module2) {
    "use strict";
    var convexHull1d = require_ch1d();
    var convexHull2d = require_ch2d();
    var convexHullnd = require_chnd();
    module2.exports = convexHull;
    function convexHull(points) {
      var n = points.length;
      if (n === 0) {
        return [];
      } else if (n === 1) {
        return [[0]];
      }
      var d = points[0].length;
      if (d === 0) {
        return [];
      } else if (d === 1) {
        return convexHull1d(points);
      } else if (d === 2) {
        return convexHull2d(points);
      }
      return convexHullnd(points, d);
    }
  }
});

// node_modules/gl-vec3/epsilon.js
var require_epsilon = __commonJS({
  "node_modules/gl-vec3/epsilon.js"(exports2, module2) {
    module2.exports = 1e-6;
  }
});

// node_modules/gl-vec3/create.js
var require_create = __commonJS({
  "node_modules/gl-vec3/create.js"(exports2, module2) {
    module2.exports = create;
    function create() {
      var out = new Float32Array(3);
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      return out;
    }
  }
});

// node_modules/gl-vec3/clone.js
var require_clone = __commonJS({
  "node_modules/gl-vec3/clone.js"(exports2, module2) {
    module2.exports = clone;
    function clone(a) {
      var out = new Float32Array(3);
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/fromValues.js
var require_fromValues = __commonJS({
  "node_modules/gl-vec3/fromValues.js"(exports2, module2) {
    module2.exports = fromValues;
    function fromValues(x, y, z) {
      var out = new Float32Array(3);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// node_modules/gl-vec3/normalize.js
var require_normalize = __commonJS({
  "node_modules/gl-vec3/normalize.js"(exports2, module2) {
    module2.exports = normalize;
    function normalize(out, a) {
      var x = a[0], y = a[1], z = a[2];
      var len = x * x + y * y + z * z;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
      }
      return out;
    }
  }
});

// node_modules/gl-vec3/dot.js
var require_dot = __commonJS({
  "node_modules/gl-vec3/dot.js"(exports2, module2) {
    module2.exports = dot;
    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
  }
});

// node_modules/gl-vec3/angle.js
var require_angle = __commonJS({
  "node_modules/gl-vec3/angle.js"(exports2, module2) {
    module2.exports = angle;
    var fromValues = require_fromValues();
    var normalize = require_normalize();
    var dot = require_dot();
    function angle(a, b) {
      var tempA = fromValues(a[0], a[1], a[2]);
      var tempB = fromValues(b[0], b[1], b[2]);
      normalize(tempA, tempA);
      normalize(tempB, tempB);
      var cosine = dot(tempA, tempB);
      if (cosine > 1) {
        return 0;
      } else {
        return Math.acos(cosine);
      }
    }
  }
});

// node_modules/gl-vec3/copy.js
var require_copy = __commonJS({
  "node_modules/gl-vec3/copy.js"(exports2, module2) {
    module2.exports = copy;
    function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/set.js
var require_set = __commonJS({
  "node_modules/gl-vec3/set.js"(exports2, module2) {
    module2.exports = set;
    function set(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// node_modules/gl-vec3/equals.js
var require_equals = __commonJS({
  "node_modules/gl-vec3/equals.js"(exports2, module2) {
    module2.exports = equals;
    var EPSILON = require_epsilon();
    function equals(a, b) {
      var a0 = a[0];
      var a1 = a[1];
      var a2 = a[2];
      var b0 = b[0];
      var b1 = b[1];
      var b2 = b[2];
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
    }
  }
});

// node_modules/gl-vec3/exactEquals.js
var require_exactEquals = __commonJS({
  "node_modules/gl-vec3/exactEquals.js"(exports2, module2) {
    module2.exports = exactEquals;
    function exactEquals(a, b) {
      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
    }
  }
});

// node_modules/gl-vec3/add.js
var require_add = __commonJS({
  "node_modules/gl-vec3/add.js"(exports2, module2) {
    module2.exports = add;
    function add(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/subtract.js
var require_subtract = __commonJS({
  "node_modules/gl-vec3/subtract.js"(exports2, module2) {
    module2.exports = subtract;
    function subtract(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/sub.js
var require_sub = __commonJS({
  "node_modules/gl-vec3/sub.js"(exports2, module2) {
    module2.exports = require_subtract();
  }
});

// node_modules/gl-vec3/multiply.js
var require_multiply = __commonJS({
  "node_modules/gl-vec3/multiply.js"(exports2, module2) {
    module2.exports = multiply;
    function multiply(out, a, b) {
      out[0] = a[0] * b[0];
      out[1] = a[1] * b[1];
      out[2] = a[2] * b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/mul.js
var require_mul = __commonJS({
  "node_modules/gl-vec3/mul.js"(exports2, module2) {
    module2.exports = require_multiply();
  }
});

// node_modules/gl-vec3/divide.js
var require_divide = __commonJS({
  "node_modules/gl-vec3/divide.js"(exports2, module2) {
    module2.exports = divide;
    function divide(out, a, b) {
      out[0] = a[0] / b[0];
      out[1] = a[1] / b[1];
      out[2] = a[2] / b[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/div.js
var require_div = __commonJS({
  "node_modules/gl-vec3/div.js"(exports2, module2) {
    module2.exports = require_divide();
  }
});

// node_modules/gl-vec3/min.js
var require_min = __commonJS({
  "node_modules/gl-vec3/min.js"(exports2, module2) {
    module2.exports = min;
    function min(out, a, b) {
      out[0] = Math.min(a[0], b[0]);
      out[1] = Math.min(a[1], b[1]);
      out[2] = Math.min(a[2], b[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/max.js
var require_max = __commonJS({
  "node_modules/gl-vec3/max.js"(exports2, module2) {
    module2.exports = max;
    function max(out, a, b) {
      out[0] = Math.max(a[0], b[0]);
      out[1] = Math.max(a[1], b[1]);
      out[2] = Math.max(a[2], b[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/floor.js
var require_floor = __commonJS({
  "node_modules/gl-vec3/floor.js"(exports2, module2) {
    module2.exports = floor;
    function floor(out, a) {
      out[0] = Math.floor(a[0]);
      out[1] = Math.floor(a[1]);
      out[2] = Math.floor(a[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/ceil.js
var require_ceil = __commonJS({
  "node_modules/gl-vec3/ceil.js"(exports2, module2) {
    module2.exports = ceil;
    function ceil(out, a) {
      out[0] = Math.ceil(a[0]);
      out[1] = Math.ceil(a[1]);
      out[2] = Math.ceil(a[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/round.js
var require_round = __commonJS({
  "node_modules/gl-vec3/round.js"(exports2, module2) {
    module2.exports = round;
    function round(out, a) {
      out[0] = Math.round(a[0]);
      out[1] = Math.round(a[1]);
      out[2] = Math.round(a[2]);
      return out;
    }
  }
});

// node_modules/gl-vec3/scale.js
var require_scale = __commonJS({
  "node_modules/gl-vec3/scale.js"(exports2, module2) {
    module2.exports = scale;
    function scale(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      return out;
    }
  }
});

// node_modules/gl-vec3/scaleAndAdd.js
var require_scaleAndAdd = __commonJS({
  "node_modules/gl-vec3/scaleAndAdd.js"(exports2, module2) {
    module2.exports = scaleAndAdd;
    function scaleAndAdd(out, a, b, scale) {
      out[0] = a[0] + b[0] * scale;
      out[1] = a[1] + b[1] * scale;
      out[2] = a[2] + b[2] * scale;
      return out;
    }
  }
});

// node_modules/gl-vec3/distance.js
var require_distance = __commonJS({
  "node_modules/gl-vec3/distance.js"(exports2, module2) {
    module2.exports = distance;
    function distance(a, b) {
      var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// node_modules/gl-vec3/dist.js
var require_dist = __commonJS({
  "node_modules/gl-vec3/dist.js"(exports2, module2) {
    module2.exports = require_distance();
  }
});

// node_modules/gl-vec3/squaredDistance.js
var require_squaredDistance = __commonJS({
  "node_modules/gl-vec3/squaredDistance.js"(exports2, module2) {
    module2.exports = squaredDistance;
    function squaredDistance(a, b) {
      var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
      return x * x + y * y + z * z;
    }
  }
});

// node_modules/gl-vec3/sqrDist.js
var require_sqrDist = __commonJS({
  "node_modules/gl-vec3/sqrDist.js"(exports2, module2) {
    module2.exports = require_squaredDistance();
  }
});

// node_modules/gl-vec3/length.js
var require_length = __commonJS({
  "node_modules/gl-vec3/length.js"(exports2, module2) {
    module2.exports = length;
    function length(a) {
      var x = a[0], y = a[1], z = a[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// node_modules/gl-vec3/len.js
var require_len = __commonJS({
  "node_modules/gl-vec3/len.js"(exports2, module2) {
    module2.exports = require_length();
  }
});

// node_modules/gl-vec3/squaredLength.js
var require_squaredLength = __commonJS({
  "node_modules/gl-vec3/squaredLength.js"(exports2, module2) {
    module2.exports = squaredLength;
    function squaredLength(a) {
      var x = a[0], y = a[1], z = a[2];
      return x * x + y * y + z * z;
    }
  }
});

// node_modules/gl-vec3/sqrLen.js
var require_sqrLen = __commonJS({
  "node_modules/gl-vec3/sqrLen.js"(exports2, module2) {
    module2.exports = require_squaredLength();
  }
});

// node_modules/gl-vec3/negate.js
var require_negate = __commonJS({
  "node_modules/gl-vec3/negate.js"(exports2, module2) {
    module2.exports = negate;
    function negate(out, a) {
      out[0] = -a[0];
      out[1] = -a[1];
      out[2] = -a[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/inverse.js
var require_inverse = __commonJS({
  "node_modules/gl-vec3/inverse.js"(exports2, module2) {
    module2.exports = inverse;
    function inverse(out, a) {
      out[0] = 1 / a[0];
      out[1] = 1 / a[1];
      out[2] = 1 / a[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/cross.js
var require_cross = __commonJS({
  "node_modules/gl-vec3/cross.js"(exports2, module2) {
    module2.exports = cross;
    function cross(out, a, b) {
      var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
  }
});

// node_modules/gl-vec3/lerp.js
var require_lerp = __commonJS({
  "node_modules/gl-vec3/lerp.js"(exports2, module2) {
    module2.exports = lerp;
    function lerp(out, a, b, t) {
      var ax = a[0], ay = a[1], az = a[2];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      return out;
    }
  }
});

// node_modules/gl-vec3/random.js
var require_random = __commonJS({
  "node_modules/gl-vec3/random.js"(exports2, module2) {
    module2.exports = random;
    function random(out, scale) {
      scale = scale || 1;
      var r = Math.random() * 2 * Math.PI;
      var z = Math.random() * 2 - 1;
      var zScale = Math.sqrt(1 - z * z) * scale;
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }
  }
});

// node_modules/gl-vec3/transformMat4.js
var require_transformMat4 = __commonJS({
  "node_modules/gl-vec3/transformMat4.js"(exports2, module2) {
    module2.exports = transformMat4;
    function transformMat4(out, a, m) {
      var x = a[0], y = a[1], z = a[2], w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
    }
  }
});

// node_modules/gl-vec3/transformMat3.js
var require_transformMat3 = __commonJS({
  "node_modules/gl-vec3/transformMat3.js"(exports2, module2) {
    module2.exports = transformMat3;
    function transformMat3(out, a, m) {
      var x = a[0], y = a[1], z = a[2];
      out[0] = x * m[0] + y * m[3] + z * m[6];
      out[1] = x * m[1] + y * m[4] + z * m[7];
      out[2] = x * m[2] + y * m[5] + z * m[8];
      return out;
    }
  }
});

// node_modules/gl-vec3/transformQuat.js
var require_transformQuat = __commonJS({
  "node_modules/gl-vec3/transformQuat.js"(exports2, module2) {
    module2.exports = transformQuat;
    function transformQuat(out, a, q) {
      var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
      out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateX.js
var require_rotateX = __commonJS({
  "node_modules/gl-vec3/rotateX.js"(exports2, module2) {
    module2.exports = rotateX;
    function rotateX(out, a, b, c) {
      var by = b[1];
      var bz = b[2];
      var py = a[1] - by;
      var pz = a[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = a[0];
      out[1] = by + py * cc - pz * sc;
      out[2] = bz + py * sc + pz * cc;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateY.js
var require_rotateY = __commonJS({
  "node_modules/gl-vec3/rotateY.js"(exports2, module2) {
    module2.exports = rotateY;
    function rotateY(out, a, b, c) {
      var bx = b[0];
      var bz = b[2];
      var px = a[0] - bx;
      var pz = a[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + pz * sc + px * cc;
      out[1] = a[1];
      out[2] = bz + pz * cc - px * sc;
      return out;
    }
  }
});

// node_modules/gl-vec3/rotateZ.js
var require_rotateZ = __commonJS({
  "node_modules/gl-vec3/rotateZ.js"(exports2, module2) {
    module2.exports = rotateZ;
    function rotateZ(out, a, b, c) {
      var bx = b[0];
      var by = b[1];
      var px = a[0] - bx;
      var py = a[1] - by;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + px * cc - py * sc;
      out[1] = by + px * sc + py * cc;
      out[2] = a[2];
      return out;
    }
  }
});

// node_modules/gl-vec3/forEach.js
var require_forEach = __commonJS({
  "node_modules/gl-vec3/forEach.js"(exports2, module2) {
    module2.exports = forEach;
    var vec = require_create()();
    function forEach(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    }
  }
});

// node_modules/gl-vec3/index.js
var require_gl_vec3 = __commonJS({
  "node_modules/gl-vec3/index.js"(exports2, module2) {
    module2.exports = {
      EPSILON: require_epsilon(),
      create: require_create(),
      clone: require_clone(),
      angle: require_angle(),
      fromValues: require_fromValues(),
      copy: require_copy(),
      set: require_set(),
      equals: require_equals(),
      exactEquals: require_exactEquals(),
      add: require_add(),
      subtract: require_subtract(),
      sub: require_sub(),
      multiply: require_multiply(),
      mul: require_mul(),
      divide: require_divide(),
      div: require_div(),
      min: require_min(),
      max: require_max(),
      floor: require_floor(),
      ceil: require_ceil(),
      round: require_round(),
      scale: require_scale(),
      scaleAndAdd: require_scaleAndAdd(),
      distance: require_distance(),
      dist: require_dist(),
      squaredDistance: require_squaredDistance(),
      sqrDist: require_sqrDist(),
      length: require_length(),
      len: require_len(),
      squaredLength: require_squaredLength(),
      sqrLen: require_sqrLen(),
      negate: require_negate(),
      inverse: require_inverse(),
      normalize: require_normalize(),
      dot: require_dot(),
      cross: require_cross(),
      lerp: require_lerp(),
      random: require_random(),
      transformMat4: require_transformMat4(),
      transformMat3: require_transformMat3(),
      transformQuat: require_transformQuat(),
      rotateX: require_rotateX(),
      rotateY: require_rotateY(),
      rotateZ: require_rotateZ(),
      forEach: require_forEach()
    };
  }
});

// node_modules/glslify/browser.js
var require_browser = __commonJS({
  "node_modules/glslify/browser.js"(exports2, module2) {
    module2.exports = function(strings) {
      if (typeof strings === "string") strings = [strings];
      var exprs = [].slice.call(arguments, 1);
      var parts = [];
      for (var i = 0; i < strings.length - 1; i++) {
        parts.push(strings[i], exprs[i] || "");
      }
      parts.push(strings[i]);
      return parts.join("");
    };
  }
});

// node_modules/gl-cone3d/lib/shaders.js
var require_shaders = __commonJS({
  "node_modules/gl-cone3d/lib/shaders.js"(exports2) {
    var glslify = require_browser();
    var triVertSrc = glslify("./triangle-vertex.glsl");
    var triFragSrc = glslify("./triangle-fragment.glsl");
    var pickVertSrc = glslify("./pick-vertex.glsl");
    var pickFragSrc = glslify("./pick-fragment.glsl");
    exports2.meshShader = {
      vertex: triVertSrc,
      fragment: triFragSrc,
      attributes: [
        { name: "position", type: "vec4" },
        { name: "color", type: "vec4" },
        { name: "uv", type: "vec2" },
        { name: "vector", type: "vec3" }
      ]
    };
    exports2.pickShader = {
      vertex: pickVertSrc,
      fragment: pickFragSrc,
      attributes: [
        { name: "position", type: "vec4" },
        { name: "id", type: "vec4" },
        { name: "vector", type: "vec3" }
      ]
    };
  }
});

// node_modules/gl-shader/lib/reflect.js
var require_reflect = __commonJS({
  "node_modules/gl-shader/lib/reflect.js"(exports2, module2) {
    "use strict";
    module2.exports = makeReflectTypes;
    function makeReflectTypes(uniforms, useIndex) {
      var obj = {};
      for (var i = 0; i < uniforms.length; ++i) {
        var n = uniforms[i].name;
        var parts = n.split(".");
        var o = obj;
        for (var j = 0; j < parts.length; ++j) {
          var x = parts[j].split("[");
          if (x.length > 1) {
            if (!(x[0] in o)) {
              o[x[0]] = [];
            }
            o = o[x[0]];
            for (var k = 1; k < x.length; ++k) {
              var y = parseInt(x[k]);
              if (k < x.length - 1 || j < parts.length - 1) {
                if (!(y in o)) {
                  if (k < x.length - 1) {
                    o[y] = [];
                  } else {
                    o[y] = {};
                  }
                }
                o = o[y];
              } else {
                if (useIndex) {
                  o[y] = i;
                } else {
                  o[y] = uniforms[i].type;
                }
              }
            }
          } else if (j < parts.length - 1) {
            if (!(x[0] in o)) {
              o[x[0]] = {};
            }
            o = o[x[0]];
          } else {
            if (useIndex) {
              o[x[0]] = i;
            } else {
              o[x[0]] = uniforms[i].type;
            }
          }
        }
      }
      return obj;
    }
  }
});

// node_modules/gl-shader/lib/GLError.js
var require_GLError = __commonJS({
  "node_modules/gl-shader/lib/GLError.js"(exports2, module2) {
    function GLError(rawError, shortMessage, longMessage) {
      this.shortMessage = shortMessage || "";
      this.longMessage = longMessage || "";
      this.rawError = rawError || "";
      this.message = "gl-shader: " + (shortMessage || rawError || "") + (longMessage ? "\n" + longMessage : "");
      this.stack = new Error().stack;
    }
    GLError.prototype = new Error();
    GLError.prototype.name = "GLError";
    GLError.prototype.constructor = GLError;
    module2.exports = GLError;
  }
});

// node_modules/gl-shader/lib/create-uniforms.js
var require_create_uniforms = __commonJS({
  "node_modules/gl-shader/lib/create-uniforms.js"(exports2, module2) {
    "use strict";
    var coallesceUniforms = require_reflect();
    var GLError = require_GLError();
    module2.exports = createUniformWrapper;
    function identity(x) {
      return function() {
        return x;
      };
    }
    function makeVector(length, fill) {
      var result = new Array(length);
      for (var i = 0; i < length; ++i) {
        result[i] = fill;
      }
      return result;
    }
    function createUniformWrapper(gl2, wrapper, uniforms, locations) {
      function makeGetter(idx) {
        return function(gl3, wrapper2, locations2) {
          return gl3.getUniform(wrapper2.program, locations2[idx]);
        };
      }
      function makeSetter(type) {
        return function updateProperty(obj) {
          var indices = enumerateIndices("", type);
          for (var i = 0; i < indices.length; ++i) {
            var item = indices[i];
            var path = item[0];
            var idx = item[1];
            if (locations[idx]) {
              var objPath = obj;
              if (typeof path === "string" && (path.indexOf(".") === 0 || path.indexOf("[") === 0)) {
                var key = path;
                if (path.indexOf(".") === 0) {
                  key = path.slice(1);
                }
                if (key.indexOf("]") === key.length - 1) {
                  var j = key.indexOf("[");
                  var k1 = key.slice(0, j);
                  var k2 = key.slice(j + 1, key.length - 1);
                  objPath = k1 ? obj[k1][k2] : obj[k2];
                } else {
                  objPath = obj[key];
                }
              }
              var t = uniforms[idx].type;
              var d;
              switch (t) {
                case "bool":
                case "int":
                case "sampler2D":
                case "samplerCube":
                  gl2.uniform1i(locations[idx], objPath);
                  break;
                case "float":
                  gl2.uniform1f(locations[idx], objPath);
                  break;
                default:
                  var vidx = t.indexOf("vec");
                  if (0 <= vidx && vidx <= 1 && t.length === 4 + vidx) {
                    d = t.charCodeAt(t.length - 1) - 48;
                    if (d < 2 || d > 4) {
                      throw new GLError("", "Invalid data type");
                    }
                    switch (t.charAt(0)) {
                      case "b":
                      case "i":
                        gl2["uniform" + d + "iv"](locations[idx], objPath);
                        break;
                      case "v":
                        gl2["uniform" + d + "fv"](locations[idx], objPath);
                        break;
                      default:
                        throw new GLError("", "Unrecognized data type for vector " + name + ": " + t);
                    }
                  } else if (t.indexOf("mat") === 0 && t.length === 4) {
                    d = t.charCodeAt(t.length - 1) - 48;
                    if (d < 2 || d > 4) {
                      throw new GLError("", "Invalid uniform dimension type for matrix " + name + ": " + t);
                    }
                    gl2["uniformMatrix" + d + "fv"](locations[idx], false, objPath);
                    break;
                  } else {
                    throw new GLError("", "Unknown uniform data type for " + name + ": " + t);
                  }
              }
            }
          }
        };
      }
      function enumerateIndices(prefix, type) {
        if (typeof type !== "object") {
          return [[prefix, type]];
        }
        var indices = [];
        for (var id in type) {
          var prop = type[id];
          var tprefix = prefix;
          if (parseInt(id) + "" === id) {
            tprefix += "[" + id + "]";
          } else {
            tprefix += "." + id;
          }
          if (typeof prop === "object") {
            indices.push.apply(indices, enumerateIndices(tprefix, prop));
          } else {
            indices.push([tprefix, prop]);
          }
        }
        return indices;
      }
      function defaultValue(type) {
        switch (type) {
          case "bool":
            return false;
          case "int":
          case "sampler2D":
          case "samplerCube":
            return 0;
          case "float":
            return 0;
          default:
            var vidx = type.indexOf("vec");
            if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type");
              }
              if (type.charAt(0) === "b") {
                return makeVector(d, false);
              }
              return makeVector(d, 0);
            } else if (type.indexOf("mat") === 0 && type.length === 4) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid uniform dimension type for matrix " + name + ": " + type);
              }
              return makeVector(d * d, 0);
            } else {
              throw new GLError("", "Unknown uniform data type for " + name + ": " + type);
            }
        }
      }
      function storeProperty(obj, prop, type) {
        if (typeof type === "object") {
          var child = processObject(type);
          Object.defineProperty(obj, prop, {
            get: identity(child),
            set: makeSetter(type),
            enumerable: true,
            configurable: false
          });
        } else {
          if (locations[type]) {
            Object.defineProperty(obj, prop, {
              get: makeGetter(type),
              set: makeSetter(type),
              enumerable: true,
              configurable: false
            });
          } else {
            obj[prop] = defaultValue(uniforms[type].type);
          }
        }
      }
      function processObject(obj) {
        var result;
        if (Array.isArray(obj)) {
          result = new Array(obj.length);
          for (var i = 0; i < obj.length; ++i) {
            storeProperty(result, i, obj[i]);
          }
        } else {
          result = {};
          for (var id in obj) {
            storeProperty(result, id, obj[id]);
          }
        }
        return result;
      }
      var coallesced = coallesceUniforms(uniforms, true);
      return {
        get: identity(processObject(coallesced)),
        set: makeSetter(coallesced),
        enumerable: true,
        configurable: true
      };
    }
  }
});

// node_modules/gl-shader/lib/create-attributes.js
var require_create_attributes = __commonJS({
  "node_modules/gl-shader/lib/create-attributes.js"(exports2, module2) {
    "use strict";
    module2.exports = createAttributeWrapper;
    var GLError = require_GLError();
    function ShaderAttribute(gl2, wrapper, index, locations, dimension, constFunc) {
      this._gl = gl2;
      this._wrapper = wrapper;
      this._index = index;
      this._locations = locations;
      this._dimension = dimension;
      this._constFunc = constFunc;
    }
    var proto = ShaderAttribute.prototype;
    proto.pointer = function setAttribPointer(type, normalized, stride, offset) {
      var self = this;
      var gl2 = self._gl;
      var location = self._locations[self._index];
      gl2.vertexAttribPointer(
        location,
        self._dimension,
        type || gl2.FLOAT,
        !!normalized,
        stride || 0,
        offset || 0
      );
      gl2.enableVertexAttribArray(location);
    };
    proto.set = function(x0, x1, x2, x3) {
      return this._constFunc(this._locations[this._index], x0, x1, x2, x3);
    };
    Object.defineProperty(proto, "location", {
      get: function() {
        return this._locations[this._index];
      },
      set: function(v) {
        if (v !== this._locations[this._index]) {
          this._locations[this._index] = v | 0;
          this._wrapper.program = null;
        }
        return v | 0;
      }
    });
    var allFns = [
      function(gl2, v, x0) {
        if (x0.length === void 0) {
          return gl2.vertexAttrib1f(v, x0);
        } else {
          return gl2.vertexAttrib1fv(v, x0);
        }
      },
      function(gl2, v, x0, x1) {
        if (x0.length === void 0) {
          return gl2.vertexAttrib2f(v, x0, x1);
        } else {
          return gl2.vertexAttrib2fv(v, x0);
        }
      },
      function(gl2, v, x0, x1, x2) {
        if (x0.length === void 0) {
          return gl2.vertexAttrib3f(v, x0, x1, x2);
        } else {
          return gl2.vertexAttrib3fv(v, x0);
        }
      },
      function(gl2, v, x0, x1, x2, x3) {
        if (x0.length === void 0) {
          return gl2.vertexAttrib4f(v, x0, x1, x2, x3);
        } else {
          return gl2.vertexAttrib4fv(v, x0);
        }
      }
    ];
    function addVectorAttribute(gl2, wrapper, index, locations, dimension, obj, name2) {
      var constFunc = allFns[dimension];
      var attr = new ShaderAttribute(
        gl2,
        wrapper,
        index,
        locations,
        dimension,
        constFunc
      );
      Object.defineProperty(obj, name2, {
        set: function(x) {
          gl2.disableVertexAttribArray(locations[index]);
          constFunc(gl2, locations[index], x);
          return x;
        },
        get: function() {
          return attr;
        },
        enumerable: true
      });
    }
    function addMatrixAttribute(gl2, wrapper, index, locations, dimension, obj, name2) {
      var parts = new Array(dimension);
      var attrs = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        addVectorAttribute(
          gl2,
          wrapper,
          index[i],
          locations,
          dimension,
          parts,
          i
        );
        attrs[i] = parts[i];
      }
      Object.defineProperty(parts, "location", {
        set: function(v) {
          if (Array.isArray(v)) {
            for (var i2 = 0; i2 < dimension; ++i2) {
              attrs[i2].location = v[i2];
            }
          } else {
            for (var i2 = 0; i2 < dimension; ++i2) {
              attrs[i2].location = v + i2;
            }
          }
          return v;
        },
        get: function() {
          var result = new Array(dimension);
          for (var i2 = 0; i2 < dimension; ++i2) {
            result[i2] = locations[index[i2]];
          }
          return result;
        },
        enumerable: true
      });
      parts.pointer = function(type, normalized, stride, offset) {
        type = type || gl2.FLOAT;
        normalized = !!normalized;
        stride = stride || dimension * dimension;
        offset = offset || 0;
        for (var i2 = 0; i2 < dimension; ++i2) {
          var location = locations[index[i2]];
          gl2.vertexAttribPointer(
            location,
            dimension,
            type,
            normalized,
            stride,
            offset + i2 * dimension
          );
          gl2.enableVertexAttribArray(location);
        }
      };
      var scratch = new Array(dimension);
      var vertexAttrib = gl2["vertexAttrib" + dimension + "fv"];
      Object.defineProperty(obj, name2, {
        set: function(x) {
          for (var i2 = 0; i2 < dimension; ++i2) {
            var loc = locations[index[i2]];
            gl2.disableVertexAttribArray(loc);
            if (Array.isArray(x[0])) {
              vertexAttrib.call(gl2, loc, x[i2]);
            } else {
              for (var j = 0; j < dimension; ++j) {
                scratch[j] = x[dimension * i2 + j];
              }
              vertexAttrib.call(gl2, loc, scratch);
            }
          }
          return x;
        },
        get: function() {
          return parts;
        },
        enumerable: true
      });
    }
    function createAttributeWrapper(gl2, wrapper, attributes, locations) {
      var obj = {};
      for (var i = 0, n = attributes.length; i < n; ++i) {
        var a = attributes[i];
        var name2 = a.name;
        var type = a.type;
        var locs = a.locations;
        switch (type) {
          case "bool":
          case "int":
          case "float":
            addVectorAttribute(
              gl2,
              wrapper,
              locs[0],
              locations,
              1,
              obj,
              name2
            );
            break;
          default:
            if (type.indexOf("vec") >= 0) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type for attribute " + name2 + ": " + type);
              }
              addVectorAttribute(
                gl2,
                wrapper,
                locs[0],
                locations,
                d,
                obj,
                name2
              );
            } else if (type.indexOf("mat") >= 0) {
              var d = type.charCodeAt(type.length - 1) - 48;
              if (d < 2 || d > 4) {
                throw new GLError("", "Invalid data type for attribute " + name2 + ": " + type);
              }
              addMatrixAttribute(
                gl2,
                wrapper,
                locs,
                locations,
                d,
                obj,
                name2
              );
            } else {
              throw new GLError("", "Unknown data type for attribute " + name2 + ": " + type);
            }
            break;
        }
      }
      return obj;
    }
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/gl-constants/1.0/numbers.js
var require_numbers = __commonJS({
  "node_modules/gl-constants/1.0/numbers.js"(exports2, module2) {
    module2.exports = {
      0: "NONE",
      1: "ONE",
      2: "LINE_LOOP",
      3: "LINE_STRIP",
      4: "TRIANGLES",
      5: "TRIANGLE_STRIP",
      6: "TRIANGLE_FAN",
      256: "DEPTH_BUFFER_BIT",
      512: "NEVER",
      513: "LESS",
      514: "EQUAL",
      515: "LEQUAL",
      516: "GREATER",
      517: "NOTEQUAL",
      518: "GEQUAL",
      519: "ALWAYS",
      768: "SRC_COLOR",
      769: "ONE_MINUS_SRC_COLOR",
      770: "SRC_ALPHA",
      771: "ONE_MINUS_SRC_ALPHA",
      772: "DST_ALPHA",
      773: "ONE_MINUS_DST_ALPHA",
      774: "DST_COLOR",
      775: "ONE_MINUS_DST_COLOR",
      776: "SRC_ALPHA_SATURATE",
      1024: "STENCIL_BUFFER_BIT",
      1028: "FRONT",
      1029: "BACK",
      1032: "FRONT_AND_BACK",
      1280: "INVALID_ENUM",
      1281: "INVALID_VALUE",
      1282: "INVALID_OPERATION",
      1285: "OUT_OF_MEMORY",
      1286: "INVALID_FRAMEBUFFER_OPERATION",
      2304: "CW",
      2305: "CCW",
      2849: "LINE_WIDTH",
      2884: "CULL_FACE",
      2885: "CULL_FACE_MODE",
      2886: "FRONT_FACE",
      2928: "DEPTH_RANGE",
      2929: "DEPTH_TEST",
      2930: "DEPTH_WRITEMASK",
      2931: "DEPTH_CLEAR_VALUE",
      2932: "DEPTH_FUNC",
      2960: "STENCIL_TEST",
      2961: "STENCIL_CLEAR_VALUE",
      2962: "STENCIL_FUNC",
      2963: "STENCIL_VALUE_MASK",
      2964: "STENCIL_FAIL",
      2965: "STENCIL_PASS_DEPTH_FAIL",
      2966: "STENCIL_PASS_DEPTH_PASS",
      2967: "STENCIL_REF",
      2968: "STENCIL_WRITEMASK",
      2978: "VIEWPORT",
      3024: "DITHER",
      3042: "BLEND",
      3088: "SCISSOR_BOX",
      3089: "SCISSOR_TEST",
      3106: "COLOR_CLEAR_VALUE",
      3107: "COLOR_WRITEMASK",
      3317: "UNPACK_ALIGNMENT",
      3333: "PACK_ALIGNMENT",
      3379: "MAX_TEXTURE_SIZE",
      3386: "MAX_VIEWPORT_DIMS",
      3408: "SUBPIXEL_BITS",
      3410: "RED_BITS",
      3411: "GREEN_BITS",
      3412: "BLUE_BITS",
      3413: "ALPHA_BITS",
      3414: "DEPTH_BITS",
      3415: "STENCIL_BITS",
      3553: "TEXTURE_2D",
      4352: "DONT_CARE",
      4353: "FASTEST",
      4354: "NICEST",
      5120: "BYTE",
      5121: "UNSIGNED_BYTE",
      5122: "SHORT",
      5123: "UNSIGNED_SHORT",
      5124: "INT",
      5125: "UNSIGNED_INT",
      5126: "FLOAT",
      5386: "INVERT",
      5890: "TEXTURE",
      6401: "STENCIL_INDEX",
      6402: "DEPTH_COMPONENT",
      6406: "ALPHA",
      6407: "RGB",
      6408: "RGBA",
      6409: "LUMINANCE",
      6410: "LUMINANCE_ALPHA",
      7680: "KEEP",
      7681: "REPLACE",
      7682: "INCR",
      7683: "DECR",
      7936: "VENDOR",
      7937: "RENDERER",
      7938: "VERSION",
      9728: "NEAREST",
      9729: "LINEAR",
      9984: "NEAREST_MIPMAP_NEAREST",
      9985: "LINEAR_MIPMAP_NEAREST",
      9986: "NEAREST_MIPMAP_LINEAR",
      9987: "LINEAR_MIPMAP_LINEAR",
      10240: "TEXTURE_MAG_FILTER",
      10241: "TEXTURE_MIN_FILTER",
      10242: "TEXTURE_WRAP_S",
      10243: "TEXTURE_WRAP_T",
      10497: "REPEAT",
      10752: "POLYGON_OFFSET_UNITS",
      16384: "COLOR_BUFFER_BIT",
      32769: "CONSTANT_COLOR",
      32770: "ONE_MINUS_CONSTANT_COLOR",
      32771: "CONSTANT_ALPHA",
      32772: "ONE_MINUS_CONSTANT_ALPHA",
      32773: "BLEND_COLOR",
      32774: "FUNC_ADD",
      32777: "BLEND_EQUATION_RGB",
      32778: "FUNC_SUBTRACT",
      32779: "FUNC_REVERSE_SUBTRACT",
      32819: "UNSIGNED_SHORT_4_4_4_4",
      32820: "UNSIGNED_SHORT_5_5_5_1",
      32823: "POLYGON_OFFSET_FILL",
      32824: "POLYGON_OFFSET_FACTOR",
      32854: "RGBA4",
      32855: "RGB5_A1",
      32873: "TEXTURE_BINDING_2D",
      32926: "SAMPLE_ALPHA_TO_COVERAGE",
      32928: "SAMPLE_COVERAGE",
      32936: "SAMPLE_BUFFERS",
      32937: "SAMPLES",
      32938: "SAMPLE_COVERAGE_VALUE",
      32939: "SAMPLE_COVERAGE_INVERT",
      32968: "BLEND_DST_RGB",
      32969: "BLEND_SRC_RGB",
      32970: "BLEND_DST_ALPHA",
      32971: "BLEND_SRC_ALPHA",
      33071: "CLAMP_TO_EDGE",
      33170: "GENERATE_MIPMAP_HINT",
      33189: "DEPTH_COMPONENT16",
      33306: "DEPTH_STENCIL_ATTACHMENT",
      33635: "UNSIGNED_SHORT_5_6_5",
      33648: "MIRRORED_REPEAT",
      33901: "ALIASED_POINT_SIZE_RANGE",
      33902: "ALIASED_LINE_WIDTH_RANGE",
      33984: "TEXTURE0",
      33985: "TEXTURE1",
      33986: "TEXTURE2",
      33987: "TEXTURE3",
      33988: "TEXTURE4",
      33989: "TEXTURE5",
      33990: "TEXTURE6",
      33991: "TEXTURE7",
      33992: "TEXTURE8",
      33993: "TEXTURE9",
      33994: "TEXTURE10",
      33995: "TEXTURE11",
      33996: "TEXTURE12",
      33997: "TEXTURE13",
      33998: "TEXTURE14",
      33999: "TEXTURE15",
      34e3: "TEXTURE16",
      34001: "TEXTURE17",
      34002: "TEXTURE18",
      34003: "TEXTURE19",
      34004: "TEXTURE20",
      34005: "TEXTURE21",
      34006: "TEXTURE22",
      34007: "TEXTURE23",
      34008: "TEXTURE24",
      34009: "TEXTURE25",
      34010: "TEXTURE26",
      34011: "TEXTURE27",
      34012: "TEXTURE28",
      34013: "TEXTURE29",
      34014: "TEXTURE30",
      34015: "TEXTURE31",
      34016: "ACTIVE_TEXTURE",
      34024: "MAX_RENDERBUFFER_SIZE",
      34041: "DEPTH_STENCIL",
      34055: "INCR_WRAP",
      34056: "DECR_WRAP",
      34067: "TEXTURE_CUBE_MAP",
      34068: "TEXTURE_BINDING_CUBE_MAP",
      34069: "TEXTURE_CUBE_MAP_POSITIVE_X",
      34070: "TEXTURE_CUBE_MAP_NEGATIVE_X",
      34071: "TEXTURE_CUBE_MAP_POSITIVE_Y",
      34072: "TEXTURE_CUBE_MAP_NEGATIVE_Y",
      34073: "TEXTURE_CUBE_MAP_POSITIVE_Z",
      34074: "TEXTURE_CUBE_MAP_NEGATIVE_Z",
      34076: "MAX_CUBE_MAP_TEXTURE_SIZE",
      34338: "VERTEX_ATTRIB_ARRAY_ENABLED",
      34339: "VERTEX_ATTRIB_ARRAY_SIZE",
      34340: "VERTEX_ATTRIB_ARRAY_STRIDE",
      34341: "VERTEX_ATTRIB_ARRAY_TYPE",
      34342: "CURRENT_VERTEX_ATTRIB",
      34373: "VERTEX_ATTRIB_ARRAY_POINTER",
      34466: "NUM_COMPRESSED_TEXTURE_FORMATS",
      34467: "COMPRESSED_TEXTURE_FORMATS",
      34660: "BUFFER_SIZE",
      34661: "BUFFER_USAGE",
      34816: "STENCIL_BACK_FUNC",
      34817: "STENCIL_BACK_FAIL",
      34818: "STENCIL_BACK_PASS_DEPTH_FAIL",
      34819: "STENCIL_BACK_PASS_DEPTH_PASS",
      34877: "BLEND_EQUATION_ALPHA",
      34921: "MAX_VERTEX_ATTRIBS",
      34922: "VERTEX_ATTRIB_ARRAY_NORMALIZED",
      34930: "MAX_TEXTURE_IMAGE_UNITS",
      34962: "ARRAY_BUFFER",
      34963: "ELEMENT_ARRAY_BUFFER",
      34964: "ARRAY_BUFFER_BINDING",
      34965: "ELEMENT_ARRAY_BUFFER_BINDING",
      34975: "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
      35040: "STREAM_DRAW",
      35044: "STATIC_DRAW",
      35048: "DYNAMIC_DRAW",
      35632: "FRAGMENT_SHADER",
      35633: "VERTEX_SHADER",
      35660: "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
      35661: "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
      35663: "SHADER_TYPE",
      35664: "FLOAT_VEC2",
      35665: "FLOAT_VEC3",
      35666: "FLOAT_VEC4",
      35667: "INT_VEC2",
      35668: "INT_VEC3",
      35669: "INT_VEC4",
      35670: "BOOL",
      35671: "BOOL_VEC2",
      35672: "BOOL_VEC3",
      35673: "BOOL_VEC4",
      35674: "FLOAT_MAT2",
      35675: "FLOAT_MAT3",
      35676: "FLOAT_MAT4",
      35678: "SAMPLER_2D",
      35680: "SAMPLER_CUBE",
      35712: "DELETE_STATUS",
      35713: "COMPILE_STATUS",
      35714: "LINK_STATUS",
      35715: "VALIDATE_STATUS",
      35716: "INFO_LOG_LENGTH",
      35717: "ATTACHED_SHADERS",
      35718: "ACTIVE_UNIFORMS",
      35719: "ACTIVE_UNIFORM_MAX_LENGTH",
      35720: "SHADER_SOURCE_LENGTH",
      35721: "ACTIVE_ATTRIBUTES",
      35722: "ACTIVE_ATTRIBUTE_MAX_LENGTH",
      35724: "SHADING_LANGUAGE_VERSION",
      35725: "CURRENT_PROGRAM",
      36003: "STENCIL_BACK_REF",
      36004: "STENCIL_BACK_VALUE_MASK",
      36005: "STENCIL_BACK_WRITEMASK",
      36006: "FRAMEBUFFER_BINDING",
      36007: "RENDERBUFFER_BINDING",
      36048: "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
      36049: "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
      36050: "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
      36051: "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
      36053: "FRAMEBUFFER_COMPLETE",
      36054: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
      36055: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
      36057: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
      36061: "FRAMEBUFFER_UNSUPPORTED",
      36064: "COLOR_ATTACHMENT0",
      36096: "DEPTH_ATTACHMENT",
      36128: "STENCIL_ATTACHMENT",
      36160: "FRAMEBUFFER",
      36161: "RENDERBUFFER",
      36162: "RENDERBUFFER_WIDTH",
      36163: "RENDERBUFFER_HEIGHT",
      36164: "RENDERBUFFER_INTERNAL_FORMAT",
      36168: "STENCIL_INDEX8",
      36176: "RENDERBUFFER_RED_SIZE",
      36177: "RENDERBUFFER_GREEN_SIZE",
      36178: "RENDERBUFFER_BLUE_SIZE",
      36179: "RENDERBUFFER_ALPHA_SIZE",
      36180: "RENDERBUFFER_DEPTH_SIZE",
      36181: "RENDERBUFFER_STENCIL_SIZE",
      36194: "RGB565",
      36336: "LOW_FLOAT",
      36337: "MEDIUM_FLOAT",
      36338: "HIGH_FLOAT",
      36339: "LOW_INT",
      36340: "MEDIUM_INT",
      36341: "HIGH_INT",
      36346: "SHADER_COMPILER",
      36347: "MAX_VERTEX_UNIFORM_VECTORS",
      36348: "MAX_VARYING_VECTORS",
      36349: "MAX_FRAGMENT_UNIFORM_VECTORS",
      37440: "UNPACK_FLIP_Y_WEBGL",
      37441: "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
      37442: "CONTEXT_LOST_WEBGL",
      37443: "UNPACK_COLORSPACE_CONVERSION_WEBGL",
      37444: "BROWSER_DEFAULT_WEBGL"
    };
  }
});

// node_modules/gl-constants/lookup.js
var require_lookup = __commonJS({
  "node_modules/gl-constants/lookup.js"(exports2, module2) {
    var gl10 = require_numbers();
    module2.exports = function lookupConstant(number) {
      return gl10[number];
    };
  }
});

// node_modules/glsl-tokenizer/lib/literals.js
var require_literals = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals.js"(exports2, module2) {
    module2.exports = [
      // current
      "precision",
      "highp",
      "mediump",
      "lowp",
      "attribute",
      "const",
      "uniform",
      "varying",
      "break",
      "continue",
      "do",
      "for",
      "while",
      "if",
      "else",
      "in",
      "out",
      "inout",
      "float",
      "int",
      "uint",
      "void",
      "bool",
      "true",
      "false",
      "discard",
      "return",
      "mat2",
      "mat3",
      "mat4",
      "vec2",
      "vec3",
      "vec4",
      "ivec2",
      "ivec3",
      "ivec4",
      "bvec2",
      "bvec3",
      "bvec4",
      "sampler1D",
      "sampler2D",
      "sampler3D",
      "samplerCube",
      "sampler1DShadow",
      "sampler2DShadow",
      "struct",
      "asm",
      "class",
      "union",
      "enum",
      "typedef",
      "template",
      "this",
      "packed",
      "goto",
      "switch",
      "default",
      "inline",
      "noinline",
      "volatile",
      "public",
      "static",
      "extern",
      "external",
      "interface",
      "long",
      "short",
      "double",
      "half",
      "fixed",
      "unsigned",
      "input",
      "output",
      "hvec2",
      "hvec3",
      "hvec4",
      "dvec2",
      "dvec3",
      "dvec4",
      "fvec2",
      "fvec3",
      "fvec4",
      "sampler2DRect",
      "sampler3DRect",
      "sampler2DRectShadow",
      "sizeof",
      "cast",
      "namespace",
      "using"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/operators.js
var require_operators = __commonJS({
  "node_modules/glsl-tokenizer/lib/operators.js"(exports2, module2) {
    module2.exports = [
      "<<=",
      ">>=",
      "++",
      "--",
      "<<",
      ">>",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "&=",
      "^^",
      "^=",
      "|=",
      "(",
      ")",
      "[",
      "]",
      ".",
      "!",
      "~",
      "*",
      "/",
      "%",
      "+",
      "-",
      "<",
      ">",
      "&",
      "^",
      "|",
      "?",
      ":",
      "=",
      ",",
      ";",
      "{",
      "}"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins.js"(exports2, module2) {
    module2.exports = [
      // Keep this list sorted
      "abs",
      "acos",
      "all",
      "any",
      "asin",
      "atan",
      "ceil",
      "clamp",
      "cos",
      "cross",
      "dFdx",
      "dFdy",
      "degrees",
      "distance",
      "dot",
      "equal",
      "exp",
      "exp2",
      "faceforward",
      "floor",
      "fract",
      "gl_BackColor",
      "gl_BackLightModelProduct",
      "gl_BackLightProduct",
      "gl_BackMaterial",
      "gl_BackSecondaryColor",
      "gl_ClipPlane",
      "gl_ClipVertex",
      "gl_Color",
      "gl_DepthRange",
      "gl_DepthRangeParameters",
      "gl_EyePlaneQ",
      "gl_EyePlaneR",
      "gl_EyePlaneS",
      "gl_EyePlaneT",
      "gl_Fog",
      "gl_FogCoord",
      "gl_FogFragCoord",
      "gl_FogParameters",
      "gl_FragColor",
      "gl_FragCoord",
      "gl_FragData",
      "gl_FragDepth",
      "gl_FragDepthEXT",
      "gl_FrontColor",
      "gl_FrontFacing",
      "gl_FrontLightModelProduct",
      "gl_FrontLightProduct",
      "gl_FrontMaterial",
      "gl_FrontSecondaryColor",
      "gl_LightModel",
      "gl_LightModelParameters",
      "gl_LightModelProducts",
      "gl_LightProducts",
      "gl_LightSource",
      "gl_LightSourceParameters",
      "gl_MaterialParameters",
      "gl_MaxClipPlanes",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxDrawBuffers",
      "gl_MaxFragmentUniformComponents",
      "gl_MaxLights",
      "gl_MaxTextureCoords",
      "gl_MaxTextureImageUnits",
      "gl_MaxTextureUnits",
      "gl_MaxVaryingFloats",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxVertexUniformComponents",
      "gl_ModelViewMatrix",
      "gl_ModelViewMatrixInverse",
      "gl_ModelViewMatrixInverseTranspose",
      "gl_ModelViewMatrixTranspose",
      "gl_ModelViewProjectionMatrix",
      "gl_ModelViewProjectionMatrixInverse",
      "gl_ModelViewProjectionMatrixInverseTranspose",
      "gl_ModelViewProjectionMatrixTranspose",
      "gl_MultiTexCoord0",
      "gl_MultiTexCoord1",
      "gl_MultiTexCoord2",
      "gl_MultiTexCoord3",
      "gl_MultiTexCoord4",
      "gl_MultiTexCoord5",
      "gl_MultiTexCoord6",
      "gl_MultiTexCoord7",
      "gl_Normal",
      "gl_NormalMatrix",
      "gl_NormalScale",
      "gl_ObjectPlaneQ",
      "gl_ObjectPlaneR",
      "gl_ObjectPlaneS",
      "gl_ObjectPlaneT",
      "gl_Point",
      "gl_PointCoord",
      "gl_PointParameters",
      "gl_PointSize",
      "gl_Position",
      "gl_ProjectionMatrix",
      "gl_ProjectionMatrixInverse",
      "gl_ProjectionMatrixInverseTranspose",
      "gl_ProjectionMatrixTranspose",
      "gl_SecondaryColor",
      "gl_TexCoord",
      "gl_TextureEnvColor",
      "gl_TextureMatrix",
      "gl_TextureMatrixInverse",
      "gl_TextureMatrixInverseTranspose",
      "gl_TextureMatrixTranspose",
      "gl_Vertex",
      "greaterThan",
      "greaterThanEqual",
      "inversesqrt",
      "length",
      "lessThan",
      "lessThanEqual",
      "log",
      "log2",
      "matrixCompMult",
      "max",
      "min",
      "mix",
      "mod",
      "normalize",
      "not",
      "notEqual",
      "pow",
      "radians",
      "reflect",
      "refract",
      "sign",
      "sin",
      "smoothstep",
      "sqrt",
      "step",
      "tan",
      "texture2D",
      "texture2DLod",
      "texture2DProj",
      "texture2DProjLod",
      "textureCube",
      "textureCubeLod",
      "texture2DLodEXT",
      "texture2DProjLodEXT",
      "textureCubeLodEXT",
      "texture2DGradEXT",
      "texture2DProjGradEXT",
      "textureCubeGradEXT"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/literals-300es.js
var require_literals_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals-300es.js"(exports2, module2) {
    var v100 = require_literals();
    module2.exports = v100.slice().concat([
      "layout",
      "centroid",
      "smooth",
      "case",
      "mat2x2",
      "mat2x3",
      "mat2x4",
      "mat3x2",
      "mat3x3",
      "mat3x4",
      "mat4x2",
      "mat4x3",
      "mat4x4",
      "uvec2",
      "uvec3",
      "uvec4",
      "samplerCubeShadow",
      "sampler2DArray",
      "sampler2DArrayShadow",
      "isampler2D",
      "isampler3D",
      "isamplerCube",
      "isampler2DArray",
      "usampler2D",
      "usampler3D",
      "usamplerCube",
      "usampler2DArray",
      "coherent",
      "restrict",
      "readonly",
      "writeonly",
      "resource",
      "atomic_uint",
      "noperspective",
      "patch",
      "sample",
      "subroutine",
      "common",
      "partition",
      "active",
      "filter",
      "image1D",
      "image2D",
      "image3D",
      "imageCube",
      "iimage1D",
      "iimage2D",
      "iimage3D",
      "iimageCube",
      "uimage1D",
      "uimage2D",
      "uimage3D",
      "uimageCube",
      "image1DArray",
      "image2DArray",
      "iimage1DArray",
      "iimage2DArray",
      "uimage1DArray",
      "uimage2DArray",
      "image1DShadow",
      "image2DShadow",
      "image1DArrayShadow",
      "image2DArrayShadow",
      "imageBuffer",
      "iimageBuffer",
      "uimageBuffer",
      "sampler1DArray",
      "sampler1DArrayShadow",
      "isampler1D",
      "isampler1DArray",
      "usampler1D",
      "usampler1DArray",
      "isampler2DRect",
      "usampler2DRect",
      "samplerBuffer",
      "isamplerBuffer",
      "usamplerBuffer",
      "sampler2DMS",
      "isampler2DMS",
      "usampler2DMS",
      "sampler2DMSArray",
      "isampler2DMSArray",
      "usampler2DMSArray"
    ]);
  }
});

// node_modules/glsl-tokenizer/lib/builtins-300es.js
var require_builtins_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins-300es.js"(exports2, module2) {
    var v100 = require_builtins();
    v100 = v100.slice().filter(function(b) {
      return !/^(gl\_|texture)/.test(b);
    });
    module2.exports = v100.concat([
      // the updated gl_ constants
      "gl_VertexID",
      "gl_InstanceID",
      "gl_Position",
      "gl_PointSize",
      "gl_FragCoord",
      "gl_FrontFacing",
      "gl_FragDepth",
      "gl_PointCoord",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexUniformVectors",
      "gl_MaxVertexOutputVectors",
      "gl_MaxFragmentInputVectors",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxTextureImageUnits",
      "gl_MaxFragmentUniformVectors",
      "gl_MaxDrawBuffers",
      "gl_MinProgramTexelOffset",
      "gl_MaxProgramTexelOffset",
      "gl_DepthRangeParameters",
      "gl_DepthRange",
      "trunc",
      "round",
      "roundEven",
      "isnan",
      "isinf",
      "floatBitsToInt",
      "floatBitsToUint",
      "intBitsToFloat",
      "uintBitsToFloat",
      "packSnorm2x16",
      "unpackSnorm2x16",
      "packUnorm2x16",
      "unpackUnorm2x16",
      "packHalf2x16",
      "unpackHalf2x16",
      "outerProduct",
      "transpose",
      "determinant",
      "inverse",
      "texture",
      "textureSize",
      "textureProj",
      "textureLod",
      "textureOffset",
      "texelFetch",
      "texelFetchOffset",
      "textureProjOffset",
      "textureLodOffset",
      "textureProjLod",
      "textureProjLodOffset",
      "textureGrad",
      "textureGradOffset",
      "textureProjGrad",
      "textureProjGradOffset"
    ]);
  }
});

// node_modules/glsl-tokenizer/index.js
var require_glsl_tokenizer = __commonJS({
  "node_modules/glsl-tokenizer/index.js"(exports2, module2) {
    module2.exports = tokenize;
    var literals100 = require_literals();
    var operators = require_operators();
    var builtins100 = require_builtins();
    var literals300es = require_literals_300es();
    var builtins300es = require_builtins_300es();
    var NORMAL = 999;
    var TOKEN = 9999;
    var BLOCK_COMMENT = 0;
    var LINE_COMMENT = 1;
    var PREPROCESSOR = 2;
    var OPERATOR = 3;
    var INTEGER = 4;
    var FLOAT = 5;
    var IDENT = 6;
    var BUILTIN = 7;
    var KEYWORD = 8;
    var WHITESPACE = 9;
    var EOF = 10;
    var HEX = 11;
    var map = [
      "block-comment",
      "line-comment",
      "preprocessor",
      "operator",
      "integer",
      "float",
      "ident",
      "builtin",
      "keyword",
      "whitespace",
      "eof",
      "integer"
    ];
    function tokenize(opt) {
      var i = 0, total = 0, mode = NORMAL, c, last, content = [], tokens = [], token_idx = 0, token_offs = 0, line = 1, col = 0, start = 0, isnum = false, isoperator = false, input = "", len;
      opt = opt || {};
      var allBuiltins = builtins100;
      var allLiterals = literals100;
      if (opt.version === "300 es") {
        allBuiltins = builtins300es;
        allLiterals = literals300es;
      }
      var builtinsDict = {}, literalsDict = {};
      for (var i = 0; i < allBuiltins.length; i++) {
        builtinsDict[allBuiltins[i]] = true;
      }
      for (var i = 0; i < allLiterals.length; i++) {
        literalsDict[allLiterals[i]] = true;
      }
      return function(data) {
        tokens = [];
        if (data !== null) return write(data);
        return end();
      };
      function token(data) {
        if (data.length) {
          tokens.push({
            type: map[mode],
            data,
            position: start,
            line,
            column: col
          });
        }
      }
      function write(chunk) {
        i = 0;
        if (chunk.toString) chunk = chunk.toString();
        input += chunk.replace(/\r\n/g, "\n");
        len = input.length;
        var last2;
        while (c = input[i], i < len) {
          last2 = i;
          switch (mode) {
            case BLOCK_COMMENT:
              i = block_comment();
              break;
            case LINE_COMMENT:
              i = line_comment();
              break;
            case PREPROCESSOR:
              i = preprocessor();
              break;
            case OPERATOR:
              i = operator();
              break;
            case INTEGER:
              i = integer();
              break;
            case HEX:
              i = hex();
              break;
            case FLOAT:
              i = decimal();
              break;
            case TOKEN:
              i = readtoken();
              break;
            case WHITESPACE:
              i = whitespace();
              break;
            case NORMAL:
              i = normal();
              break;
          }
          if (last2 !== i) {
            switch (input[last2]) {
              case "\n":
                col = 0;
                ++line;
                break;
              default:
                ++col;
                break;
            }
          }
        }
        total += i;
        input = input.slice(i);
        return tokens;
      }
      function end(chunk) {
        if (content.length) {
          token(content.join(""));
        }
        mode = EOF;
        token("(eof)");
        return tokens;
      }
      function normal() {
        content = content.length ? [] : content;
        if (last === "/" && c === "*") {
          start = total + i - 1;
          mode = BLOCK_COMMENT;
          last = c;
          return i + 1;
        }
        if (last === "/" && c === "/") {
          start = total + i - 1;
          mode = LINE_COMMENT;
          last = c;
          return i + 1;
        }
        if (c === "#") {
          mode = PREPROCESSOR;
          start = total + i;
          return i;
        }
        if (/\s/.test(c)) {
          mode = WHITESPACE;
          start = total + i;
          return i;
        }
        isnum = /\d/.test(c);
        isoperator = /[^\w_]/.test(c);
        start = total + i;
        mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
        return i;
      }
      function whitespace() {
        if (/[^\s]/g.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function preprocessor() {
        if ((c === "\r" || c === "\n") && last !== "\\") {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function line_comment() {
        return preprocessor();
      }
      function block_comment() {
        if (c === "/" && last === "*") {
          content.push(c);
          token(content.join(""));
          mode = NORMAL;
          return i + 1;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function operator() {
        if (last === "." && /\d/.test(c)) {
          mode = FLOAT;
          return i;
        }
        if (last === "/" && c === "*") {
          mode = BLOCK_COMMENT;
          return i;
        }
        if (last === "/" && c === "/") {
          mode = LINE_COMMENT;
          return i;
        }
        if (c === "." && content.length) {
          while (determine_operator(content)) ;
          mode = FLOAT;
          return i;
        }
        if (c === ";" || c === ")" || c === "(") {
          if (content.length) while (determine_operator(content)) ;
          token(c);
          mode = NORMAL;
          return i + 1;
        }
        var is_composite_operator = content.length === 2 && c !== "=";
        if (/[\w_\d\s]/.test(c) || is_composite_operator) {
          while (determine_operator(content)) ;
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function determine_operator(buf) {
        var j = 0, idx, res;
        do {
          idx = operators.indexOf(buf.slice(0, buf.length + j).join(""));
          res = operators[idx];
          if (idx === -1) {
            if (j-- + buf.length > 0) continue;
            res = buf.slice(0, 1).join("");
          }
          token(res);
          start += res.length;
          content = content.slice(res.length);
          return content.length;
        } while (1);
      }
      function hex() {
        if (/[^a-fA-F0-9]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function integer() {
        if (c === ".") {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (c === "x" && content.length === 1 && content[0] === "0") {
          mode = HEX;
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function decimal() {
        if (c === "f") {
          content.push(c);
          last = c;
          i += 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if ((c === "-" || c === "+") && /[eE]/.test(last)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function readtoken() {
        if (/[^\d\w_]/.test(c)) {
          var contentstr = content.join("");
          if (literalsDict[contentstr]) {
            mode = KEYWORD;
          } else if (builtinsDict[contentstr]) {
            mode = BUILTIN;
          } else {
            mode = IDENT;
          }
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
    }
  }
});

// node_modules/glsl-tokenizer/string.js
var require_string = __commonJS({
  "node_modules/glsl-tokenizer/string.js"(exports2, module2) {
    var tokenize = require_glsl_tokenizer();
    module2.exports = tokenizeString;
    function tokenizeString(str, opt) {
      var generator = tokenize(opt);
      var tokens = [];
      tokens = tokens.concat(generator(str));
      tokens = tokens.concat(generator(null));
      return tokens;
    }
  }
});

// node_modules/atob-lite/atob-browser.js
var require_atob_browser = __commonJS({
  "node_modules/atob-lite/atob-browser.js"(exports2, module2) {
    module2.exports = function _atob(str) {
      return atob(str);
    };
  }
});

// node_modules/glsl-shader-name/index.js
var require_glsl_shader_name = __commonJS({
  "node_modules/glsl-shader-name/index.js"(exports2, module2) {
    var tokenize = require_string();
    var atob2 = require_atob_browser();
    module2.exports = getName;
    function getName(src) {
      var tokens = Array.isArray(src) ? src : tokenize(src);
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.type !== "preprocessor") continue;
        var match = token.data.match(/\#define\s+SHADER_NAME(_B64)?\s+(.+)$/);
        if (!match) continue;
        if (!match[2]) continue;
        var b64 = match[1];
        var name2 = match[2];
        return (b64 ? atob2(name2) : name2).trim();
      }
    }
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports2, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1) return str;
      if (num === 2) return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/pad-left/index.js
var require_pad_left = __commonJS({
  "node_modules/pad-left/index.js"(exports2, module2) {
    "use strict";
    var repeat = require_repeat_string();
    module2.exports = function padLeft(str, num, ch) {
      ch = typeof ch !== "undefined" ? ch + "" : " ";
      return repeat(ch, num) + str;
    };
  }
});

// node_modules/add-line-numbers/index.js
var require_add_line_numbers = __commonJS({
  "node_modules/add-line-numbers/index.js"(exports2, module2) {
    var padLeft = require_pad_left();
    module2.exports = addLineNumbers;
    function addLineNumbers(string, start, delim) {
      start = typeof start === "number" ? start : 1;
      delim = delim || ": ";
      var lines = string.split(/\r?\n/);
      var totalDigits = String(lines.length + start - 1).length;
      return lines.map(function(line, i) {
        var c = i + start;
        var digits = String(c).length;
        var prefix = padLeft(c, totalDigits - digits);
        return prefix + delim + line;
      }).join("\n");
    }
  }
});

// node_modules/gl-format-compiler-error/index.js
var require_gl_format_compiler_error = __commonJS({
  "node_modules/gl-format-compiler-error/index.js"(exports2, module2) {
    var sprintf = require_sprintf().sprintf;
    var glConstants = require_lookup();
    var shaderName = require_glsl_shader_name();
    var addLineNumbers = require_add_line_numbers();
    module2.exports = formatCompilerError;
    function formatCompilerError(errLog, src, type) {
      "use strict";
      var name2 = shaderName(src) || "of unknown name (see npm glsl-shader-name)";
      var typeName = "unknown type";
      if (type !== void 0) {
        typeName = type === glConstants.FRAGMENT_SHADER ? "fragment" : "vertex";
      }
      var longForm = sprintf("Error compiling %s shader %s:\n", typeName, name2);
      var shortForm = sprintf("%s%s", longForm, errLog);
      var errorStrings = errLog.split("\n");
      var errors = {};
      for (var i = 0; i < errorStrings.length; i++) {
        var errorString = errorStrings[i];
        if (errorString === "" || errorString === "\0") continue;
        var lineNo = parseInt(errorString.split(":")[2]);
        if (isNaN(lineNo)) {
          throw new Error(sprintf("Could not parse error: %s", errorString));
        }
        errors[lineNo] = errorString;
      }
      var lines = addLineNumbers(src).split("\n");
      for (var i = 0; i < lines.length; i++) {
        if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) continue;
        var line = lines[i];
        longForm += line + "\n";
        if (errors[i + 1]) {
          var e = errors[i + 1];
          e = e.substr(e.split(":", 3).join(":").length + 1).trim();
          longForm += sprintf("^^^ %s\n\n", e);
        }
      }
      return {
        long: longForm.trim(),
        short: shortForm.trim()
      };
    }
  }
});

// node_modules/weakmap-shim/hidden-store.js
var require_hidden_store = __commonJS({
  "node_modules/weakmap-shim/hidden-store.js"(exports2, module2) {
    module2.exports = hiddenStore;
    function hiddenStore(obj, key) {
      var store = { identity: key };
      var valueOf = obj.valueOf;
      Object.defineProperty(obj, "valueOf", {
        value: function(value) {
          return value !== key ? valueOf.apply(this, arguments) : store;
        },
        writable: true
      });
      return store;
    }
  }
});

// node_modules/weakmap-shim/create-store.js
var require_create_store = __commonJS({
  "node_modules/weakmap-shim/create-store.js"(exports2, module2) {
    var hiddenStore = require_hidden_store();
    module2.exports = createStore;
    function createStore() {
      var key = {};
      return function(obj) {
        if ((typeof obj !== "object" || obj === null) && typeof obj !== "function") {
          throw new Error("Weakmap-shim: Key must be object");
        }
        var store = obj.valueOf(key);
        return store && store.identity === key ? store : hiddenStore(obj, key);
      };
    }
  }
});

// node_modules/weakmap-shim/index.js
var require_weakmap_shim = __commonJS({
  "node_modules/weakmap-shim/index.js"(exports2, module2) {
    var createStore = require_create_store();
    module2.exports = weakMap;
    function weakMap() {
      var privates = createStore();
      return {
        "get": function(key, fallback) {
          var store = privates(key);
          return store.hasOwnProperty("value") ? store.value : fallback;
        },
        "set": function(key, value) {
          privates(key).value = value;
          return this;
        },
        "has": function(key) {
          return "value" in privates(key);
        },
        "delete": function(key) {
          return delete privates(key).value;
        }
      };
    }
  }
});

// node_modules/gl-shader/lib/shader-cache.js
var require_shader_cache = __commonJS({
  "node_modules/gl-shader/lib/shader-cache.js"(exports2) {
    "use strict";
    exports2.shader = getShaderReference;
    exports2.program = createProgram;
    var GLError = require_GLError();
    var formatCompilerError = require_gl_format_compiler_error();
    var weakMap = typeof WeakMap === "undefined" ? require_weakmap_shim() : WeakMap;
    var CACHE = new weakMap();
    var SHADER_COUNTER = 0;
    function ShaderReference(id, src, type, shader, programs, count, cache) {
      this.id = id;
      this.src = src;
      this.type = type;
      this.shader = shader;
      this.count = count;
      this.programs = [];
      this.cache = cache;
    }
    ShaderReference.prototype.dispose = function() {
      if (--this.count === 0) {
        var cache = this.cache;
        var gl2 = cache.gl;
        var programs = this.programs;
        for (var i = 0, n = programs.length; i < n; ++i) {
          var p = cache.programs[programs[i]];
          if (p) {
            delete cache.programs[i];
            gl2.deleteProgram(p);
          }
        }
        gl2.deleteShader(this.shader);
        delete cache.shaders[this.type === gl2.FRAGMENT_SHADER | 0][this.src];
      }
    };
    function ContextCache(gl2) {
      this.gl = gl2;
      this.shaders = [{}, {}];
      this.programs = {};
    }
    var proto = ContextCache.prototype;
    function compileShader(gl2, type, src) {
      var shader = gl2.createShader(type);
      gl2.shaderSource(shader, src);
      gl2.compileShader(shader);
      if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
        var errLog = gl2.getShaderInfoLog(shader);
        try {
          var fmt = formatCompilerError(errLog, src, type);
        } catch (e) {
          console.warn("Failed to format compiler error: " + e);
          throw new GLError(errLog, "Error compiling shader:\n" + errLog);
        }
        throw new GLError(errLog, fmt.short, fmt.long);
      }
      return shader;
    }
    proto.getShaderReference = function(type, src) {
      var gl2 = this.gl;
      var shaders = this.shaders[type === gl2.FRAGMENT_SHADER | 0];
      var shader = shaders[src];
      if (!shader || !gl2.isShader(shader.shader)) {
        var shaderObj = compileShader(gl2, type, src);
        shader = shaders[src] = new ShaderReference(
          SHADER_COUNTER++,
          src,
          type,
          shaderObj,
          [],
          1,
          this
        );
      } else {
        shader.count += 1;
      }
      return shader;
    };
    function linkProgram(gl2, vshader, fshader, attribs, locations) {
      var program = gl2.createProgram();
      gl2.attachShader(program, vshader);
      gl2.attachShader(program, fshader);
      for (var i = 0; i < attribs.length; ++i) {
        gl2.bindAttribLocation(program, locations[i], attribs[i]);
      }
      gl2.linkProgram(program);
      if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
        var errLog = gl2.getProgramInfoLog(program);
        throw new GLError(errLog, "Error linking program: " + errLog);
      }
      return program;
    }
    proto.getProgram = function(vref, fref, attribs, locations) {
      var token = [vref.id, fref.id, attribs.join(":"), locations.join(":")].join("@");
      var prog = this.programs[token];
      if (!prog || !this.gl.isProgram(prog)) {
        this.programs[token] = prog = linkProgram(
          this.gl,
          vref.shader,
          fref.shader,
          attribs,
          locations
        );
        vref.programs.push(token);
        fref.programs.push(token);
      }
      return prog;
    };
    function getCache(gl2) {
      var ctxCache = CACHE.get(gl2);
      if (!ctxCache) {
        ctxCache = new ContextCache(gl2);
        CACHE.set(gl2, ctxCache);
      }
      return ctxCache;
    }
    function getShaderReference(gl2, type, src) {
      return getCache(gl2).getShaderReference(type, src);
    }
    function createProgram(gl2, vref, fref, attribs, locations) {
      return getCache(gl2).getProgram(vref, fref, attribs, locations);
    }
  }
});

// node_modules/gl-shader/lib/runtime-reflect.js
var require_runtime_reflect = __commonJS({
  "node_modules/gl-shader/lib/runtime-reflect.js"(exports2) {
    "use strict";
    exports2.uniforms = runtimeUniforms;
    exports2.attributes = runtimeAttributes;
    var GL_TO_GLSL_TYPES = {
      "FLOAT": "float",
      "FLOAT_VEC2": "vec2",
      "FLOAT_VEC3": "vec3",
      "FLOAT_VEC4": "vec4",
      "INT": "int",
      "INT_VEC2": "ivec2",
      "INT_VEC3": "ivec3",
      "INT_VEC4": "ivec4",
      "BOOL": "bool",
      "BOOL_VEC2": "bvec2",
      "BOOL_VEC3": "bvec3",
      "BOOL_VEC4": "bvec4",
      "FLOAT_MAT2": "mat2",
      "FLOAT_MAT3": "mat3",
      "FLOAT_MAT4": "mat4",
      "SAMPLER_2D": "sampler2D",
      "SAMPLER_CUBE": "samplerCube"
    };
    var GL_TABLE = null;
    function getType(gl2, type) {
      if (!GL_TABLE) {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);
        GL_TABLE = {};
        for (var i = 0; i < typeNames.length; ++i) {
          var tn = typeNames[i];
          GL_TABLE[gl2[tn]] = GL_TO_GLSL_TYPES[tn];
        }
      }
      return GL_TABLE[type];
    }
    function runtimeUniforms(gl2, program) {
      var numUniforms = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
      var result = [];
      for (var i = 0; i < numUniforms; ++i) {
        var info = gl2.getActiveUniform(program, i);
        if (info) {
          var type = getType(gl2, info.type);
          if (info.size > 1) {
            for (var j = 0; j < info.size; ++j) {
              result.push({
                name: info.name.replace("[0]", "[" + j + "]"),
                type
              });
            }
          } else {
            result.push({
              name: info.name,
              type
            });
          }
        }
      }
      return result;
    }
    function runtimeAttributes(gl2, program) {
      var numAttributes = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
      var result = [];
      for (var i = 0; i < numAttributes; ++i) {
        var info = gl2.getActiveAttrib(program, i);
        if (info) {
          result.push({
            name: info.name,
            type: getType(gl2, info.type)
          });
        }
      }
      return result;
    }
  }
});

// node_modules/gl-shader/index.js
var require_gl_shader = __commonJS({
  "node_modules/gl-shader/index.js"(exports2, module2) {
    "use strict";
    var createUniformWrapper = require_create_uniforms();
    var createAttributeWrapper = require_create_attributes();
    var makeReflect = require_reflect();
    var shaderCache = require_shader_cache();
    var runtime = require_runtime_reflect();
    var GLError = require_GLError();
    function Shader(gl2) {
      this.gl = gl2;
      this.gl.lastAttribCount = 0;
      this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;
    }
    var proto = Shader.prototype;
    proto.bind = function() {
      if (!this.program) {
        this._relink();
      }
      var i;
      var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
      var oldAttribCount = this.gl.lastAttribCount;
      if (newAttribCount > oldAttribCount) {
        for (i = oldAttribCount; i < newAttribCount; i++) {
          this.gl.enableVertexAttribArray(i);
        }
      } else if (oldAttribCount > newAttribCount) {
        for (i = newAttribCount; i < oldAttribCount; i++) {
          this.gl.disableVertexAttribArray(i);
        }
      }
      this.gl.lastAttribCount = newAttribCount;
      this.gl.useProgram(this.program);
    };
    proto.dispose = function() {
      var oldAttribCount = this.gl.lastAttribCount;
      for (var i = 0; i < oldAttribCount; i++) {
        this.gl.disableVertexAttribArray(i);
      }
      this.gl.lastAttribCount = 0;
      if (this._fref) {
        this._fref.dispose();
      }
      if (this._vref) {
        this._vref.dispose();
      }
      this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;
    };
    function compareAttributes(a, b) {
      if (a.name < b.name) {
        return -1;
      }
      return 1;
    }
    proto.update = function(vertSource, fragSource, uniforms, attributes) {
      if (!fragSource || arguments.length === 1) {
        var obj = vertSource;
        vertSource = obj.vertex;
        fragSource = obj.fragment;
        uniforms = obj.uniforms;
        attributes = obj.attributes;
      }
      var wrapper = this;
      var gl2 = wrapper.gl;
      var pvref = wrapper._vref;
      wrapper._vref = shaderCache.shader(gl2, gl2.VERTEX_SHADER, vertSource);
      if (pvref) {
        pvref.dispose();
      }
      wrapper.vertShader = wrapper._vref.shader;
      var pfref = this._fref;
      wrapper._fref = shaderCache.shader(gl2, gl2.FRAGMENT_SHADER, fragSource);
      if (pfref) {
        pfref.dispose();
      }
      wrapper.fragShader = wrapper._fref.shader;
      if (!uniforms || !attributes) {
        var testProgram = gl2.createProgram();
        gl2.attachShader(testProgram, wrapper.fragShader);
        gl2.attachShader(testProgram, wrapper.vertShader);
        gl2.linkProgram(testProgram);
        if (!gl2.getProgramParameter(testProgram, gl2.LINK_STATUS)) {
          var errLog = gl2.getProgramInfoLog(testProgram);
          throw new GLError(errLog, "Error linking program:" + errLog);
        }
        uniforms = uniforms || runtime.uniforms(gl2, testProgram);
        attributes = attributes || runtime.attributes(gl2, testProgram);
        gl2.deleteProgram(testProgram);
      }
      attributes = attributes.slice();
      attributes.sort(compareAttributes);
      var attributeUnpacked = [];
      var attributeNames = [];
      var attributeLocations = [];
      var i;
      for (i = 0; i < attributes.length; ++i) {
        var attr = attributes[i];
        if (attr.type.indexOf("mat") >= 0) {
          var size = attr.type.charAt(attr.type.length - 1) | 0;
          var locVector = new Array(size);
          for (var j = 0; j < size; ++j) {
            locVector[j] = attributeLocations.length;
            attributeNames.push(attr.name + "[" + j + "]");
            if (typeof attr.location === "number") {
              attributeLocations.push(attr.location + j);
            } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === "number") {
              attributeLocations.push(attr.location[j] | 0);
            } else {
              attributeLocations.push(-1);
            }
          }
          attributeUnpacked.push({
            name: attr.name,
            type: attr.type,
            locations: locVector
          });
        } else {
          attributeUnpacked.push({
            name: attr.name,
            type: attr.type,
            locations: [attributeLocations.length]
          });
          attributeNames.push(attr.name);
          if (typeof attr.location === "number") {
            attributeLocations.push(attr.location | 0);
          } else {
            attributeLocations.push(-1);
          }
        }
      }
      var curLocation = 0;
      for (i = 0; i < attributeLocations.length; ++i) {
        if (attributeLocations[i] < 0) {
          while (attributeLocations.indexOf(curLocation) >= 0) {
            curLocation += 1;
          }
          attributeLocations[i] = curLocation;
        }
      }
      var uniformLocations = new Array(uniforms.length);
      function relink() {
        wrapper.program = shaderCache.program(
          gl2,
          wrapper._vref,
          wrapper._fref,
          attributeNames,
          attributeLocations
        );
        for (var i2 = 0; i2 < uniforms.length; ++i2) {
          uniformLocations[i2] = gl2.getUniformLocation(
            wrapper.program,
            uniforms[i2].name
          );
        }
      }
      relink();
      wrapper._relink = relink;
      wrapper.types = {
        uniforms: makeReflect(uniforms),
        attributes: makeReflect(attributes)
      };
      wrapper.attributes = createAttributeWrapper(
        gl2,
        wrapper,
        attributeUnpacked,
        attributeLocations
      );
      Object.defineProperty(wrapper, "uniforms", createUniformWrapper(
        gl2,
        wrapper,
        uniforms,
        uniformLocations
      ));
    };
    function createShader(gl2, vertSource, fragSource, uniforms, attributes) {
      var shader = new Shader(gl2);
      shader.update(
        vertSource,
        fragSource,
        uniforms,
        attributes
      );
      return shader;
    }
    module2.exports = createShader;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/typedarray-pool/pool.js
var require_pool = __commonJS({
  "node_modules/typedarray-pool/pool.js"(exports2) {
    "use strict";
    var bits = require_twiddle();
    var dup = require_dup();
    var Buffer2 = require_buffer().Buffer;
    if (!window.__TYPEDARRAY_POOL) {
      window.__TYPEDARRAY_POOL = {
        UINT8: dup([32, 0]),
        UINT16: dup([32, 0]),
        UINT32: dup([32, 0]),
        BIGUINT64: dup([32, 0]),
        INT8: dup([32, 0]),
        INT16: dup([32, 0]),
        INT32: dup([32, 0]),
        BIGINT64: dup([32, 0]),
        FLOAT: dup([32, 0]),
        DOUBLE: dup([32, 0]),
        DATA: dup([32, 0]),
        UINT8C: dup([32, 0]),
        BUFFER: dup([32, 0])
      };
    }
    var hasUint8C = typeof Uint8ClampedArray !== "undefined";
    var hasBigUint64 = typeof BigUint64Array !== "undefined";
    var hasBigInt64 = typeof BigInt64Array !== "undefined";
    var POOL = window.__TYPEDARRAY_POOL;
    if (!POOL.UINT8C) {
      POOL.UINT8C = dup([32, 0]);
    }
    if (!POOL.BIGUINT64) {
      POOL.BIGUINT64 = dup([32, 0]);
    }
    if (!POOL.BIGINT64) {
      POOL.BIGINT64 = dup([32, 0]);
    }
    if (!POOL.BUFFER) {
      POOL.BUFFER = dup([32, 0]);
    }
    var DATA = POOL.DATA;
    var BUFFER = POOL.BUFFER;
    exports2.free = function free(array) {
      if (Buffer2.isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
      } else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
          array = array.buffer;
        }
        if (!array) {
          return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
      }
    };
    function freeArrayBuffer(buffer) {
      if (!buffer) {
        return;
      }
      var n = buffer.length || buffer.byteLength;
      var log_n = bits.log2(n);
      DATA[log_n].push(buffer);
    }
    function freeTypedArray(array) {
      freeArrayBuffer(array.buffer);
    }
    exports2.freeUint8 = exports2.freeUint16 = exports2.freeUint32 = exports2.freeBigUint64 = exports2.freeInt8 = exports2.freeInt16 = exports2.freeInt32 = exports2.freeBigInt64 = exports2.freeFloat32 = exports2.freeFloat = exports2.freeFloat64 = exports2.freeDouble = exports2.freeUint8Clamped = exports2.freeDataView = freeTypedArray;
    exports2.freeArrayBuffer = freeArrayBuffer;
    exports2.freeBuffer = function freeBuffer(array) {
      BUFFER[bits.log2(array.length)].push(array);
    };
    exports2.malloc = function malloc(n, dtype) {
      if (dtype === void 0 || dtype === "arraybuffer") {
        return mallocArrayBuffer(n);
      } else {
        switch (dtype) {
          case "uint8":
            return mallocUint8(n);
          case "uint16":
            return mallocUint16(n);
          case "uint32":
            return mallocUint32(n);
          case "int8":
            return mallocInt8(n);
          case "int16":
            return mallocInt16(n);
          case "int32":
            return mallocInt32(n);
          case "float":
          case "float32":
            return mallocFloat(n);
          case "double":
          case "float64":
            return mallocDouble(n);
          case "uint8_clamped":
            return mallocUint8Clamped(n);
          case "bigint64":
            return mallocBigInt64(n);
          case "biguint64":
            return mallocBigUint64(n);
          case "buffer":
            return mallocBuffer(n);
          case "data":
          case "dataview":
            return mallocDataView(n);
          default:
            return null;
        }
      }
      return null;
    };
    function mallocArrayBuffer(n) {
      var n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var d = DATA[log_n];
      if (d.length > 0) {
        return d.pop();
      }
      return new ArrayBuffer(n);
    }
    exports2.mallocArrayBuffer = mallocArrayBuffer;
    function mallocUint8(n) {
      return new Uint8Array(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocUint8 = mallocUint8;
    function mallocUint16(n) {
      return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports2.mallocUint16 = mallocUint16;
    function mallocUint32(n) {
      return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocUint32 = mallocUint32;
    function mallocInt8(n) {
      return new Int8Array(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocInt8 = mallocInt8;
    function mallocInt16(n) {
      return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports2.mallocInt16 = mallocInt16;
    function mallocInt32(n) {
      return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocInt32 = mallocInt32;
    function mallocFloat(n) {
      return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports2.mallocFloat32 = exports2.mallocFloat = mallocFloat;
    function mallocDouble(n) {
      return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
    }
    exports2.mallocFloat64 = exports2.mallocDouble = mallocDouble;
    function mallocUint8Clamped(n) {
      if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
      } else {
        return mallocUint8(n);
      }
    }
    exports2.mallocUint8Clamped = mallocUint8Clamped;
    function mallocBigUint64(n) {
      if (hasBigUint64) {
        return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports2.mallocBigUint64 = mallocBigUint64;
    function mallocBigInt64(n) {
      if (hasBigInt64) {
        return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
      } else {
        return null;
      }
    }
    exports2.mallocBigInt64 = mallocBigInt64;
    function mallocDataView(n) {
      return new DataView(mallocArrayBuffer(n), 0, n);
    }
    exports2.mallocDataView = mallocDataView;
    function mallocBuffer(n) {
      n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var cache = BUFFER[log_n];
      if (cache.length > 0) {
        return cache.pop();
      }
      return new Buffer2(n);
    }
    exports2.mallocBuffer = mallocBuffer;
    exports2.clearCache = function clearCache() {
      for (var i = 0; i < 32; ++i) {
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
      }
    };
  }
});

// node_modules/ndarray-ops/ndarray-ops.js
var require_ndarray_ops = __commonJS({
  "node_modules/ndarray-ops/ndarray-ops.js"(exports2) {
    "use strict";
    var CACHED_CWiseOp = {
      "float64,2,1,0": function() {
        return function divseq_cwise_loop_2s1s0m3f64(SS, a0, t0, p0, Y0) {
          var s0 = SS[0], s1 = SS[1], s2 = SS[2], t0p0 = t0[0], t0p1 = t0[1], t0p2 = t0[2];
          p0 |= 0;
          var i0 = 0, i1 = 0, i2 = 0, d0s0 = t0p2, d0s1 = t0p1 - s2 * t0p2, d0s2 = t0p0 - s1 * t0p1;
          for (i2 = 0; i2 < s0; ++i2) {
            for (i1 = 0; i1 < s1; ++i1) {
              for (i0 = 0; i0 < s2; ++i0) {
                a0[p0] /= Y0;
                p0 += d0s0;
              }
              p0 += d0s1;
            }
            p0 += d0s2;
          }
        };
      },
      "uint8,2,0,1,float64,2,1,0": function() {
        return function muls_cwise_loop_2s0s1m1u8f64(SS, a0, t0, p0, a1, t1, p1, Y0) {
          var s0 = SS[0], s1 = SS[1], s2 = SS[2], t0p0 = t0[0], t0p1 = t0[1], t0p2 = t0[2], t1p0 = t1[0], t1p1 = t1[1], t1p2 = t1[2];
          p0 |= 0;
          p1 |= 0;
          var offset0 = p0;
          var offset1 = p1;
          for (var j1 = SS[0] | 0; j1 > 0; ) {
            if (j1 < 64) {
              s0 = j1;
              j1 = 0;
            } else {
              s0 = 64;
              j1 -= 64;
            }
            for (var j2 = SS[1] | 0; j2 > 0; ) {
              if (j2 < 64) {
                s1 = j2;
                j2 = 0;
              } else {
                s1 = 64;
                j2 -= 64;
              }
              p0 = offset0 + j1 * t0p0 + j2 * t0p1;
              p1 = offset1 + j1 * t1p0 + j2 * t1p1;
              var i0 = 0, i1 = 0, i2 = 0, d0s0 = t0p2, d0s1 = t0p0 - s2 * t0p2, d0s2 = t0p1 - s0 * t0p0, d1s0 = t1p2, d1s1 = t1p0 - s2 * t1p2, d1s2 = t1p1 - s0 * t1p0;
              for (i2 = 0; i2 < s1; ++i2) {
                for (i1 = 0; i1 < s0; ++i1) {
                  for (i0 = 0; i0 < s2; ++i0) {
                    a0[p0] = a1[p1] * Y0;
                    p0 += d0s0;
                    p1 += d1s0;
                  }
                  p0 += d0s1;
                  p1 += d1s1;
                }
                p0 += d0s2;
                p1 += d1s2;
              }
            }
          }
        };
      },
      "float32,1,0,float32,1,0": function() {
        return function assign_cwise_loop_1s0m2f32(SS, a0, t0, p0, a1, t1, p1) {
          var s0 = SS[0], s1 = SS[1], t0p0 = t0[0], t0p1 = t0[1], t1p0 = t1[0], t1p1 = t1[1];
          p0 |= 0;
          p1 |= 0;
          var i0 = 0, i1 = 0, d0s0 = t0p1, d0s1 = t0p0 - s1 * t0p1, d1s0 = t1p1, d1s1 = t1p0 - s1 * t1p1;
          for (i1 = 0; i1 < s0; ++i1) {
            for (i0 = 0; i0 < s1; ++i0) {
              a0[p0] = a1[p1];
              p0 += d0s0;
              p1 += d1s0;
            }
            p0 += d0s1;
            p1 += d1s1;
          }
        };
      },
      "float32,1,0,float32,0,1": function() {
        return function assign_cwise_loop_1s0m0f32(SS, a0, t0, p0, a1, t1, p1) {
          var s0 = SS[0], s1 = SS[1], t0p0 = t0[0], t0p1 = t0[1], t1p0 = t1[0], t1p1 = t1[1];
          p0 |= 0;
          p1 |= 0;
          var offset0 = p0;
          var offset1 = p1;
          for (var j0 = SS[1] | 0; j0 > 0; ) {
            if (j0 < 64) {
              s1 = j0;
              j0 = 0;
            } else {
              s1 = 64;
              j0 -= 64;
            }
            for (var j1 = SS[0] | 0; j1 > 0; ) {
              if (j1 < 64) {
                s0 = j1;
                j1 = 0;
              } else {
                s0 = 64;
                j1 -= 64;
              }
              p0 = offset0 + j0 * t0p1 + j1 * t0p0;
              p1 = offset1 + j0 * t1p1 + j1 * t1p0;
              var i0 = 0, i1 = 0, d0s0 = t0p1, d0s1 = t0p0 - s1 * t0p1, d1s0 = t1p1, d1s1 = t1p0 - s1 * t1p1;
              for (i1 = 0; i1 < s0; ++i1) {
                for (i0 = 0; i0 < s1; ++i0) {
                  a0[p0] = a1[p1];
                  p0 += d0s0;
                  p1 += d1s0;
                }
                p0 += d0s1;
                p1 += d1s1;
              }
            }
          }
        };
      },
      "uint8,2,0,1,uint8,1,2,0": function() {
        return function assign_cwise_loop_2s0s1m0u8(SS, a0, t0, p0, a1, t1, p1) {
          var s0 = SS[0], s1 = SS[1], s2 = SS[2], t0p0 = t0[0], t0p1 = t0[1], t0p2 = t0[2], t1p0 = t1[0], t1p1 = t1[1], t1p2 = t1[2];
          p0 |= 0;
          p1 |= 0;
          var offset0 = p0;
          var offset1 = p1;
          for (var j0 = SS[2] | 0; j0 > 0; ) {
            if (j0 < 64) {
              s2 = j0;
              j0 = 0;
            } else {
              s2 = 64;
              j0 -= 64;
            }
            for (var j1 = SS[0] | 0; j1 > 0; ) {
              if (j1 < 64) {
                s0 = j1;
                j1 = 0;
              } else {
                s0 = 64;
                j1 -= 64;
              }
              for (var j2 = SS[1] | 0; j2 > 0; ) {
                if (j2 < 64) {
                  s1 = j2;
                  j2 = 0;
                } else {
                  s1 = 64;
                  j2 -= 64;
                }
                p0 = offset0 + j0 * t0p2 + j1 * t0p0 + j2 * t0p1;
                p1 = offset1 + j0 * t1p2 + j1 * t1p0 + j2 * t1p1;
                var i0 = 0, i1 = 0, i2 = 0, d0s0 = t0p2, d0s1 = t0p0 - s2 * t0p2, d0s2 = t0p1 - s0 * t0p0, d1s0 = t1p2, d1s1 = t1p0 - s2 * t1p2, d1s2 = t1p1 - s0 * t1p0;
                for (i2 = 0; i2 < s1; ++i2) {
                  for (i1 = 0; i1 < s0; ++i1) {
                    for (i0 = 0; i0 < s2; ++i0) {
                      a0[p0] = a1[p1];
                      p0 += d0s0;
                      p1 += d1s0;
                    }
                    p0 += d0s1;
                    p1 += d1s1;
                  }
                  p0 += d0s2;
                  p1 += d1s2;
                }
              }
            }
          }
        };
      },
      "uint8,2,0,1,array,2,0,1": function() {
        return function assign_cwise_loop_2s0s1m3u8a(SS, a0, t0, p0, a1, t1, p1) {
          var s0 = SS[0], s1 = SS[1], s2 = SS[2], t0p0 = t0[0], t0p1 = t0[1], t0p2 = t0[2], t1p0 = t1[0], t1p1 = t1[1], t1p2 = t1[2];
          p0 |= 0;
          p1 |= 0;
          var i0 = 0, i1 = 0, i2 = 0, d0s0 = t0p2, d0s1 = t0p0 - s2 * t0p2, d0s2 = t0p1 - s0 * t0p0, d1s0 = t1p2, d1s1 = t1p0 - s2 * t1p2, d1s2 = t1p1 - s0 * t1p0;
          for (i2 = 0; i2 < s1; ++i2) {
            for (i1 = 0; i1 < s0; ++i1) {
              for (i0 = 0; i0 < s2; ++i0) {
                a0[p0] = a1[p1];
                p0 += d0s0;
                p1 += d1s0;
              }
              p0 += d0s1;
              p1 += d1s1;
            }
            p0 += d0s2;
            p1 += d1s2;
          }
        };
      }
    };
    function generateCWiseOp(proc, typesig) {
      var key = typesig.join(",");
      var f = CACHED_CWiseOp[key];
      return f();
    }
    var compile = generateCWiseOp;
    var CACHED_thunk = {
      mul: function(compile2) {
        var CACHED = {};
        return function mul_cwise_thunk(array0, array1, array2) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, t2 = array2.dtype, r2 = array2.order, type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1, t2, r2]);
          }
          return proc(
            array0.shape.slice(0),
            array0.data,
            array0.stride,
            array0.offset | 0,
            array1.data,
            array1.stride,
            array1.offset | 0,
            array2.data,
            array2.stride,
            array2.offset | 0
          );
        };
      },
      muls: function(compile2) {
        var CACHED = {};
        return function muls_cwise_thunk(array0, array1, scalar2) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, type = [t0, r0.join(), t1, r1.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1]);
          }
          return proc(
            array0.shape.slice(0),
            array0.data,
            array0.stride,
            array0.offset | 0,
            array1.data,
            array1.stride,
            array1.offset | 0,
            scalar2
          );
        };
      },
      mulseq: function(compile2) {
        var CACHED = {};
        return function mulseq_cwise_thunk(array0, scalar1) {
          var t0 = array0.dtype, r0 = array0.order, type = [t0, r0.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar1);
        };
      },
      div: function(compile2) {
        var CACHED = {};
        return function div_cwise_thunk(array0, array1, array2) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, t2 = array2.dtype, r2 = array2.order, type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1, t2, r2]);
          }
          return proc(
            array0.shape.slice(0),
            array0.data,
            array0.stride,
            array0.offset | 0,
            array1.data,
            array1.stride,
            array1.offset | 0,
            array2.data,
            array2.stride,
            array2.offset | 0
          );
        };
      },
      divs: function(compile2) {
        var CACHED = {};
        return function divs_cwise_thunk(array0, array1, scalar2) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, type = [t0, r0.join(), t1, r1.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1]);
          }
          return proc(
            array0.shape.slice(0),
            array0.data,
            array0.stride,
            array0.offset | 0,
            array1.data,
            array1.stride,
            array1.offset | 0,
            scalar2
          );
        };
      },
      divseq: function(compile2) {
        var CACHED = {};
        return function divseq_cwise_thunk(array0, scalar1) {
          var t0 = array0.dtype, r0 = array0.order, type = [t0, r0.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar1);
        };
      },
      assign: function(compile2) {
        var CACHED = {};
        return function assign_cwise_thunk(array0, array1) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, type = [t0, r0.join(), t1, r1.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1]);
          }
          return proc(
            array0.shape.slice(0),
            array0.data,
            array0.stride,
            array0.offset | 0,
            array1.data,
            array1.stride,
            array1.offset | 0
          );
        };
      }
    };
    function createThunk(proc) {
      var thunk = CACHED_thunk[proc.funcName];
      return thunk(compile.bind(void 0, proc));
    }
    function makeOp(user_args) {
      return createThunk({
        funcName: user_args.funcName
      });
    }
    var assign_ops = {
      mul: "*",
      div: "/"
    };
    (function() {
      for (var id in assign_ops) {
        exports2[id] = makeOp({
          funcName: id
        });
        exports2[id + "s"] = makeOp({
          funcName: id + "s"
        });
        exports2[id + "seq"] = makeOp({
          funcName: id + "seq"
        });
      }
    })();
    exports2.assign = makeOp({
      funcName: "assign"
    });
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/ndarray/ndarray.js"(exports2, module2) {
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a, b) {
      return a[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    var allFns = {
      // Special case for trivial arrays
      T: function(dtype) {
        function View(a) {
          this.data = a;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.index = function() {
          return -1;
        };
        proto.size = 0;
        proto.dimension = -1;
        proto.shape = proto.stride = proto.order = [];
        proto.lo = proto.hi = proto.transpose = proto.step = function() {
          return new View(this.data);
        };
        proto.get = proto.set = function() {
        };
        proto.pick = function() {
          return null;
        };
        return function construct(a) {
          return new View(a);
        };
      },
      // Special case for 0d arrays
      0: function(dtype, TrivialArray) {
        function View(a, d) {
          this.data = a;
          this.offset = d;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.index = function() {
          return this.offset;
        };
        proto.dimension = 0;
        proto.size = 1;
        proto.shape = proto.stride = proto.order = [];
        proto.lo = proto.hi = proto.transpose = proto.step = function copy() {
          return new View(this.data, this.offset);
        };
        proto.pick = function pick() {
          return TrivialArray(this.data);
        };
        proto.valueOf = proto.get = function get() {
          return dtype === "generic" ? this.data.get(this.offset) : this.data[this.offset];
        };
        proto.set = function set(v) {
          return dtype === "generic" ? this.data.set(this.offset, v) : this.data[this.offset] = v;
        };
        return function construct(a, b, c, d) {
          return new View(a, d);
        };
      },
      1: function(dtype, CTOR_LIST, ORDER) {
        function View(a, b0, c0, d) {
          this.data = a;
          this.shape = [b0];
          this.stride = [c0];
          this.offset = d | 0;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.dimension = 1;
        Object.defineProperty(proto, "size", {
          get: function size() {
            return this.shape[0];
          }
        });
        proto.order = [0];
        proto.set = function set(i0, v) {
          return dtype === "generic" ? this.data.set(this.offset + this.stride[0] * i0, v) : this.data[this.offset + this.stride[0] * i0] = v;
        };
        proto.get = function get(i0) {
          return dtype === "generic" ? this.data.get(this.offset + this.stride[0] * i0) : this.data[this.offset + this.stride[0] * i0];
        };
        proto.index = function index(i0) {
          return this.offset + this.stride[0] * i0;
        };
        proto.hi = function hi(i0) {
          return new View(this.data, typeof i0 !== "number" || i0 < 0 ? this.shape[0] : i0 | 0, this.stride[0], this.offset);
        };
        proto.lo = function lo(i0) {
          var b = this.offset, d = 0, a0 = this.shape[0], c0 = this.stride[0];
          if (typeof i0 === "number" && i0 >= 0) {
            d = i0 | 0;
            b += c0 * d;
            a0 -= d;
          }
          return new View(this.data, a0, c0, b);
        };
        proto.step = function step(i0) {
          var a0 = this.shape[0], b0 = this.stride[0], c = this.offset, d = 0, ceil = Math.ceil;
          if (typeof i0 === "number") {
            d = i0 | 0;
            if (d < 0) {
              c += b0 * (a0 - 1);
              a0 = ceil(-a0 / d);
            } else {
              a0 = ceil(a0 / d);
            }
            b0 *= d;
          }
          return new View(this.data, a0, b0, c);
        };
        proto.transpose = function transpose(i0) {
          i0 = i0 === void 0 ? 0 : i0 | 0;
          var a = this.shape, b = this.stride;
          return new View(this.data, a[i0], b[i0], this.offset);
        };
        proto.pick = function pick(i0) {
          var a = [], b = [], c = this.offset;
          if (typeof i0 === "number" && i0 >= 0) {
            c = c + this.stride[0] * i0 | 0;
          } else {
            a.push(this.shape[0]);
            b.push(this.stride[0]);
          }
          var ctor = CTOR_LIST[a.length + 1];
          return ctor(this.data, a, b, c);
        };
        return function construct(data, shape, stride, offset) {
          return new View(data, shape[0], stride[0], offset);
        };
      },
      2: function(dtype, CTOR_LIST, ORDER) {
        function View(a, b0, b1, c0, c1, d) {
          this.data = a;
          this.shape = [b0, b1];
          this.stride = [c0, c1];
          this.offset = d | 0;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.dimension = 2;
        Object.defineProperty(proto, "size", {
          get: function size() {
            return this.shape[0] * this.shape[1];
          }
        });
        Object.defineProperty(proto, "order", {
          get: function order2() {
            return Math.abs(this.stride[0]) > Math.abs(this.stride[1]) ? [1, 0] : [0, 1];
          }
        });
        proto.set = function set(i0, i1, v) {
          return dtype === "generic" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1] = v;
        };
        proto.get = function get(i0, i1) {
          return dtype === "generic" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1];
        };
        proto.index = function index(i0, i1) {
          return this.offset + this.stride[0] * i0 + this.stride[1] * i1;
        };
        proto.hi = function hi(i0, i1) {
          return new View(
            this.data,
            typeof i0 !== "number" || i0 < 0 ? this.shape[0] : i0 | 0,
            typeof i1 !== "number" || i1 < 0 ? this.shape[1] : i1 | 0,
            this.stride[0],
            this.stride[1],
            this.offset
          );
        };
        proto.lo = function lo(i0, i1) {
          var b = this.offset, d = 0, a0 = this.shape[0], a1 = this.shape[1], c0 = this.stride[0], c1 = this.stride[1];
          if (typeof i0 === "number" && i0 >= 0) {
            d = i0 | 0;
            b += c0 * d;
            a0 -= d;
          }
          if (typeof i1 === "number" && i1 >= 0) {
            d = i1 | 0;
            b += c1 * d;
            a1 -= d;
          }
          return new View(this.data, a0, a1, c0, c1, b);
        };
        proto.step = function step(i0, i1) {
          var a0 = this.shape[0], a1 = this.shape[1], b0 = this.stride[0], b1 = this.stride[1], c = this.offset, d = 0, ceil = Math.ceil;
          if (typeof i0 === "number") {
            d = i0 | 0;
            if (d < 0) {
              c += b0 * (a0 - 1);
              a0 = ceil(-a0 / d);
            } else {
              a0 = ceil(a0 / d);
            }
            b0 *= d;
          }
          if (typeof i1 === "number") {
            d = i1 | 0;
            if (d < 0) {
              c += b1 * (a1 - 1);
              a1 = ceil(-a1 / d);
            } else {
              a1 = ceil(a1 / d);
            }
            b1 *= d;
          }
          return new View(this.data, a0, a1, b0, b1, c);
        };
        proto.transpose = function transpose(i0, i1) {
          i0 = i0 === void 0 ? 0 : i0 | 0;
          i1 = i1 === void 0 ? 1 : i1 | 0;
          var a = this.shape, b = this.stride;
          return new View(this.data, a[i0], a[i1], b[i0], b[i1], this.offset);
        };
        proto.pick = function pick(i0, i1) {
          var a = [], b = [], c = this.offset;
          if (typeof i0 === "number" && i0 >= 0) {
            c = c + this.stride[0] * i0 | 0;
          } else {
            a.push(this.shape[0]);
            b.push(this.stride[0]);
          }
          if (typeof i1 === "number" && i1 >= 0) {
            c = c + this.stride[1] * i1 | 0;
          } else {
            a.push(this.shape[1]);
            b.push(this.stride[1]);
          }
          var ctor = CTOR_LIST[a.length + 1];
          return ctor(this.data, a, b, c);
        };
        return function construct(data, shape, stride, offset) {
          return new View(data, shape[0], shape[1], stride[0], stride[1], offset);
        };
      },
      3: function(dtype, CTOR_LIST, ORDER) {
        function View(a, b0, b1, b2, c0, c1, c2, d) {
          this.data = a;
          this.shape = [b0, b1, b2];
          this.stride = [c0, c1, c2];
          this.offset = d | 0;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.dimension = 3;
        Object.defineProperty(proto, "size", {
          get: function size() {
            return this.shape[0] * this.shape[1] * this.shape[2];
          }
        });
        Object.defineProperty(proto, "order", {
          get: function order2() {
            var s0 = Math.abs(this.stride[0]), s1 = Math.abs(this.stride[1]), s2 = Math.abs(this.stride[2]);
            if (s0 > s1) {
              if (s1 > s2) {
                return [2, 1, 0];
              } else if (s0 > s2) {
                return [1, 2, 0];
              } else {
                return [1, 0, 2];
              }
            } else if (s0 > s2) {
              return [2, 0, 1];
            } else if (s2 > s1) {
              return [0, 1, 2];
            } else {
              return [0, 2, 1];
            }
          }
        });
        proto.set = function set(i0, i1, i2, v) {
          return dtype === "generic" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2] = v;
        };
        proto.get = function get(i0, i1, i2) {
          return dtype === "generic" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2];
        };
        proto.index = function index(i0, i1, i2) {
          return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2;
        };
        proto.hi = function hi(i0, i1, i2) {
          return new View(
            this.data,
            typeof i0 !== "number" || i0 < 0 ? this.shape[0] : i0 | 0,
            typeof i1 !== "number" || i1 < 0 ? this.shape[1] : i1 | 0,
            typeof i2 !== "number" || i2 < 0 ? this.shape[2] : i2 | 0,
            this.stride[0],
            this.stride[1],
            this.stride[2],
            this.offset
          );
        };
        proto.lo = function lo(i0, i1, i2) {
          var b = this.offset, d = 0, a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], c0 = this.stride[0], c1 = this.stride[1], c2 = this.stride[2];
          if (typeof i0 === "number" && i0 >= 0) {
            d = i0 | 0;
            b += c0 * d;
            a0 -= d;
          }
          if (typeof i1 === "number" && i1 >= 0) {
            d = i1 | 0;
            b += c1 * d;
            a1 -= d;
          }
          if (typeof i2 === "number" && i2 >= 0) {
            d = i2 | 0;
            b += c2 * d;
            a2 -= d;
          }
          return new View(this.data, a0, a1, a2, c0, c1, c2, b);
        };
        proto.step = function step(i0, i1, i2) {
          var a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], b0 = this.stride[0], b1 = this.stride[1], b2 = this.stride[2], c = this.offset, d = 0, ceil = Math.ceil;
          if (typeof i0 === "number") {
            d = i0 | 0;
            if (d < 0) {
              c += b0 * (a0 - 1);
              a0 = ceil(-a0 / d);
            } else {
              a0 = ceil(a0 / d);
            }
            b0 *= d;
          }
          if (typeof i1 === "number") {
            d = i1 | 0;
            if (d < 0) {
              c += b1 * (a1 - 1);
              a1 = ceil(-a1 / d);
            } else {
              a1 = ceil(a1 / d);
            }
            b1 *= d;
          }
          if (typeof i2 === "number") {
            d = i2 | 0;
            if (d < 0) {
              c += b2 * (a2 - 1);
              a2 = ceil(-a2 / d);
            } else {
              a2 = ceil(a2 / d);
            }
            b2 *= d;
          }
          return new View(this.data, a0, a1, a2, b0, b1, b2, c);
        };
        proto.transpose = function transpose(i0, i1, i2) {
          i0 = i0 === void 0 ? 0 : i0 | 0;
          i1 = i1 === void 0 ? 1 : i1 | 0;
          i2 = i2 === void 0 ? 2 : i2 | 0;
          var a = this.shape, b = this.stride;
          return new View(this.data, a[i0], a[i1], a[i2], b[i0], b[i1], b[i2], this.offset);
        };
        proto.pick = function pick(i0, i1, i2) {
          var a = [], b = [], c = this.offset;
          if (typeof i0 === "number" && i0 >= 0) {
            c = c + this.stride[0] * i0 | 0;
          } else {
            a.push(this.shape[0]);
            b.push(this.stride[0]);
          }
          if (typeof i1 === "number" && i1 >= 0) {
            c = c + this.stride[1] * i1 | 0;
          } else {
            a.push(this.shape[1]);
            b.push(this.stride[1]);
          }
          if (typeof i2 === "number" && i2 >= 0) {
            c = c + this.stride[2] * i2 | 0;
          } else {
            a.push(this.shape[2]);
            b.push(this.stride[2]);
          }
          var ctor = CTOR_LIST[a.length + 1];
          return ctor(this.data, a, b, c);
        };
        return function construct(data, shape, stride, offset) {
          return new View(data, shape[0], shape[1], shape[2], stride[0], stride[1], stride[2], offset);
        };
      },
      4: function(dtype, CTOR_LIST, ORDER) {
        function View(a, b0, b1, b2, b3, c0, c1, c2, c3, d) {
          this.data = a;
          this.shape = [b0, b1, b2, b3];
          this.stride = [c0, c1, c2, c3];
          this.offset = d | 0;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.dimension = 4;
        Object.defineProperty(proto, "size", {
          get: function size() {
            return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3];
          }
        });
        Object.defineProperty(proto, "order", { get: ORDER });
        proto.set = function set(i0, i1, i2, i3, v) {
          return dtype === "generic" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3] = v;
        };
        proto.get = function get(i0, i1, i2, i3) {
          return dtype === "generic" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3];
        };
        proto.index = function index(i0, i1, i2, i3) {
          return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3;
        };
        proto.hi = function hi(i0, i1, i2, i3) {
          return new View(
            this.data,
            typeof i0 !== "number" || i0 < 0 ? this.shape[0] : i0 | 0,
            typeof i1 !== "number" || i1 < 0 ? this.shape[1] : i1 | 0,
            typeof i2 !== "number" || i2 < 0 ? this.shape[2] : i2 | 0,
            typeof i3 !== "number" || i3 < 0 ? this.shape[3] : i3 | 0,
            this.stride[0],
            this.stride[1],
            this.stride[2],
            this.stride[3],
            this.offset
          );
        };
        proto.lo = function lo(i0, i1, i2, i3) {
          var b = this.offset, d = 0, a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], a3 = this.shape[3], c0 = this.stride[0], c1 = this.stride[1], c2 = this.stride[2], c3 = this.stride[3];
          if (typeof i0 === "number" && i0 >= 0) {
            d = i0 | 0;
            b += c0 * d;
            a0 -= d;
          }
          if (typeof i1 === "number" && i1 >= 0) {
            d = i1 | 0;
            b += c1 * d;
            a1 -= d;
          }
          if (typeof i2 === "number" && i2 >= 0) {
            d = i2 | 0;
            b += c2 * d;
            a2 -= d;
          }
          if (typeof i3 === "number" && i3 >= 0) {
            d = i3 | 0;
            b += c3 * d;
            a3 -= d;
          }
          return new View(this.data, a0, a1, a2, a3, c0, c1, c2, c3, b);
        };
        proto.step = function step(i0, i1, i2, i3) {
          var a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], a3 = this.shape[3], b0 = this.stride[0], b1 = this.stride[1], b2 = this.stride[2], b3 = this.stride[3], c = this.offset, d = 0, ceil = Math.ceil;
          if (typeof i0 === "number") {
            d = i0 | 0;
            if (d < 0) {
              c += b0 * (a0 - 1);
              a0 = ceil(-a0 / d);
            } else {
              a0 = ceil(a0 / d);
            }
            b0 *= d;
          }
          if (typeof i1 === "number") {
            d = i1 | 0;
            if (d < 0) {
              c += b1 * (a1 - 1);
              a1 = ceil(-a1 / d);
            } else {
              a1 = ceil(a1 / d);
            }
            b1 *= d;
          }
          if (typeof i2 === "number") {
            d = i2 | 0;
            if (d < 0) {
              c += b2 * (a2 - 1);
              a2 = ceil(-a2 / d);
            } else {
              a2 = ceil(a2 / d);
            }
            b2 *= d;
          }
          if (typeof i3 === "number") {
            d = i3 | 0;
            if (d < 0) {
              c += b3 * (a3 - 1);
              a3 = ceil(-a3 / d);
            } else {
              a3 = ceil(a3 / d);
            }
            b3 *= d;
          }
          return new View(this.data, a0, a1, a2, a3, b0, b1, b2, b3, c);
        };
        proto.transpose = function transpose(i0, i1, i2, i3) {
          i0 = i0 === void 0 ? 0 : i0 | 0;
          i1 = i1 === void 0 ? 1 : i1 | 0;
          i2 = i2 === void 0 ? 2 : i2 | 0;
          i3 = i3 === void 0 ? 3 : i3 | 0;
          var a = this.shape, b = this.stride;
          return new View(this.data, a[i0], a[i1], a[i2], a[i3], b[i0], b[i1], b[i2], b[i3], this.offset);
        };
        proto.pick = function pick(i0, i1, i2, i3) {
          var a = [], b = [], c = this.offset;
          if (typeof i0 === "number" && i0 >= 0) {
            c = c + this.stride[0] * i0 | 0;
          } else {
            a.push(this.shape[0]);
            b.push(this.stride[0]);
          }
          if (typeof i1 === "number" && i1 >= 0) {
            c = c + this.stride[1] * i1 | 0;
          } else {
            a.push(this.shape[1]);
            b.push(this.stride[1]);
          }
          if (typeof i2 === "number" && i2 >= 0) {
            c = c + this.stride[2] * i2 | 0;
          } else {
            a.push(this.shape[2]);
            b.push(this.stride[2]);
          }
          if (typeof i3 === "number" && i3 >= 0) {
            c = c + this.stride[3] * i3 | 0;
          } else {
            a.push(this.shape[3]);
            b.push(this.stride[3]);
          }
          var ctor = CTOR_LIST[a.length + 1];
          return ctor(this.data, a, b, c);
        };
        return function construct(data, shape, stride, offset) {
          return new View(data, shape[0], shape[1], shape[2], shape[3], stride[0], stride[1], stride[2], stride[3], offset);
        };
      },
      5: function anonymous(dtype, CTOR_LIST, ORDER) {
        function View(a, b0, b1, b2, b3, b4, c0, c1, c2, c3, c4, d) {
          this.data = a;
          this.shape = [b0, b1, b2, b3, b4];
          this.stride = [c0, c1, c2, c3, c4];
          this.offset = d | 0;
        }
        var proto = View.prototype;
        proto.dtype = dtype;
        proto.dimension = 5;
        Object.defineProperty(proto, "size", {
          get: function size() {
            return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3] * this.shape[4];
          }
        });
        Object.defineProperty(proto, "order", { get: ORDER });
        proto.set = function set(i0, i1, i2, i3, i4, v) {
          return dtype === "generic" ? this.data.set(
            this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4,
            v
          ) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4] = v;
        };
        proto.get = function get(i0, i1, i2, i3, i4) {
          return dtype === "generic" ? this.data.get(
            this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4
          ) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4];
        };
        proto.index = function index(i0, i1, i2, i3, i4) {
          return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4;
        };
        proto.hi = function hi(i0, i1, i2, i3, i4) {
          return new View(
            this.data,
            typeof i0 !== "number" || i0 < 0 ? this.shape[0] : i0 | 0,
            typeof i1 !== "number" || i1 < 0 ? this.shape[1] : i1 | 0,
            typeof i2 !== "number" || i2 < 0 ? this.shape[2] : i2 | 0,
            typeof i3 !== "number" || i3 < 0 ? this.shape[3] : i3 | 0,
            typeof i4 !== "number" || i4 < 0 ? this.shape[4] : i4 | 0,
            this.stride[0],
            this.stride[1],
            this.stride[2],
            this.stride[3],
            this.stride[4],
            this.offset
          );
        };
        proto.lo = function lo(i0, i1, i2, i3, i4) {
          var b = this.offset, d = 0, a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], a3 = this.shape[3], a4 = this.shape[4], c0 = this.stride[0], c1 = this.stride[1], c2 = this.stride[2], c3 = this.stride[3], c4 = this.stride[4];
          if (typeof i0 === "number" && i0 >= 0) {
            d = i0 | 0;
            b += c0 * d;
            a0 -= d;
          }
          if (typeof i1 === "number" && i1 >= 0) {
            d = i1 | 0;
            b += c1 * d;
            a1 -= d;
          }
          if (typeof i2 === "number" && i2 >= 0) {
            d = i2 | 0;
            b += c2 * d;
            a2 -= d;
          }
          if (typeof i3 === "number" && i3 >= 0) {
            d = i3 | 0;
            b += c3 * d;
            a3 -= d;
          }
          if (typeof i4 === "number" && i4 >= 0) {
            d = i4 | 0;
            b += c4 * d;
            a4 -= d;
          }
          return new View(this.data, a0, a1, a2, a3, a4, c0, c1, c2, c3, c4, b);
        };
        proto.step = function step(i0, i1, i2, i3, i4) {
          var a0 = this.shape[0], a1 = this.shape[1], a2 = this.shape[2], a3 = this.shape[3], a4 = this.shape[4], b0 = this.stride[0], b1 = this.stride[1], b2 = this.stride[2], b3 = this.stride[3], b4 = this.stride[4], c = this.offset, d = 0, ceil = Math.ceil;
          if (typeof i0 === "number") {
            d = i0 | 0;
            if (d < 0) {
              c += b0 * (a0 - 1);
              a0 = ceil(-a0 / d);
            } else {
              a0 = ceil(a0 / d);
            }
            b0 *= d;
          }
          if (typeof i1 === "number") {
            d = i1 | 0;
            if (d < 0) {
              c += b1 * (a1 - 1);
              a1 = ceil(-a1 / d);
            } else {
              a1 = ceil(a1 / d);
            }
            b1 *= d;
          }
          if (typeof i2 === "number") {
            d = i2 | 0;
            if (d < 0) {
              c += b2 * (a2 - 1);
              a2 = ceil(-a2 / d);
            } else {
              a2 = ceil(a2 / d);
            }
            b2 *= d;
          }
          if (typeof i3 === "number") {
            d = i3 | 0;
            if (d < 0) {
              c += b3 * (a3 - 1);
              a3 = ceil(-a3 / d);
            } else {
              a3 = ceil(a3 / d);
            }
            b3 *= d;
          }
          if (typeof i4 === "number") {
            d = i4 | 0;
            if (d < 0) {
              c += b4 * (a4 - 1);
              a4 = ceil(-a4 / d);
            } else {
              a4 = ceil(a4 / d);
            }
            b4 *= d;
          }
          return new View(this.data, a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, c);
        };
        proto.transpose = function transpose(i0, i1, i2, i3, i4) {
          i0 = i0 === void 0 ? 0 : i0 | 0;
          i1 = i1 === void 0 ? 1 : i1 | 0;
          i2 = i2 === void 0 ? 2 : i2 | 0;
          i3 = i3 === void 0 ? 3 : i3 | 0;
          i4 = i4 === void 0 ? 4 : i4 | 0;
          var a = this.shape, b = this.stride;
          return new View(this.data, a[i0], a[i1], a[i2], a[i3], a[i4], b[i0], b[i1], b[i2], b[i3], b[i4], this.offset);
        };
        proto.pick = function pick(i0, i1, i2, i3, i4) {
          var a = [], b = [], c = this.offset;
          if (typeof i0 === "number" && i0 >= 0) {
            c = c + this.stride[0] * i0 | 0;
          } else {
            a.push(this.shape[0]);
            b.push(this.stride[0]);
          }
          if (typeof i1 === "number" && i1 >= 0) {
            c = c + this.stride[1] * i1 | 0;
          } else {
            a.push(this.shape[1]);
            b.push(this.stride[1]);
          }
          if (typeof i2 === "number" && i2 >= 0) {
            c = c + this.stride[2] * i2 | 0;
          } else {
            a.push(this.shape[2]);
            b.push(this.stride[2]);
          }
          if (typeof i3 === "number" && i3 >= 0) {
            c = c + this.stride[3] * i3 | 0;
          } else {
            a.push(this.shape[3]);
            b.push(this.stride[3]);
          }
          if (typeof i4 === "number" && i4 >= 0) {
            c = c + this.stride[4] * i4 | 0;
          } else {
            a.push(this.shape[4]);
            b.push(this.stride[4]);
          }
          var ctor = CTOR_LIST[a.length + 1];
          return ctor(this.data, a, b, c);
        };
        return function construct(data, shape, stride, offset) {
          return new View(
            data,
            shape[0],
            shape[1],
            shape[2],
            shape[3],
            shape[4],
            stride[0],
            stride[1],
            stride[2],
            stride[3],
            stride[4],
            offset
          );
        };
      }
    };
    function compileConstructor(inType, inDimension) {
      var dKey = inDimension === -1 ? "T" : String(inDimension);
      var procedure = allFns[dKey];
      if (inDimension === -1) {
        return procedure(inType);
      } else if (inDimension === 0) {
        return procedure(inType, CACHED_CONSTRUCTORS[inType][0]);
      }
      return procedure(inType, CACHED_CONSTRUCTORS[inType], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "generic": [],
      "buffer": [],
      "array": [],
      // typed arrays
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8_clamped": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "bigint64": [],
      "biguint64": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var inType = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[inType];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(inType, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module2.exports = wrappedNDArrayCtor;
  }
});

// node_modules/gl-buffer/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/gl-buffer/buffer.js"(exports2, module2) {
    "use strict";
    var pool = require_pool();
    var ops = require_ndarray_ops();
    var ndarray = require_ndarray();
    var SUPPORTED_TYPES = [
      "uint8",
      "uint8_clamped",
      "uint16",
      "uint32",
      "int8",
      "int16",
      "int32",
      "float32"
    ];
    function GLBuffer(gl2, type, handle, length, usage) {
      this.gl = gl2;
      this.type = type;
      this.handle = handle;
      this.length = length;
      this.usage = usage;
    }
    var proto = GLBuffer.prototype;
    proto.bind = function() {
      this.gl.bindBuffer(this.type, this.handle);
    };
    proto.unbind = function() {
      this.gl.bindBuffer(this.type, null);
    };
    proto.dispose = function() {
      this.gl.deleteBuffer(this.handle);
    };
    function updateTypeArray(gl2, type, len, usage, data, offset) {
      var dataLen = data.length * data.BYTES_PER_ELEMENT;
      if (offset < 0) {
        gl2.bufferData(type, data, usage);
        return dataLen;
      }
      if (dataLen + offset > len) {
        throw new Error("gl-buffer: If resizing buffer, must not specify offset");
      }
      gl2.bufferSubData(type, offset, data);
      return len;
    }
    function makeScratchTypeArray(array, dtype) {
      var res = pool.malloc(array.length, dtype);
      var n = array.length;
      for (var i = 0; i < n; ++i) {
        res[i] = array[i];
      }
      return res;
    }
    function isPacked(shape, stride) {
      var n = 1;
      for (var i = stride.length - 1; i >= 0; --i) {
        if (stride[i] !== n) {
          return false;
        }
        n *= shape[i];
      }
      return true;
    }
    proto.update = function(array, offset) {
      if (typeof offset !== "number") {
        offset = -1;
      }
      this.bind();
      if (typeof array === "object" && typeof array.shape !== "undefined") {
        var dtype = array.dtype;
        if (SUPPORTED_TYPES.indexOf(dtype) < 0) {
          dtype = "float32";
        }
        if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
          var ext = gl.getExtension("OES_element_index_uint");
          if (ext && dtype !== "uint16") {
            dtype = "uint32";
          } else {
            dtype = "uint16";
          }
        }
        if (dtype === array.dtype && isPacked(array.shape, array.stride)) {
          if (array.offset === 0 && array.data.length === array.shape[0]) {
            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset);
          } else {
            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset);
          }
        } else {
          var tmp = pool.malloc(array.size, dtype);
          var ndt = ndarray(tmp, array.shape);
          ops.assign(ndt, array);
          if (offset < 0) {
            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset);
          } else {
            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset);
          }
          pool.free(tmp);
        }
      } else if (Array.isArray(array)) {
        var t;
        if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
          t = makeScratchTypeArray(array, "uint16");
        } else {
          t = makeScratchTypeArray(array, "float32");
        }
        if (offset < 0) {
          this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset);
        } else {
          this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset);
        }
        pool.free(t);
      } else if (typeof array === "object" && typeof array.length === "number") {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset);
      } else if (typeof array === "number" || array === void 0) {
        if (offset >= 0) {
          throw new Error("gl-buffer: Cannot specify offset when resizing buffer");
        }
        array = array | 0;
        if (array <= 0) {
          array = 1;
        }
        this.gl.bufferData(this.type, array | 0, this.usage);
        this.length = array;
      } else {
        throw new Error("gl-buffer: Invalid data type");
      }
    };
    function createBuffer(gl2, data, type, usage) {
      type = type || gl2.ARRAY_BUFFER;
      usage = usage || gl2.DYNAMIC_DRAW;
      if (type !== gl2.ARRAY_BUFFER && type !== gl2.ELEMENT_ARRAY_BUFFER) {
        throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER");
      }
      if (usage !== gl2.DYNAMIC_DRAW && usage !== gl2.STATIC_DRAW && usage !== gl2.STREAM_DRAW) {
        throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW");
      }
      var handle = gl2.createBuffer();
      var result = new GLBuffer(gl2, type, handle, 0, usage);
      result.update(data);
      return result;
    }
    module2.exports = createBuffer;
  }
});

// node_modules/gl-vao/lib/do-bind.js
var require_do_bind = __commonJS({
  "node_modules/gl-vao/lib/do-bind.js"(exports2, module2) {
    "use strict";
    function doBind(gl2, elements, attributes) {
      if (elements) {
        elements.bind();
      } else {
        gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, null);
      }
      var nattribs = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS) | 0;
      if (attributes) {
        if (attributes.length > nattribs) {
          throw new Error("gl-vao: Too many vertex attributes");
        }
        for (var i = 0; i < attributes.length; ++i) {
          var attrib = attributes[i];
          if (attrib.buffer) {
            var buffer = attrib.buffer;
            var size = attrib.size || 4;
            var type = attrib.type || gl2.FLOAT;
            var normalized = !!attrib.normalized;
            var stride = attrib.stride || 0;
            var offset = attrib.offset || 0;
            buffer.bind();
            gl2.enableVertexAttribArray(i);
            gl2.vertexAttribPointer(i, size, type, normalized, stride, offset);
          } else {
            if (typeof attrib === "number") {
              gl2.vertexAttrib1f(i, attrib);
            } else if (attrib.length === 1) {
              gl2.vertexAttrib1f(i, attrib[0]);
            } else if (attrib.length === 2) {
              gl2.vertexAttrib2f(i, attrib[0], attrib[1]);
            } else if (attrib.length === 3) {
              gl2.vertexAttrib3f(i, attrib[0], attrib[1], attrib[2]);
            } else if (attrib.length === 4) {
              gl2.vertexAttrib4f(i, attrib[0], attrib[1], attrib[2], attrib[3]);
            } else {
              throw new Error("gl-vao: Invalid vertex attribute");
            }
            gl2.disableVertexAttribArray(i);
          }
        }
        for (; i < nattribs; ++i) {
          gl2.disableVertexAttribArray(i);
        }
      } else {
        gl2.bindBuffer(gl2.ARRAY_BUFFER, null);
        for (var i = 0; i < nattribs; ++i) {
          gl2.disableVertexAttribArray(i);
        }
      }
    }
    module2.exports = doBind;
  }
});

// node_modules/gl-vao/lib/vao-native.js
var require_vao_native = __commonJS({
  "node_modules/gl-vao/lib/vao-native.js"(exports2, module2) {
    "use strict";
    var bindAttribs = require_do_bind();
    function VertexAttribute(location, dimension, a, b, c, d) {
      this.location = location;
      this.dimension = dimension;
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
    }
    VertexAttribute.prototype.bind = function(gl2) {
      switch (this.dimension) {
        case 1:
          gl2.vertexAttrib1f(this.location, this.a);
          break;
        case 2:
          gl2.vertexAttrib2f(this.location, this.a, this.b);
          break;
        case 3:
          gl2.vertexAttrib3f(this.location, this.a, this.b, this.c);
          break;
        case 4:
          gl2.vertexAttrib4f(this.location, this.a, this.b, this.c, this.d);
          break;
      }
    };
    function VAONative(gl2, ext, handle) {
      this.gl = gl2;
      this._ext = ext;
      this.handle = handle;
      this._attribs = [];
      this._useElements = false;
      this._elementsType = gl2.UNSIGNED_SHORT;
    }
    VAONative.prototype.bind = function() {
      this._ext.bindVertexArrayOES(this.handle);
      for (var i = 0; i < this._attribs.length; ++i) {
        this._attribs[i].bind(this.gl);
      }
    };
    VAONative.prototype.unbind = function() {
      this._ext.bindVertexArrayOES(null);
    };
    VAONative.prototype.dispose = function() {
      this._ext.deleteVertexArrayOES(this.handle);
    };
    VAONative.prototype.update = function(attributes, elements, elementsType) {
      this.bind();
      bindAttribs(this.gl, elements, attributes);
      this.unbind();
      this._attribs.length = 0;
      if (attributes)
        for (var i = 0; i < attributes.length; ++i) {
          var a = attributes[i];
          if (typeof a === "number") {
            this._attribs.push(new VertexAttribute(i, 1, a));
          } else if (Array.isArray(a)) {
            this._attribs.push(new VertexAttribute(i, a.length, a[0], a[1], a[2], a[3]));
          }
        }
      this._useElements = !!elements;
      this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;
    };
    VAONative.prototype.draw = function(mode, count, offset) {
      offset = offset || 0;
      var gl2 = this.gl;
      if (this._useElements) {
        gl2.drawElements(mode, count, this._elementsType, offset);
      } else {
        gl2.drawArrays(mode, offset, count);
      }
    };
    function createVAONative(gl2, ext) {
      return new VAONative(gl2, ext, ext.createVertexArrayOES());
    }
    module2.exports = createVAONative;
  }
});

// node_modules/gl-vao/lib/vao-emulated.js
var require_vao_emulated = __commonJS({
  "node_modules/gl-vao/lib/vao-emulated.js"(exports2, module2) {
    "use strict";
    var bindAttribs = require_do_bind();
    function VAOEmulated(gl2) {
      this.gl = gl2;
      this._elements = null;
      this._attributes = null;
      this._elementsType = gl2.UNSIGNED_SHORT;
    }
    VAOEmulated.prototype.bind = function() {
      bindAttribs(this.gl, this._elements, this._attributes);
    };
    VAOEmulated.prototype.update = function(attributes, elements, elementsType) {
      this._elements = elements;
      this._attributes = attributes;
      this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;
    };
    VAOEmulated.prototype.dispose = function() {
    };
    VAOEmulated.prototype.unbind = function() {
    };
    VAOEmulated.prototype.draw = function(mode, count, offset) {
      offset = offset || 0;
      var gl2 = this.gl;
      if (this._elements) {
        gl2.drawElements(mode, count, this._elementsType, offset);
      } else {
        gl2.drawArrays(mode, offset, count);
      }
    };
    function createVAOEmulated(gl2) {
      return new VAOEmulated(gl2);
    }
    module2.exports = createVAOEmulated;
  }
});

// node_modules/gl-vao/vao.js
var require_vao = __commonJS({
  "node_modules/gl-vao/vao.js"(exports2, module2) {
    "use strict";
    var createVAONative = require_vao_native();
    var createVAOEmulated = require_vao_emulated();
    function ExtensionShim(gl2) {
      this.bindVertexArrayOES = gl2.bindVertexArray.bind(gl2);
      this.createVertexArrayOES = gl2.createVertexArray.bind(gl2);
      this.deleteVertexArrayOES = gl2.deleteVertexArray.bind(gl2);
    }
    function createVAO(gl2, attributes, elements, elementsType) {
      var ext = gl2.createVertexArray ? new ExtensionShim(gl2) : gl2.getExtension("OES_vertex_array_object");
      var vao;
      if (ext) {
        vao = createVAONative(gl2, ext);
      } else {
        vao = createVAOEmulated(gl2);
      }
      vao.update(attributes, elements, elementsType);
      return vao;
    }
    module2.exports = createVAO;
  }
});

// node_modules/gl-texture2d/texture.js
var require_texture = __commonJS({
  "node_modules/gl-texture2d/texture.js"(exports2, module2) {
    "use strict";
    var ndarray = require_ndarray();
    var ops = require_ndarray_ops();
    var pool = require_pool();
    module2.exports = createTexture2D;
    var linearTypes = null;
    var filterTypes = null;
    var wrapTypes = null;
    function lazyInitLinearTypes(gl2) {
      linearTypes = [
        gl2.LINEAR,
        gl2.NEAREST_MIPMAP_LINEAR,
        gl2.LINEAR_MIPMAP_NEAREST,
        gl2.LINEAR_MIPMAP_NEAREST
      ];
      filterTypes = [
        gl2.NEAREST,
        gl2.LINEAR,
        gl2.NEAREST_MIPMAP_NEAREST,
        gl2.NEAREST_MIPMAP_LINEAR,
        gl2.LINEAR_MIPMAP_NEAREST,
        gl2.LINEAR_MIPMAP_LINEAR
      ];
      wrapTypes = [
        gl2.REPEAT,
        gl2.CLAMP_TO_EDGE,
        gl2.MIRRORED_REPEAT
      ];
    }
    function acceptTextureDOM(obj) {
      return "undefined" != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement || "undefined" != typeof HTMLImageElement && obj instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && obj instanceof HTMLVideoElement || "undefined" != typeof ImageData && obj instanceof ImageData;
    }
    var convertFloatToUint8 = function(out, inp) {
      ops.muls(out, inp, 255);
    };
    function reshapeTexture(tex, w, h) {
      var gl2 = tex.gl;
      var maxSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
      if (w < 0 || w > maxSize || h < 0 || h > maxSize) {
        throw new Error("gl-texture2d: Invalid texture size");
      }
      tex._shape = [w, h];
      tex.bind();
      gl2.texImage2D(gl2.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null);
      tex._mipLevels = [0];
      return tex;
    }
    function Texture2D(gl2, handle, width, height, format, type) {
      this.gl = gl2;
      this.handle = handle;
      this.format = format;
      this.type = type;
      this._shape = [width, height];
      this._mipLevels = [0];
      this._magFilter = gl2.NEAREST;
      this._minFilter = gl2.NEAREST;
      this._wrapS = gl2.CLAMP_TO_EDGE;
      this._wrapT = gl2.CLAMP_TO_EDGE;
      this._anisoSamples = 1;
      var parent = this;
      var wrapVector = [this._wrapS, this._wrapT];
      Object.defineProperties(wrapVector, [
        {
          get: function() {
            return parent._wrapS;
          },
          set: function(v) {
            return parent.wrapS = v;
          }
        },
        {
          get: function() {
            return parent._wrapT;
          },
          set: function(v) {
            return parent.wrapT = v;
          }
        }
      ]);
      this._wrapVector = wrapVector;
      var shapeVector = [this._shape[0], this._shape[1]];
      Object.defineProperties(shapeVector, [
        {
          get: function() {
            return parent._shape[0];
          },
          set: function(v) {
            return parent.width = v;
          }
        },
        {
          get: function() {
            return parent._shape[1];
          },
          set: function(v) {
            return parent.height = v;
          }
        }
      ]);
      this._shapeVector = shapeVector;
    }
    var proto = Texture2D.prototype;
    Object.defineProperties(proto, {
      minFilter: {
        get: function() {
          return this._minFilter;
        },
        set: function(v) {
          this.bind();
          var gl2 = this.gl;
          if (this.type === gl2.FLOAT && linearTypes.indexOf(v) >= 0) {
            if (!gl2.getExtension("OES_texture_float_linear")) {
              v = gl2.NEAREST;
            }
          }
          if (filterTypes.indexOf(v) < 0) {
            throw new Error("gl-texture2d: Unknown filter mode " + v);
          }
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, v);
          return this._minFilter = v;
        }
      },
      magFilter: {
        get: function() {
          return this._magFilter;
        },
        set: function(v) {
          this.bind();
          var gl2 = this.gl;
          if (this.type === gl2.FLOAT && linearTypes.indexOf(v) >= 0) {
            if (!gl2.getExtension("OES_texture_float_linear")) {
              v = gl2.NEAREST;
            }
          }
          if (filterTypes.indexOf(v) < 0) {
            throw new Error("gl-texture2d: Unknown filter mode " + v);
          }
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, v);
          return this._magFilter = v;
        }
      },
      mipSamples: {
        get: function() {
          return this._anisoSamples;
        },
        set: function(i) {
          var psamples = this._anisoSamples;
          this._anisoSamples = Math.max(i, 1) | 0;
          if (psamples !== this._anisoSamples) {
            var ext = this.gl.getExtension("EXT_texture_filter_anisotropic");
            if (ext) {
              this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples);
            }
          }
          return this._anisoSamples;
        }
      },
      wrapS: {
        get: function() {
          return this._wrapS;
        },
        set: function(v) {
          this.bind();
          if (wrapTypes.indexOf(v) < 0) {
            throw new Error("gl-texture2d: Unknown wrap mode " + v);
          }
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v);
          return this._wrapS = v;
        }
      },
      wrapT: {
        get: function() {
          return this._wrapT;
        },
        set: function(v) {
          this.bind();
          if (wrapTypes.indexOf(v) < 0) {
            throw new Error("gl-texture2d: Unknown wrap mode " + v);
          }
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v);
          return this._wrapT = v;
        }
      },
      wrap: {
        get: function() {
          return this._wrapVector;
        },
        set: function(v) {
          if (!Array.isArray(v)) {
            v = [v, v];
          }
          if (v.length !== 2) {
            throw new Error("gl-texture2d: Must specify wrap mode for rows and columns");
          }
          for (var i = 0; i < 2; ++i) {
            if (wrapTypes.indexOf(v[i]) < 0) {
              throw new Error("gl-texture2d: Unknown wrap mode " + v);
            }
          }
          this._wrapS = v[0];
          this._wrapT = v[1];
          var gl2 = this.gl;
          this.bind();
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, this._wrapS);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, this._wrapT);
          return v;
        }
      },
      shape: {
        get: function() {
          return this._shapeVector;
        },
        set: function(x) {
          if (!Array.isArray(x)) {
            x = [x | 0, x | 0];
          } else {
            if (x.length !== 2) {
              throw new Error("gl-texture2d: Invalid texture shape");
            }
          }
          reshapeTexture(this, x[0] | 0, x[1] | 0);
          return [x[0] | 0, x[1] | 0];
        }
      },
      width: {
        get: function() {
          return this._shape[0];
        },
        set: function(w) {
          w = w | 0;
          reshapeTexture(this, w, this._shape[1]);
          return w;
        }
      },
      height: {
        get: function() {
          return this._shape[1];
        },
        set: function(h) {
          h = h | 0;
          reshapeTexture(this, this._shape[0], h);
          return h;
        }
      }
    });
    proto.bind = function(unit) {
      var gl2 = this.gl;
      if (unit !== void 0) {
        gl2.activeTexture(gl2.TEXTURE0 + (unit | 0));
      }
      gl2.bindTexture(gl2.TEXTURE_2D, this.handle);
      if (unit !== void 0) {
        return unit | 0;
      }
      return gl2.getParameter(gl2.ACTIVE_TEXTURE) - gl2.TEXTURE0;
    };
    proto.dispose = function() {
      this.gl.deleteTexture(this.handle);
    };
    proto.generateMipmap = function() {
      this.bind();
      this.gl.generateMipmap(this.gl.TEXTURE_2D);
      var l = Math.min(this._shape[0], this._shape[1]);
      for (var i = 0; l > 0; ++i, l >>>= 1) {
        if (this._mipLevels.indexOf(i) < 0) {
          this._mipLevels.push(i);
        }
      }
    };
    proto.setPixels = function(data, x_off, y_off, mip_level) {
      var gl2 = this.gl;
      this.bind();
      if (Array.isArray(x_off)) {
        mip_level = y_off;
        y_off = x_off[1] | 0;
        x_off = x_off[0] | 0;
      } else {
        x_off = x_off || 0;
        y_off = y_off || 0;
      }
      mip_level = mip_level || 0;
      var directData = acceptTextureDOM(data) ? data : data.raw;
      if (directData) {
        var needsMip = this._mipLevels.indexOf(mip_level) < 0;
        if (needsMip) {
          gl2.texImage2D(gl2.TEXTURE_2D, 0, this.format, this.format, this.type, directData);
          this._mipLevels.push(mip_level);
        } else {
          gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData);
        }
      } else if (data.shape && data.stride && data.data) {
        if (data.shape.length < 2 || x_off + data.shape[1] > this._shape[1] >>> mip_level || y_off + data.shape[0] > this._shape[0] >>> mip_level || x_off < 0 || y_off < 0) {
          throw new Error("gl-texture2d: Texture dimensions are out of bounds");
        }
        texSubImageArray(gl2, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data);
      } else {
        throw new Error("gl-texture2d: Unsupported data type");
      }
    };
    function isPacked(shape, stride) {
      if (shape.length === 3) {
        return stride[2] === 1 && stride[1] === shape[0] * shape[2] && stride[0] === shape[2];
      }
      return stride[0] === 1 && stride[1] === shape[0];
    }
    function texSubImageArray(gl2, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
      var dtype = array.dtype;
      var shape = array.shape.slice();
      if (shape.length < 2 || shape.length > 3) {
        throw new Error("gl-texture2d: Invalid ndarray, must be 2d or 3d");
      }
      var type = 0, format = 0;
      var packed = isPacked(shape, array.stride.slice());
      if (dtype === "float32") {
        type = gl2.FLOAT;
      } else if (dtype === "float64") {
        type = gl2.FLOAT;
        packed = false;
        dtype = "float32";
      } else if (dtype === "uint8") {
        type = gl2.UNSIGNED_BYTE;
      } else {
        type = gl2.UNSIGNED_BYTE;
        packed = false;
        dtype = "uint8";
      }
      var channels = 1;
      if (shape.length === 2) {
        format = gl2.LUMINANCE;
        shape = [shape[0], shape[1], 1];
        array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);
      } else if (shape.length === 3) {
        if (shape[2] === 1) {
          format = gl2.ALPHA;
        } else if (shape[2] === 2) {
          format = gl2.LUMINANCE_ALPHA;
        } else if (shape[2] === 3) {
          format = gl2.RGB;
        } else if (shape[2] === 4) {
          format = gl2.RGBA;
        } else {
          throw new Error("gl-texture2d: Invalid shape for pixel coords");
        }
        channels = shape[2];
      } else {
        throw new Error("gl-texture2d: Invalid shape for texture");
      }
      if ((format === gl2.LUMINANCE || format === gl2.ALPHA) && (cformat === gl2.LUMINANCE || cformat === gl2.ALPHA)) {
        format = cformat;
      }
      if (format !== cformat) {
        throw new Error("gl-texture2d: Incompatible texture format for setPixels");
      }
      var size = array.size;
      var needsMip = mipLevels.indexOf(mip_level) < 0;
      if (needsMip) {
        mipLevels.push(mip_level);
      }
      if (type === ctype && packed) {
        if (array.offset === 0 && array.data.length === size) {
          if (needsMip) {
            gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data);
          } else {
            gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data);
          }
        } else {
          if (needsMip) {
            gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset + size));
          } else {
            gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset + size));
          }
        }
      } else {
        var pack_buffer;
        if (ctype === gl2.FLOAT) {
          pack_buffer = pool.mallocFloat32(size);
        } else {
          pack_buffer = pool.mallocUint8(size);
        }
        var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2] * shape[0], 1]);
        if (type === gl2.FLOAT && ctype === gl2.UNSIGNED_BYTE) {
          convertFloatToUint8(pack_view, array);
        } else {
          ops.assign(pack_view, array);
        }
        if (needsMip) {
          gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size));
        } else {
          gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size));
        }
        if (ctype === gl2.FLOAT) {
          pool.freeFloat32(pack_buffer);
        } else {
          pool.freeUint8(pack_buffer);
        }
      }
    }
    function initTexture(gl2) {
      var tex = gl2.createTexture();
      gl2.bindTexture(gl2.TEXTURE_2D, tex);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
      return tex;
    }
    function createTextureShape(gl2, width, height, format, type) {
      var maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
      if (width < 0 || width > maxTextureSize || height < 0 || height > maxTextureSize) {
        throw new Error("gl-texture2d: Invalid texture shape");
      }
      if (type === gl2.FLOAT && !gl2.getExtension("OES_texture_float")) {
        throw new Error("gl-texture2d: Floating point textures not supported on this platform");
      }
      var tex = initTexture(gl2);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
      return new Texture2D(gl2, tex, width, height, format, type);
    }
    function createTextureDOM(gl2, directData, width, height, format, type) {
      var tex = initTexture(gl2);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, format, format, type, directData);
      return new Texture2D(gl2, tex, width, height, format, type);
    }
    function createTextureArray(gl2, array) {
      var dtype = array.dtype;
      var shape = array.shape.slice();
      var maxSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
      if (shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
        throw new Error("gl-texture2d: Invalid texture size");
      }
      var packed = isPacked(shape, array.stride.slice());
      var type = 0;
      if (dtype === "float32") {
        type = gl2.FLOAT;
      } else if (dtype === "float64") {
        type = gl2.FLOAT;
        packed = false;
        dtype = "float32";
      } else if (dtype === "uint8") {
        type = gl2.UNSIGNED_BYTE;
      } else {
        type = gl2.UNSIGNED_BYTE;
        packed = false;
        dtype = "uint8";
      }
      var format = 0;
      if (shape.length === 2) {
        format = gl2.LUMINANCE;
        shape = [shape[0], shape[1], 1];
        array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);
      } else if (shape.length === 3) {
        if (shape[2] === 1) {
          format = gl2.ALPHA;
        } else if (shape[2] === 2) {
          format = gl2.LUMINANCE_ALPHA;
        } else if (shape[2] === 3) {
          format = gl2.RGB;
        } else if (shape[2] === 4) {
          format = gl2.RGBA;
        } else {
          throw new Error("gl-texture2d: Invalid shape for pixel coords");
        }
      } else {
        throw new Error("gl-texture2d: Invalid shape for texture");
      }
      if (type === gl2.FLOAT && !gl2.getExtension("OES_texture_float")) {
        type = gl2.UNSIGNED_BYTE;
        packed = false;
      }
      var buffer, buf_store;
      var size = array.size;
      if (!packed) {
        var stride = [shape[2], shape[2] * shape[0], 1];
        buf_store = pool.malloc(size, dtype);
        var buf_array = ndarray(buf_store, shape, stride, 0);
        if ((dtype === "float32" || dtype === "float64") && type === gl2.UNSIGNED_BYTE) {
          convertFloatToUint8(buf_array, array);
        } else {
          ops.assign(buf_array, array);
        }
        buffer = buf_store.subarray(0, size);
      } else if (array.offset === 0 && array.data.length === size) {
        buffer = array.data;
      } else {
        buffer = array.data.subarray(array.offset, array.offset + size);
      }
      var tex = initTexture(gl2);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer);
      if (!packed) {
        pool.free(buf_store);
      }
      return new Texture2D(gl2, tex, shape[0], shape[1], format, type);
    }
    function createTexture2D(gl2) {
      if (arguments.length <= 1) {
        throw new Error("gl-texture2d: Missing arguments for texture2d constructor");
      }
      if (!linearTypes) {
        lazyInitLinearTypes(gl2);
      }
      if (typeof arguments[1] === "number") {
        return createTextureShape(gl2, arguments[1], arguments[2], arguments[3] || gl2.RGBA, arguments[4] || gl2.UNSIGNED_BYTE);
      }
      if (Array.isArray(arguments[1])) {
        return createTextureShape(gl2, arguments[1][0] | 0, arguments[1][1] | 0, arguments[2] || gl2.RGBA, arguments[3] || gl2.UNSIGNED_BYTE);
      }
      if (typeof arguments[1] === "object") {
        var obj = arguments[1];
        var directData = acceptTextureDOM(obj) ? obj : obj.raw;
        if (directData) {
          return createTextureDOM(gl2, directData, obj.width | 0, obj.height | 0, arguments[2] || gl2.RGBA, arguments[3] || gl2.UNSIGNED_BYTE);
        } else if (obj.shape && obj.data && obj.stride) {
          return createTextureArray(gl2, obj);
        }
      }
      throw new Error("gl-texture2d: Invalid arguments for texture2d constructor");
    }
  }
});

// node_modules/gl-mat4/multiply.js
var require_multiply2 = __commonJS({
  "node_modules/gl-mat4/multiply.js"(exports2, module2) {
    module2.exports = multiply;
    function multiply(out, a, b) {
      var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
      var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }
  }
});

// node_modules/gl-mat4/invert.js
var require_invert = __commonJS({
  "node_modules/gl-mat4/invert.js"(exports2, module2) {
    module2.exports = invert;
    function invert(out, a) {
      var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
  }
});

// node_modules/colormap/colorScale.js
var require_colorScale = __commonJS({
  "node_modules/colormap/colorScale.js"(exports2, module2) {
    module2.exports = {
      "jet": [{ "index": 0, "rgb": [0, 0, 131] }, { "index": 0.125, "rgb": [0, 60, 170] }, { "index": 0.375, "rgb": [5, 255, 255] }, { "index": 0.625, "rgb": [255, 255, 0] }, { "index": 0.875, "rgb": [250, 0, 0] }, { "index": 1, "rgb": [128, 0, 0] }],
      "hsv": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 0.169, "rgb": [253, 255, 2] }, { "index": 0.173, "rgb": [247, 255, 2] }, { "index": 0.337, "rgb": [0, 252, 4] }, { "index": 0.341, "rgb": [0, 252, 10] }, { "index": 0.506, "rgb": [1, 249, 255] }, { "index": 0.671, "rgb": [2, 0, 253] }, { "index": 0.675, "rgb": [8, 0, 253] }, { "index": 0.839, "rgb": [255, 0, 251] }, { "index": 0.843, "rgb": [255, 0, 245] }, { "index": 1, "rgb": [255, 0, 6] }],
      "hot": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.3, "rgb": [230, 0, 0] }, { "index": 0.6, "rgb": [255, 210, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
      "spring": [{ "index": 0, "rgb": [255, 0, 255] }, { "index": 1, "rgb": [255, 255, 0] }],
      "summer": [{ "index": 0, "rgb": [0, 128, 102] }, { "index": 1, "rgb": [255, 255, 102] }],
      "autumn": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 1, "rgb": [255, 255, 0] }],
      "winter": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [0, 255, 128] }],
      "bone": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.376, "rgb": [84, 84, 116] }, { "index": 0.753, "rgb": [169, 200, 200] }, { "index": 1, "rgb": [255, 255, 255] }],
      "copper": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.804, "rgb": [255, 160, 102] }, { "index": 1, "rgb": [255, 199, 127] }],
      "greys": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
      "yignbu": [{ "index": 0, "rgb": [8, 29, 88] }, { "index": 0.125, "rgb": [37, 52, 148] }, { "index": 0.25, "rgb": [34, 94, 168] }, { "index": 0.375, "rgb": [29, 145, 192] }, { "index": 0.5, "rgb": [65, 182, 196] }, { "index": 0.625, "rgb": [127, 205, 187] }, { "index": 0.75, "rgb": [199, 233, 180] }, { "index": 0.875, "rgb": [237, 248, 217] }, { "index": 1, "rgb": [255, 255, 217] }],
      "greens": [{ "index": 0, "rgb": [0, 68, 27] }, { "index": 0.125, "rgb": [0, 109, 44] }, { "index": 0.25, "rgb": [35, 139, 69] }, { "index": 0.375, "rgb": [65, 171, 93] }, { "index": 0.5, "rgb": [116, 196, 118] }, { "index": 0.625, "rgb": [161, 217, 155] }, { "index": 0.75, "rgb": [199, 233, 192] }, { "index": 0.875, "rgb": [229, 245, 224] }, { "index": 1, "rgb": [247, 252, 245] }],
      "yiorrd": [{ "index": 0, "rgb": [128, 0, 38] }, { "index": 0.125, "rgb": [189, 0, 38] }, { "index": 0.25, "rgb": [227, 26, 28] }, { "index": 0.375, "rgb": [252, 78, 42] }, { "index": 0.5, "rgb": [253, 141, 60] }, { "index": 0.625, "rgb": [254, 178, 76] }, { "index": 0.75, "rgb": [254, 217, 118] }, { "index": 0.875, "rgb": [255, 237, 160] }, { "index": 1, "rgb": [255, 255, 204] }],
      "bluered": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [255, 0, 0] }],
      "rdbu": [{ "index": 0, "rgb": [5, 10, 172] }, { "index": 0.35, "rgb": [106, 137, 247] }, { "index": 0.5, "rgb": [190, 190, 190] }, { "index": 0.6, "rgb": [220, 170, 132] }, { "index": 0.7, "rgb": [230, 145, 90] }, { "index": 1, "rgb": [178, 10, 28] }],
      "picnic": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 0.1, "rgb": [51, 153, 255] }, { "index": 0.2, "rgb": [102, 204, 255] }, { "index": 0.3, "rgb": [153, 204, 255] }, { "index": 0.4, "rgb": [204, 204, 255] }, { "index": 0.5, "rgb": [255, 255, 255] }, { "index": 0.6, "rgb": [255, 204, 255] }, { "index": 0.7, "rgb": [255, 153, 255] }, { "index": 0.8, "rgb": [255, 102, 204] }, { "index": 0.9, "rgb": [255, 102, 102] }, { "index": 1, "rgb": [255, 0, 0] }],
      "rainbow": [{ "index": 0, "rgb": [150, 0, 90] }, { "index": 0.125, "rgb": [0, 0, 200] }, { "index": 0.25, "rgb": [0, 25, 255] }, { "index": 0.375, "rgb": [0, 152, 255] }, { "index": 0.5, "rgb": [44, 255, 150] }, { "index": 0.625, "rgb": [151, 255, 0] }, { "index": 0.75, "rgb": [255, 234, 0] }, { "index": 0.875, "rgb": [255, 111, 0] }, { "index": 1, "rgb": [255, 0, 0] }],
      "portland": [{ "index": 0, "rgb": [12, 51, 131] }, { "index": 0.25, "rgb": [10, 136, 186] }, { "index": 0.5, "rgb": [242, 211, 56] }, { "index": 0.75, "rgb": [242, 143, 56] }, { "index": 1, "rgb": [217, 30, 30] }],
      "blackbody": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.2, "rgb": [230, 0, 0] }, { "index": 0.4, "rgb": [230, 210, 0] }, { "index": 0.7, "rgb": [255, 255, 255] }, { "index": 1, "rgb": [160, 200, 255] }],
      "earth": [{ "index": 0, "rgb": [0, 0, 130] }, { "index": 0.1, "rgb": [0, 180, 180] }, { "index": 0.2, "rgb": [40, 210, 40] }, { "index": 0.4, "rgb": [230, 230, 50] }, { "index": 0.6, "rgb": [120, 70, 20] }, { "index": 1, "rgb": [255, 255, 255] }],
      "electric": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.15, "rgb": [30, 0, 100] }, { "index": 0.4, "rgb": [120, 0, 100] }, { "index": 0.6, "rgb": [160, 90, 0] }, { "index": 0.8, "rgb": [230, 200, 0] }, { "index": 1, "rgb": [255, 250, 220] }],
      "alpha": [{ "index": 0, "rgb": [255, 255, 255, 0] }, { "index": 1, "rgb": [255, 255, 255, 1] }],
      "viridis": [{ "index": 0, "rgb": [68, 1, 84] }, { "index": 0.13, "rgb": [71, 44, 122] }, { "index": 0.25, "rgb": [59, 81, 139] }, { "index": 0.38, "rgb": [44, 113, 142] }, { "index": 0.5, "rgb": [33, 144, 141] }, { "index": 0.63, "rgb": [39, 173, 129] }, { "index": 0.75, "rgb": [92, 200, 99] }, { "index": 0.88, "rgb": [170, 220, 50] }, { "index": 1, "rgb": [253, 231, 37] }],
      "inferno": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [31, 12, 72] }, { "index": 0.25, "rgb": [85, 15, 109] }, { "index": 0.38, "rgb": [136, 34, 106] }, { "index": 0.5, "rgb": [186, 54, 85] }, { "index": 0.63, "rgb": [227, 89, 51] }, { "index": 0.75, "rgb": [249, 140, 10] }, { "index": 0.88, "rgb": [249, 201, 50] }, { "index": 1, "rgb": [252, 255, 164] }],
      "magma": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [28, 16, 68] }, { "index": 0.25, "rgb": [79, 18, 123] }, { "index": 0.38, "rgb": [129, 37, 129] }, { "index": 0.5, "rgb": [181, 54, 122] }, { "index": 0.63, "rgb": [229, 80, 100] }, { "index": 0.75, "rgb": [251, 135, 97] }, { "index": 0.88, "rgb": [254, 194, 135] }, { "index": 1, "rgb": [252, 253, 191] }],
      "plasma": [{ "index": 0, "rgb": [13, 8, 135] }, { "index": 0.13, "rgb": [75, 3, 161] }, { "index": 0.25, "rgb": [125, 3, 168] }, { "index": 0.38, "rgb": [168, 34, 150] }, { "index": 0.5, "rgb": [203, 70, 121] }, { "index": 0.63, "rgb": [229, 107, 93] }, { "index": 0.75, "rgb": [248, 148, 65] }, { "index": 0.88, "rgb": [253, 195, 40] }, { "index": 1, "rgb": [240, 249, 33] }],
      "warm": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [172, 0, 187] }, { "index": 0.25, "rgb": [219, 0, 170] }, { "index": 0.38, "rgb": [255, 0, 130] }, { "index": 0.5, "rgb": [255, 63, 74] }, { "index": 0.63, "rgb": [255, 123, 0] }, { "index": 0.75, "rgb": [234, 176, 0] }, { "index": 0.88, "rgb": [190, 228, 0] }, { "index": 1, "rgb": [147, 255, 0] }],
      "cool": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [116, 0, 218] }, { "index": 0.25, "rgb": [98, 74, 237] }, { "index": 0.38, "rgb": [68, 146, 231] }, { "index": 0.5, "rgb": [0, 204, 197] }, { "index": 0.63, "rgb": [0, 247, 146] }, { "index": 0.75, "rgb": [0, 255, 88] }, { "index": 0.88, "rgb": [40, 255, 8] }, { "index": 1, "rgb": [147, 255, 0] }],
      "rainbow-soft": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.1, "rgb": [199, 0, 180] }, { "index": 0.2, "rgb": [255, 0, 121] }, { "index": 0.3, "rgb": [255, 108, 0] }, { "index": 0.4, "rgb": [222, 194, 0] }, { "index": 0.5, "rgb": [150, 255, 0] }, { "index": 0.6, "rgb": [0, 255, 55] }, { "index": 0.7, "rgb": [0, 246, 150] }, { "index": 0.8, "rgb": [50, 167, 222] }, { "index": 0.9, "rgb": [103, 51, 235] }, { "index": 1, "rgb": [124, 0, 186] }],
      "bathymetry": [{ "index": 0, "rgb": [40, 26, 44] }, { "index": 0.13, "rgb": [59, 49, 90] }, { "index": 0.25, "rgb": [64, 76, 139] }, { "index": 0.38, "rgb": [63, 110, 151] }, { "index": 0.5, "rgb": [72, 142, 158] }, { "index": 0.63, "rgb": [85, 174, 163] }, { "index": 0.75, "rgb": [120, 206, 163] }, { "index": 0.88, "rgb": [187, 230, 172] }, { "index": 1, "rgb": [253, 254, 204] }],
      "cdom": [{ "index": 0, "rgb": [47, 15, 62] }, { "index": 0.13, "rgb": [87, 23, 86] }, { "index": 0.25, "rgb": [130, 28, 99] }, { "index": 0.38, "rgb": [171, 41, 96] }, { "index": 0.5, "rgb": [206, 67, 86] }, { "index": 0.63, "rgb": [230, 106, 84] }, { "index": 0.75, "rgb": [242, 149, 103] }, { "index": 0.88, "rgb": [249, 193, 135] }, { "index": 1, "rgb": [254, 237, 176] }],
      "chlorophyll": [{ "index": 0, "rgb": [18, 36, 20] }, { "index": 0.13, "rgb": [25, 63, 41] }, { "index": 0.25, "rgb": [24, 91, 59] }, { "index": 0.38, "rgb": [13, 119, 72] }, { "index": 0.5, "rgb": [18, 148, 80] }, { "index": 0.63, "rgb": [80, 173, 89] }, { "index": 0.75, "rgb": [132, 196, 122] }, { "index": 0.88, "rgb": [175, 221, 162] }, { "index": 1, "rgb": [215, 249, 208] }],
      "density": [{ "index": 0, "rgb": [54, 14, 36] }, { "index": 0.13, "rgb": [89, 23, 80] }, { "index": 0.25, "rgb": [110, 45, 132] }, { "index": 0.38, "rgb": [120, 77, 178] }, { "index": 0.5, "rgb": [120, 113, 213] }, { "index": 0.63, "rgb": [115, 151, 228] }, { "index": 0.75, "rgb": [134, 185, 227] }, { "index": 0.88, "rgb": [177, 214, 227] }, { "index": 1, "rgb": [230, 241, 241] }],
      "freesurface-blue": [{ "index": 0, "rgb": [30, 4, 110] }, { "index": 0.13, "rgb": [47, 14, 176] }, { "index": 0.25, "rgb": [41, 45, 236] }, { "index": 0.38, "rgb": [25, 99, 212] }, { "index": 0.5, "rgb": [68, 131, 200] }, { "index": 0.63, "rgb": [114, 156, 197] }, { "index": 0.75, "rgb": [157, 181, 203] }, { "index": 0.88, "rgb": [200, 208, 216] }, { "index": 1, "rgb": [241, 237, 236] }],
      "freesurface-red": [{ "index": 0, "rgb": [60, 9, 18] }, { "index": 0.13, "rgb": [100, 17, 27] }, { "index": 0.25, "rgb": [142, 20, 29] }, { "index": 0.38, "rgb": [177, 43, 27] }, { "index": 0.5, "rgb": [192, 87, 63] }, { "index": 0.63, "rgb": [205, 125, 105] }, { "index": 0.75, "rgb": [216, 162, 148] }, { "index": 0.88, "rgb": [227, 199, 193] }, { "index": 1, "rgb": [241, 237, 236] }],
      "oxygen": [{ "index": 0, "rgb": [64, 5, 5] }, { "index": 0.13, "rgb": [106, 6, 15] }, { "index": 0.25, "rgb": [144, 26, 7] }, { "index": 0.38, "rgb": [168, 64, 3] }, { "index": 0.5, "rgb": [188, 100, 4] }, { "index": 0.63, "rgb": [206, 136, 11] }, { "index": 0.75, "rgb": [220, 174, 25] }, { "index": 0.88, "rgb": [231, 215, 44] }, { "index": 1, "rgb": [248, 254, 105] }],
      "par": [{ "index": 0, "rgb": [51, 20, 24] }, { "index": 0.13, "rgb": [90, 32, 35] }, { "index": 0.25, "rgb": [129, 44, 34] }, { "index": 0.38, "rgb": [159, 68, 25] }, { "index": 0.5, "rgb": [182, 99, 19] }, { "index": 0.63, "rgb": [199, 134, 22] }, { "index": 0.75, "rgb": [212, 171, 35] }, { "index": 0.88, "rgb": [221, 210, 54] }, { "index": 1, "rgb": [225, 253, 75] }],
      "phase": [{ "index": 0, "rgb": [145, 105, 18] }, { "index": 0.13, "rgb": [184, 71, 38] }, { "index": 0.25, "rgb": [186, 58, 115] }, { "index": 0.38, "rgb": [160, 71, 185] }, { "index": 0.5, "rgb": [110, 97, 218] }, { "index": 0.63, "rgb": [50, 123, 164] }, { "index": 0.75, "rgb": [31, 131, 110] }, { "index": 0.88, "rgb": [77, 129, 34] }, { "index": 1, "rgb": [145, 105, 18] }],
      "salinity": [{ "index": 0, "rgb": [42, 24, 108] }, { "index": 0.13, "rgb": [33, 50, 162] }, { "index": 0.25, "rgb": [15, 90, 145] }, { "index": 0.38, "rgb": [40, 118, 137] }, { "index": 0.5, "rgb": [59, 146, 135] }, { "index": 0.63, "rgb": [79, 175, 126] }, { "index": 0.75, "rgb": [120, 203, 104] }, { "index": 0.88, "rgb": [193, 221, 100] }, { "index": 1, "rgb": [253, 239, 154] }],
      "temperature": [{ "index": 0, "rgb": [4, 35, 51] }, { "index": 0.13, "rgb": [23, 51, 122] }, { "index": 0.25, "rgb": [85, 59, 157] }, { "index": 0.38, "rgb": [129, 79, 143] }, { "index": 0.5, "rgb": [175, 95, 130] }, { "index": 0.63, "rgb": [222, 112, 101] }, { "index": 0.75, "rgb": [249, 146, 66] }, { "index": 0.88, "rgb": [249, 196, 65] }, { "index": 1, "rgb": [232, 250, 91] }],
      "turbidity": [{ "index": 0, "rgb": [34, 31, 27] }, { "index": 0.13, "rgb": [65, 50, 41] }, { "index": 0.25, "rgb": [98, 69, 52] }, { "index": 0.38, "rgb": [131, 89, 57] }, { "index": 0.5, "rgb": [161, 112, 59] }, { "index": 0.63, "rgb": [185, 140, 66] }, { "index": 0.75, "rgb": [202, 174, 88] }, { "index": 0.88, "rgb": [216, 209, 126] }, { "index": 1, "rgb": [233, 246, 171] }],
      "velocity-blue": [{ "index": 0, "rgb": [17, 32, 64] }, { "index": 0.13, "rgb": [35, 52, 116] }, { "index": 0.25, "rgb": [29, 81, 156] }, { "index": 0.38, "rgb": [31, 113, 162] }, { "index": 0.5, "rgb": [50, 144, 169] }, { "index": 0.63, "rgb": [87, 173, 176] }, { "index": 0.75, "rgb": [149, 196, 189] }, { "index": 0.88, "rgb": [203, 221, 211] }, { "index": 1, "rgb": [254, 251, 230] }],
      "velocity-green": [{ "index": 0, "rgb": [23, 35, 19] }, { "index": 0.13, "rgb": [24, 64, 38] }, { "index": 0.25, "rgb": [11, 95, 45] }, { "index": 0.38, "rgb": [39, 123, 35] }, { "index": 0.5, "rgb": [95, 146, 12] }, { "index": 0.63, "rgb": [152, 165, 18] }, { "index": 0.75, "rgb": [201, 186, 69] }, { "index": 0.88, "rgb": [233, 216, 137] }, { "index": 1, "rgb": [255, 253, 205] }],
      "cubehelix": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.07, "rgb": [22, 5, 59] }, { "index": 0.13, "rgb": [60, 4, 105] }, { "index": 0.2, "rgb": [109, 1, 135] }, { "index": 0.27, "rgb": [161, 0, 147] }, { "index": 0.33, "rgb": [210, 2, 142] }, { "index": 0.4, "rgb": [251, 11, 123] }, { "index": 0.47, "rgb": [255, 29, 97] }, { "index": 0.53, "rgb": [255, 54, 69] }, { "index": 0.6, "rgb": [255, 85, 46] }, { "index": 0.67, "rgb": [255, 120, 34] }, { "index": 0.73, "rgb": [255, 157, 37] }, { "index": 0.8, "rgb": [241, 191, 57] }, { "index": 0.87, "rgb": [224, 220, 93] }, { "index": 0.93, "rgb": [218, 241, 142] }, { "index": 1, "rgb": [227, 253, 198] }]
    };
  }
});

// node_modules/lerp/index.js
var require_lerp2 = __commonJS({
  "node_modules/lerp/index.js"(exports2, module2) {
    function lerp(v0, v1, t) {
      return v0 * (1 - t) + v1 * t;
    }
    module2.exports = lerp;
  }
});

// node_modules/colormap/index.js
var require_colormap = __commonJS({
  "node_modules/colormap/index.js"(exports2, module2) {
    "use strict";
    var colorScale = require_colorScale();
    var lerp = require_lerp2();
    module2.exports = createColormap;
    function createColormap(spec) {
      var indicies, fromrgba, torgba, nsteps, cmap, colormap, format, nshades, colors, alpha, i;
      if (!spec) spec = {};
      nshades = (spec.nshades || 72) - 1;
      format = spec.format || "hex";
      colormap = spec.colormap;
      if (!colormap) colormap = "jet";
      if (typeof colormap === "string") {
        colormap = colormap.toLowerCase();
        if (!colorScale[colormap]) {
          throw Error(colormap + " not a supported colorscale");
        }
        cmap = colorScale[colormap];
      } else if (Array.isArray(colormap)) {
        cmap = colormap.slice();
      } else {
        throw Error("unsupported colormap option", colormap);
      }
      if (cmap.length > nshades + 1) {
        throw new Error(
          colormap + " map requires nshades to be at least size " + cmap.length
        );
      }
      if (!Array.isArray(spec.alpha)) {
        if (typeof spec.alpha === "number") {
          alpha = [spec.alpha, spec.alpha];
        } else {
          alpha = [1, 1];
        }
      } else if (spec.alpha.length !== 2) {
        alpha = [1, 1];
      } else {
        alpha = spec.alpha.slice();
      }
      indicies = cmap.map(function(c) {
        return Math.round(c.index * nshades);
      });
      alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
      alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
      var steps = cmap.map(function(c, i2) {
        var index = cmap[i2].index;
        var rgba = cmap[i2].rgb.slice();
        if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
          return rgba;
        }
        rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
        return rgba;
      });
      var colors = [];
      for (i = 0; i < indicies.length - 1; ++i) {
        nsteps = indicies[i + 1] - indicies[i];
        fromrgba = steps[i];
        torgba = steps[i + 1];
        for (var j = 0; j < nsteps; j++) {
          var amt = j / nsteps;
          colors.push([
            Math.round(lerp(fromrgba[0], torgba[0], amt)),
            Math.round(lerp(fromrgba[1], torgba[1], amt)),
            Math.round(lerp(fromrgba[2], torgba[2], amt)),
            lerp(fromrgba[3], torgba[3], amt)
          ]);
        }
      }
      colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));
      if (format === "hex") colors = colors.map(rgb2hex);
      else if (format === "rgbaString") colors = colors.map(rgbaStr);
      else if (format === "float") colors = colors.map(rgb2float);
      return colors;
    }
    function rgb2float(rgba) {
      return [
        rgba[0] / 255,
        rgba[1] / 255,
        rgba[2] / 255,
        rgba[3]
      ];
    }
    function rgb2hex(rgba) {
      var dig, hex = "#";
      for (var i = 0; i < 3; ++i) {
        dig = rgba[i];
        dig = dig.toString(16);
        hex += ("00" + dig).substr(dig.length);
      }
      return hex;
    }
    function rgbaStr(rgba) {
      return "rgba(" + rgba.join(",") + ")";
    }
  }
});

// node_modules/gl-cone3d/create_mesh.js
var require_create_mesh = __commonJS({
  "node_modules/gl-cone3d/create_mesh.js"(exports2, module2) {
    "use strict";
    var createShader = require_gl_shader();
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createTexture = require_texture();
    var multiply = require_multiply2();
    var invert = require_invert();
    var ndarray = require_ndarray();
    var colormap = require_colormap();
    var IDENTITY = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    function VectorMesh(gl2, texture, triShader, pickShader, trianglePositions, triangleVectors, triangleIds, triangleColors, triangleUVs, triangleVAO, traceType) {
      this.gl = gl2;
      this.pixelRatio = 1;
      this.cells = [];
      this.positions = [];
      this.intensity = [];
      this.texture = texture;
      this.dirty = true;
      this.triShader = triShader;
      this.pickShader = pickShader;
      this.trianglePositions = trianglePositions;
      this.triangleVectors = triangleVectors;
      this.triangleColors = triangleColors;
      this.triangleUVs = triangleUVs;
      this.triangleIds = triangleIds;
      this.triangleVAO = triangleVAO;
      this.triangleCount = 0;
      this.pickId = 1;
      this.bounds = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      this.clipBounds = [
        [-Infinity, -Infinity, -Infinity],
        [Infinity, Infinity, Infinity]
      ];
      this.lightPosition = [1e5, 1e5, 0];
      this.ambientLight = 0.8;
      this.diffuseLight = 0.8;
      this.specularLight = 2;
      this.roughness = 0.5;
      this.fresnel = 1.5;
      this.opacity = 1;
      this.traceType = traceType;
      this.tubeScale = 1;
      this.coneScale = 2;
      this.vectorScale = 1;
      this.coneOffset = 0.25;
      this._model = IDENTITY;
      this._view = IDENTITY;
      this._projection = IDENTITY;
      this._resolution = [1, 1];
    }
    var proto = VectorMesh.prototype;
    proto.isOpaque = function() {
      return this.opacity >= 1;
    };
    proto.isTransparent = function() {
      return this.opacity < 1;
    };
    proto.pickSlots = 1;
    proto.setPickBase = function(id) {
      this.pickId = id;
    };
    function genColormap(param) {
      var colors = colormap({
        colormap: param,
        nshades: 256,
        format: "rgba"
      });
      var result = new Uint8Array(256 * 4);
      for (var i = 0; i < 256; ++i) {
        var c = colors[i];
        for (var j = 0; j < 3; ++j) {
          result[4 * i + j] = c[j];
        }
        result[4 * i + 3] = c[3] * 255;
      }
      return ndarray(result, [256, 256, 4], [4, 0, 1]);
    }
    function takeZComponent(array) {
      var n = array.length;
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = array[i][2];
      }
      return result;
    }
    proto.update = function(params) {
      params = params || {};
      var gl2 = this.gl;
      this.dirty = true;
      if ("lightPosition" in params) {
        this.lightPosition = params.lightPosition;
      }
      if ("opacity" in params) {
        this.opacity = params.opacity;
      }
      if ("ambient" in params) {
        this.ambientLight = params.ambient;
      }
      if ("diffuse" in params) {
        this.diffuseLight = params.diffuse;
      }
      if ("specular" in params) {
        this.specularLight = params.specular;
      }
      if ("roughness" in params) {
        this.roughness = params.roughness;
      }
      if ("fresnel" in params) {
        this.fresnel = params.fresnel;
      }
      if (params.tubeScale !== void 0) {
        this.tubeScale = params.tubeScale;
      }
      if (params.vectorScale !== void 0) {
        this.vectorScale = params.vectorScale;
      }
      if (params.coneScale !== void 0) {
        this.coneScale = params.coneScale;
      }
      if (params.coneOffset !== void 0) {
        this.coneOffset = params.coneOffset;
      }
      if (params.colormap) {
        this.texture.shape = [256, 256];
        this.texture.minFilter = gl2.LINEAR_MIPMAP_LINEAR;
        this.texture.magFilter = gl2.LINEAR;
        this.texture.setPixels(genColormap(params.colormap));
        this.texture.generateMipmap();
      }
      var cells = params.cells;
      var positions = params.positions;
      var vectors = params.vectors;
      if (!positions || !cells || !vectors) {
        return;
      }
      var tPos = [];
      var tVec = [];
      var tCol = [];
      var tUVs = [];
      var tIds = [];
      this.cells = cells;
      this.positions = positions;
      this.vectors = vectors;
      var meshColor = params.meshColor || [1, 1, 1, 1];
      var vertexIntensity = params.vertexIntensity;
      var intensityLo = Infinity;
      var intensityHi = -Infinity;
      if (vertexIntensity) {
        if (params.vertexIntensityBounds) {
          intensityLo = +params.vertexIntensityBounds[0];
          intensityHi = +params.vertexIntensityBounds[1];
        } else {
          for (var i = 0; i < vertexIntensity.length; ++i) {
            var f = vertexIntensity[i];
            intensityLo = Math.min(intensityLo, f);
            intensityHi = Math.max(intensityHi, f);
          }
        }
      } else {
        for (var i = 0; i < positions.length; ++i) {
          var f = positions[i][2];
          intensityLo = Math.min(intensityLo, f);
          intensityHi = Math.max(intensityHi, f);
        }
      }
      if (vertexIntensity) {
        this.intensity = vertexIntensity;
      } else {
        this.intensity = takeZComponent(positions);
      }
      this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      for (var i = 0; i < positions.length; ++i) {
        var p = positions[i];
        for (var j = 0; j < 3; ++j) {
          if (isNaN(p[j]) || !isFinite(p[j])) {
            continue;
          }
          this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);
          this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);
        }
      }
      var triangleCount = 0;
      fill_loop:
        for (var i = 0; i < cells.length; ++i) {
          var cell = cells[i];
          switch (cell.length) {
            case 3:
              for (var j = 0; j < 3; ++j) {
                var v = cell[j];
                var p = positions[v];
                for (var k = 0; k < 3; ++k) {
                  if (isNaN(p[k]) || !isFinite(p[k])) {
                    continue fill_loop;
                  }
                }
              }
              for (var j = 0; j < 3; ++j) {
                var v = cell[2 - j];
                var p = positions[v];
                tPos.push(p[0], p[1], p[2], p[3]);
                var w = vectors[v];
                tVec.push(w[0], w[1], w[2], w[3] || 0);
                var c = meshColor;
                if (c.length === 3) {
                  tCol.push(c[0], c[1], c[2], 1);
                } else {
                  tCol.push(c[0], c[1], c[2], c[3]);
                }
                var uv;
                if (vertexIntensity) {
                  uv = [
                    (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                } else {
                  uv = [
                    (p[2] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                }
                tUVs.push(uv[0], uv[1]);
                tIds.push(i);
              }
              triangleCount += 1;
              break;
            default:
              break;
          }
        }
      this.triangleCount = triangleCount;
      this.trianglePositions.update(tPos);
      this.triangleVectors.update(tVec);
      this.triangleColors.update(tCol);
      this.triangleUVs.update(tUVs);
      this.triangleIds.update(new Uint32Array(tIds));
    };
    proto.drawTransparent = proto.draw = function(params) {
      params = params || {};
      var gl2 = this.gl;
      var model = params.model || IDENTITY;
      var view = params.view || IDENTITY;
      var projection = params.projection || IDENTITY;
      var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];
      for (var i = 0; i < 3; ++i) {
        clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);
        clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);
      }
      var uniforms = {
        model,
        view,
        projection,
        inverseModel: IDENTITY.slice(),
        clipBounds,
        kambient: this.ambientLight,
        kdiffuse: this.diffuseLight,
        kspecular: this.specularLight,
        roughness: this.roughness,
        fresnel: this.fresnel,
        eyePosition: [0, 0, 0],
        lightPosition: [0, 0, 0],
        opacity: this.opacity,
        tubeScale: this.tubeScale,
        vectorScale: this.vectorScale,
        coneScale: this.coneScale,
        coneOffset: this.coneOffset,
        texture: 0
      };
      uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);
      gl2.disable(gl2.CULL_FACE);
      this.texture.bind(0);
      var invCameraMatrix = new Array(16);
      multiply(invCameraMatrix, uniforms.view, uniforms.model);
      multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);
      invert(invCameraMatrix, invCameraMatrix);
      for (var i = 0; i < 3; ++i) {
        uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];
      }
      var w = invCameraMatrix[15];
      for (var i = 0; i < 3; ++i) {
        w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];
      }
      for (var i = 0; i < 3; ++i) {
        var s = invCameraMatrix[12 + i];
        for (var j = 0; j < 3; ++j) {
          s += invCameraMatrix[4 * j + i] * this.lightPosition[j];
        }
        uniforms.lightPosition[i] = s / w;
      }
      if (this.triangleCount > 0) {
        var shader = this.triShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.triangleVAO.bind();
        gl2.drawArrays(gl2.TRIANGLES, 0, this.triangleCount * 3);
        this.triangleVAO.unbind();
      }
    };
    proto.drawPick = function(params) {
      params = params || {};
      var gl2 = this.gl;
      var model = params.model || IDENTITY;
      var view = params.view || IDENTITY;
      var projection = params.projection || IDENTITY;
      var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];
      for (var i = 0; i < 3; ++i) {
        clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);
        clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);
      }
      this._model = [].slice.call(model);
      this._view = [].slice.call(view);
      this._projection = [].slice.call(projection);
      this._resolution = [gl2.drawingBufferWidth, gl2.drawingBufferHeight];
      var uniforms = {
        model,
        view,
        projection,
        clipBounds,
        tubeScale: this.tubeScale,
        vectorScale: this.vectorScale,
        coneScale: this.coneScale,
        coneOffset: this.coneOffset,
        pickId: this.pickId / 255
      };
      var shader = this.pickShader;
      shader.bind();
      shader.uniforms = uniforms;
      if (this.triangleCount > 0) {
        this.triangleVAO.bind();
        gl2.drawArrays(gl2.TRIANGLES, 0, this.triangleCount * 3);
        this.triangleVAO.unbind();
      }
    };
    proto.pick = function(pickData) {
      if (!pickData) {
        return null;
      }
      if (pickData.id !== this.pickId) {
        return null;
      }
      var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];
      var cell = this.cells[cellId];
      var pos = this.positions[cell[1]].slice(0, 3);
      var result = {
        position: pos,
        dataCoordinate: pos,
        index: Math.floor(cell[1] / 48)
      };
      if (this.traceType === "cone") {
        result.index = Math.floor(cell[1] / 48);
      } else if (this.traceType === "streamtube") {
        result.intensity = this.intensity[cell[1]];
        result.velocity = this.vectors[cell[1]].slice(0, 3);
        result.divergence = this.vectors[cell[1]][3];
        result.index = cellId;
      }
      return result;
    };
    proto.dispose = function() {
      this.texture.dispose();
      this.triShader.dispose();
      this.pickShader.dispose();
      this.triangleVAO.dispose();
      this.trianglePositions.dispose();
      this.triangleVectors.dispose();
      this.triangleColors.dispose();
      this.triangleUVs.dispose();
      this.triangleIds.dispose();
    };
    function createMeshShader(gl2, shaders) {
      var shader = createShader(
        gl2,
        shaders.meshShader.vertex,
        shaders.meshShader.fragment,
        null,
        shaders.meshShader.attributes
      );
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 2;
      shader.attributes.uv.location = 3;
      shader.attributes.vector.location = 4;
      return shader;
    }
    function createPickShader(gl2, shaders) {
      var shader = createShader(
        gl2,
        shaders.pickShader.vertex,
        shaders.pickShader.fragment,
        null,
        shaders.pickShader.attributes
      );
      shader.attributes.position.location = 0;
      shader.attributes.id.location = 1;
      shader.attributes.vector.location = 4;
      return shader;
    }
    function createVectorMesh(gl2, params, opts) {
      var shaders = opts.shaders;
      if (arguments.length === 1) {
        params = gl2;
        gl2 = params.gl;
      }
      var triShader = createMeshShader(gl2, shaders);
      var pickShader = createPickShader(gl2, shaders);
      var meshTexture = createTexture(
        gl2,
        ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4])
      );
      meshTexture.generateMipmap();
      meshTexture.minFilter = gl2.LINEAR_MIPMAP_LINEAR;
      meshTexture.magFilter = gl2.LINEAR;
      var trianglePositions = createBuffer(gl2);
      var triangleVectors = createBuffer(gl2);
      var triangleColors = createBuffer(gl2);
      var triangleUVs = createBuffer(gl2);
      var triangleIds = createBuffer(gl2);
      var triangleVAO = createVAO(gl2, [
        {
          buffer: trianglePositions,
          type: gl2.FLOAT,
          size: 4
        },
        {
          buffer: triangleIds,
          type: gl2.UNSIGNED_BYTE,
          size: 4,
          normalized: true
        },
        {
          buffer: triangleColors,
          type: gl2.FLOAT,
          size: 4
        },
        {
          buffer: triangleUVs,
          type: gl2.FLOAT,
          size: 2
        },
        {
          buffer: triangleVectors,
          type: gl2.FLOAT,
          size: 4
        }
      ]);
      var mesh = new VectorMesh(
        gl2,
        meshTexture,
        triShader,
        pickShader,
        trianglePositions,
        triangleVectors,
        triangleIds,
        triangleColors,
        triangleUVs,
        triangleVAO,
        opts.traceType || "cone"
      );
      mesh.update(params);
      return mesh;
    }
    module2.exports = createVectorMesh;
  }
});

// node_modules/gl-cone3d/cone.js
var require_cone = __commonJS({
  "node_modules/gl-cone3d/cone.js"(exports2, module2) {
    "use strict";
    var vec3 = require_gl_vec3();
    module2.exports = function(vectorfield, bounds) {
      var positions = vectorfield.positions;
      var vectors = vectorfield.vectors;
      var geo = {
        positions: [],
        vertexIntensity: [],
        vertexIntensityBounds: vectorfield.vertexIntensityBounds,
        vectors: [],
        cells: [],
        coneOffset: vectorfield.coneOffset,
        colormap: vectorfield.colormap
      };
      if (vectorfield.positions.length === 0) {
        if (bounds) {
          bounds[0] = [0, 0, 0];
          bounds[1] = [0, 0, 0];
        }
        return geo;
      }
      var maxNorm = 0;
      var minX = Infinity, maxX = -Infinity;
      var minY = Infinity, maxY = -Infinity;
      var minZ = Infinity, maxZ = -Infinity;
      var p2 = null;
      var u2 = null;
      var positionVectors = [];
      var vectorScale = Infinity;
      var skipIt = false;
      var rawSizemodemode = vectorfield.coneSizemode === "raw";
      for (var i = 0; i < positions.length; i++) {
        var p = positions[i];
        minX = Math.min(p[0], minX);
        maxX = Math.max(p[0], maxX);
        minY = Math.min(p[1], minY);
        maxY = Math.max(p[1], maxY);
        minZ = Math.min(p[2], minZ);
        maxZ = Math.max(p[2], maxZ);
        var u = vectors[i];
        if (vec3.length(u) > maxNorm) {
          maxNorm = vec3.length(u);
        }
        if (i && !rawSizemodemode) {
          var q = 2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u));
          if (q) {
            vectorScale = Math.min(vectorScale, q);
            skipIt = false;
          } else {
            skipIt = true;
          }
        }
        if (!skipIt) {
          p2 = p;
          u2 = u;
        }
        positionVectors.push(u);
      }
      var minV = [minX, minY, minZ];
      var maxV = [maxX, maxY, maxZ];
      if (bounds) {
        bounds[0] = minV;
        bounds[1] = maxV;
      }
      if (maxNorm === 0) {
        maxNorm = 1;
      }
      var invertedMaxNorm = 1 / maxNorm;
      if (!isFinite(vectorScale)) {
        vectorScale = 1;
      }
      geo.vectorScale = vectorScale;
      var coneScale = vectorfield.coneSize || (rawSizemodemode ? 1 : 0.5);
      if (vectorfield.absoluteConeSize) {
        coneScale = vectorfield.absoluteConeSize * invertedMaxNorm;
      }
      geo.coneScale = coneScale;
      for (var i = 0, j = 0; i < positions.length; i++) {
        var p = positions[i];
        var x = p[0], y = p[1], z = p[2];
        var d = positionVectors[i];
        var intensity = vec3.length(d) * invertedMaxNorm;
        for (var k = 0, l = 8; k < l; k++) {
          geo.positions.push([x, y, z, j++]);
          geo.positions.push([x, y, z, j++]);
          geo.positions.push([x, y, z, j++]);
          geo.positions.push([x, y, z, j++]);
          geo.positions.push([x, y, z, j++]);
          geo.positions.push([x, y, z, j++]);
          geo.vectors.push(d);
          geo.vectors.push(d);
          geo.vectors.push(d);
          geo.vectors.push(d);
          geo.vectors.push(d);
          geo.vectors.push(d);
          geo.vertexIntensity.push(intensity, intensity, intensity);
          geo.vertexIntensity.push(intensity, intensity, intensity);
          var m = geo.positions.length;
          geo.cells.push([m - 6, m - 5, m - 4], [m - 3, m - 2, m - 1]);
        }
      }
      return geo;
    };
    var shaders = require_shaders();
    module2.exports.createMesh = require_create_mesh();
    module2.exports.createConeMesh = function(gl2, params) {
      return module2.exports.createMesh(gl2, params, {
        shaders,
        traceType: "cone"
      });
    };
  }
});

// node_modules/gl-error3d/shaders/index.js
var require_shaders2 = __commonJS({
  "node_modules/gl-error3d/shaders/index.js"(exports2, module2) {
    "use strict";
    var glslify = require_browser();
    var createShader = require_gl_shader();
    var vertSrc = glslify("./vertex.glsl");
    var fragSrc = glslify("./fragment.glsl");
    module2.exports = function(gl2) {
      return createShader(gl2, vertSrc, fragSrc, null, [
        { name: "position", type: "vec3" },
        { name: "color", type: "vec4" },
        { name: "offset", type: "vec3" }
      ]);
    };
  }
});

// node_modules/gl-error3d/errorbars.js
var require_errorbars = __commonJS({
  "node_modules/gl-error3d/errorbars.js"(exports2, module2) {
    "use strict";
    module2.exports = createErrorBars;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createShader = require_shaders2();
    var IDENTITY = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    function ErrorBars(gl2, buffer, vao, shader) {
      this.gl = gl2;
      this.shader = shader;
      this.buffer = buffer;
      this.vao = vao;
      this.pixelRatio = 1;
      this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
      this.lineWidth = [1, 1, 1];
      this.capSize = [10, 10, 10];
      this.lineCount = [0, 0, 0];
      this.lineOffset = [0, 0, 0];
      this.opacity = 1;
      this.hasAlpha = false;
    }
    var proto = ErrorBars.prototype;
    proto.isOpaque = function() {
      return !this.hasAlpha;
    };
    proto.isTransparent = function() {
      return this.hasAlpha;
    };
    proto.drawTransparent = proto.draw = function(cameraParams) {
      var gl2 = this.gl;
      var uniforms = this.shader.uniforms;
      this.shader.bind();
      var view = uniforms.view = cameraParams.view || IDENTITY;
      var projection = uniforms.projection = cameraParams.projection || IDENTITY;
      uniforms.model = cameraParams.model || IDENTITY;
      uniforms.clipBounds = this.clipBounds;
      uniforms.opacity = this.opacity;
      var cx = view[12];
      var cy = view[13];
      var cz = view[14];
      var cw = view[15];
      var isOrtho = cameraParams._ortho || false;
      var orthoFix = isOrtho ? 2 : 1;
      var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl2.drawingBufferHeight;
      this.vao.bind();
      for (var i = 0; i < 3; ++i) {
        gl2.lineWidth(this.lineWidth[i] * this.pixelRatio);
        uniforms.capSize = this.capSize[i] * pixelScaleF;
        if (this.lineCount[i]) {
          gl2.drawArrays(gl2.LINES, this.lineOffset[i], this.lineCount[i]);
        }
      }
      this.vao.unbind();
    };
    function updateBounds(bounds, point) {
      for (var i = 0; i < 3; ++i) {
        bounds[0][i] = Math.min(bounds[0][i], point[i]);
        bounds[1][i] = Math.max(bounds[1][i], point[i]);
      }
    }
    var FACE_TABLE = function() {
      var table = new Array(3);
      for (var d = 0; d < 3; ++d) {
        var row = [];
        for (var j = 1; j <= 2; ++j) {
          for (var s = -1; s <= 1; s += 2) {
            var u = (j + d) % 3;
            var y = [0, 0, 0];
            y[u] = s;
            row.push(y);
          }
        }
        table[d] = row;
      }
      return table;
    }();
    function emitFace(verts, x, c, d) {
      var offsets = FACE_TABLE[d];
      for (var i = 0; i < offsets.length; ++i) {
        var o = offsets[i];
        verts.push(
          x[0],
          x[1],
          x[2],
          c[0],
          c[1],
          c[2],
          c[3],
          o[0],
          o[1],
          o[2]
        );
      }
      return offsets.length;
    }
    proto.update = function(options) {
      options = options || {};
      if ("lineWidth" in options) {
        this.lineWidth = options.lineWidth;
        if (!Array.isArray(this.lineWidth)) {
          this.lineWidth = [this.lineWidth, this.lineWidth, this.lineWidth];
        }
      }
      if ("capSize" in options) {
        this.capSize = options.capSize;
        if (!Array.isArray(this.capSize)) {
          this.capSize = [this.capSize, this.capSize, this.capSize];
        }
      }
      this.hasAlpha = false;
      if ("opacity" in options) {
        this.opacity = +options.opacity;
        if (this.opacity < 1) {
          this.hasAlpha = true;
        }
      }
      var color = options.color || [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
      var position = options.position;
      var error = options.error;
      if (!Array.isArray(color[0])) {
        color = [color, color, color];
      }
      if (position && error) {
        var verts = [];
        var n = position.length;
        var vertexCount = 0;
        this.bounds = [
          [Infinity, Infinity, Infinity],
          [-Infinity, -Infinity, -Infinity]
        ];
        this.lineCount = [0, 0, 0];
        for (var j = 0; j < 3; ++j) {
          this.lineOffset[j] = vertexCount;
          i_loop:
            for (var i = 0; i < n; ++i) {
              var p = position[i];
              for (var k = 0; k < 3; ++k) {
                if (isNaN(p[k]) || !isFinite(p[k])) {
                  continue i_loop;
                }
              }
              var e = error[i];
              var c = color[j];
              if (Array.isArray(c[0])) {
                c = color[i];
              }
              if (c.length === 3) {
                c = [c[0], c[1], c[2], 1];
              } else if (c.length === 4) {
                c = [c[0], c[1], c[2], c[3]];
                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;
              }
              if (isNaN(e[0][j]) || isNaN(e[1][j])) {
                continue;
              }
              if (e[0][j] < 0) {
                var x = p.slice();
                x[j] += e[0][j];
                verts.push(
                  p[0],
                  p[1],
                  p[2],
                  c[0],
                  c[1],
                  c[2],
                  c[3],
                  0,
                  0,
                  0,
                  x[0],
                  x[1],
                  x[2],
                  c[0],
                  c[1],
                  c[2],
                  c[3],
                  0,
                  0,
                  0
                );
                updateBounds(this.bounds, x);
                vertexCount += 2 + emitFace(verts, x, c, j);
              }
              if (e[1][j] > 0) {
                var x = p.slice();
                x[j] += e[1][j];
                verts.push(
                  p[0],
                  p[1],
                  p[2],
                  c[0],
                  c[1],
                  c[2],
                  c[3],
                  0,
                  0,
                  0,
                  x[0],
                  x[1],
                  x[2],
                  c[0],
                  c[1],
                  c[2],
                  c[3],
                  0,
                  0,
                  0
                );
                updateBounds(this.bounds, x);
                vertexCount += 2 + emitFace(verts, x, c, j);
              }
            }
          this.lineCount[j] = vertexCount - this.lineOffset[j];
        }
        this.buffer.update(verts);
      }
    };
    proto.dispose = function() {
      this.shader.dispose();
      this.buffer.dispose();
      this.vao.dispose();
    };
    function createErrorBars(options) {
      var gl2 = options.gl;
      var buffer = createBuffer(gl2);
      var vao = createVAO(gl2, [
        {
          buffer,
          type: gl2.FLOAT,
          size: 3,
          offset: 0,
          stride: 40
        },
        {
          buffer,
          type: gl2.FLOAT,
          size: 4,
          offset: 12,
          stride: 40
        },
        {
          buffer,
          type: gl2.FLOAT,
          size: 3,
          offset: 28,
          stride: 40
        }
      ]);
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 1;
      shader.attributes.offset.location = 2;
      var result = new ErrorBars(gl2, buffer, vao, shader);
      result.update(options);
      return result;
    }
  }
});

// node_modules/binary-search-bounds/search-bounds.js
var require_search_bounds = __commonJS({
  "node_modules/binary-search-bounds/search-bounds.js"(exports2, module2) {
    "use strict";
    function ge(a, y, c, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p >= 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function gt(a, y, c, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p > 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function lt(a, y, c, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p < 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function le(a, y, c, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p <= 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function eq(a, y, c, l, h) {
      while (l <= h) {
        var m = l + h >>> 1, x = a[m];
        var p = c !== void 0 ? c(x, y) : x - y;
        if (p === 0) {
          return m;
        }
        if (p <= 0) {
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return -1;
    }
    function norm(a, y, c, l, h, f) {
      if (typeof c === "function") {
        return f(a, y, c, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0);
      }
      return f(a, y, void 0, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0);
    }
    module2.exports = {
      ge: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, ge);
      },
      gt: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, gt);
      },
      lt: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, lt);
      },
      le: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, le);
      },
      eq: function(a, y, c, l, h) {
        return norm(a, y, c, l, h, eq);
      }
    };
  }
});

// node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "node_modules/iota-array/iota.js"(exports2, module2) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module2.exports = iota;
  }
});

// node_modules/gl-heatmap2d/lib/shaders.js
var require_shaders3 = __commonJS({
  "node_modules/gl-heatmap2d/lib/shaders.js"(exports2, module2) {
    "use strict";
    var glslify = require_browser();
    module2.exports = {
      fragment: glslify("./shaders/fragment.glsl"),
      vertex: glslify("./shaders/vertex.glsl"),
      pickFragment: glslify("./shaders/pick-fragment.glsl"),
      pickVertex: glslify("./shaders/pick-vertex.glsl")
    };
  }
});

// node_modules/gl-heatmap2d/heatmap.js
var require_heatmap = __commonJS({
  "node_modules/gl-heatmap2d/heatmap.js"(exports2, module2) {
    "use strict";
    module2.exports = createHeatmap2D;
    var bsearch = require_search_bounds();
    var iota = require_iota();
    var pool = require_pool();
    var createShader = require_gl_shader();
    var createBuffer = require_buffer2();
    var shaders = require_shaders3();
    function GLHeatmap2D(plot, shader, pickShader, positionBuffer, weightBuffer, colorBuffer, idBuffer) {
      this.plot = plot;
      this.shader = shader;
      this.pickShader = pickShader;
      this.positionBuffer = positionBuffer;
      this.weightBuffer = weightBuffer;
      this.colorBuffer = colorBuffer;
      this.idBuffer = idBuffer;
      this.xData = [];
      this.yData = [];
      this.shape = [0, 0];
      this.bounds = [Infinity, Infinity, -Infinity, -Infinity];
      this.pickOffset = 0;
    }
    var proto = GLHeatmap2D.prototype;
    var WEIGHTS = [
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1
    ];
    proto.draw = /* @__PURE__ */ function() {
      var MATRIX = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      return function() {
        var plot = this.plot;
        var shader = this.shader;
        var bounds = this.bounds;
        var numVertices = this.numVertices;
        if (numVertices <= 0) {
          return;
        }
        var gl2 = plot.gl;
        var dataBox = plot.dataBox;
        var boundX = bounds[2] - bounds[0];
        var boundY = bounds[3] - bounds[1];
        var dataX = dataBox[2] - dataBox[0];
        var dataY = dataBox[3] - dataBox[1];
        MATRIX[0] = 2 * boundX / dataX;
        MATRIX[4] = 2 * boundY / dataY;
        MATRIX[6] = 2 * (bounds[0] - dataBox[0]) / dataX - 1;
        MATRIX[7] = 2 * (bounds[1] - dataBox[1]) / dataY - 1;
        shader.bind();
        var uniforms = shader.uniforms;
        uniforms.viewTransform = MATRIX;
        uniforms.shape = this.shape;
        var attributes = shader.attributes;
        this.positionBuffer.bind();
        attributes.position.pointer();
        this.weightBuffer.bind();
        attributes.weight.pointer(gl2.UNSIGNED_BYTE, false);
        this.colorBuffer.bind();
        attributes.color.pointer(gl2.UNSIGNED_BYTE, true);
        gl2.drawArrays(gl2.TRIANGLES, 0, numVertices);
      };
    }();
    proto.drawPick = /* @__PURE__ */ function() {
      var MATRIX = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      var PICK_VECTOR = [0, 0, 0, 0];
      return function(pickOffset) {
        var plot = this.plot;
        var shader = this.pickShader;
        var bounds = this.bounds;
        var numVertices = this.numVertices;
        if (numVertices <= 0) {
          return;
        }
        var gl2 = plot.gl;
        var dataBox = plot.dataBox;
        var boundX = bounds[2] - bounds[0];
        var boundY = bounds[3] - bounds[1];
        var dataX = dataBox[2] - dataBox[0];
        var dataY = dataBox[3] - dataBox[1];
        MATRIX[0] = 2 * boundX / dataX;
        MATRIX[4] = 2 * boundY / dataY;
        MATRIX[6] = 2 * (bounds[0] - dataBox[0]) / dataX - 1;
        MATRIX[7] = 2 * (bounds[1] - dataBox[1]) / dataY - 1;
        for (var i = 0; i < 4; ++i) {
          PICK_VECTOR[i] = pickOffset >> i * 8 & 255;
        }
        this.pickOffset = pickOffset;
        shader.bind();
        var uniforms = shader.uniforms;
        uniforms.viewTransform = MATRIX;
        uniforms.pickOffset = PICK_VECTOR;
        uniforms.shape = this.shape;
        var attributes = shader.attributes;
        this.positionBuffer.bind();
        attributes.position.pointer();
        this.weightBuffer.bind();
        attributes.weight.pointer(gl2.UNSIGNED_BYTE, false);
        this.idBuffer.bind();
        attributes.pickId.pointer(gl2.UNSIGNED_BYTE, false);
        gl2.drawArrays(gl2.TRIANGLES, 0, numVertices);
        return pickOffset + this.shape[0] * this.shape[1];
      };
    }();
    proto.pick = function(x, y, value) {
      var pickOffset = this.pickOffset;
      var pointCount = this.shape[0] * this.shape[1];
      if (value < pickOffset || value >= pickOffset + pointCount) {
        return null;
      }
      var pointId = value - pickOffset;
      var xData = this.xData;
      var yData = this.yData;
      return {
        object: this,
        pointId,
        dataCoord: [
          xData[pointId % this.shape[0]],
          yData[pointId / this.shape[0] | 0]
        ]
      };
    };
    proto.update = function(options) {
      options = options || {};
      var shape = options.shape || [0, 0];
      var x = options.x || iota(shape[0]);
      var y = options.y || iota(shape[1]);
      var z = options.z || new Float32Array(shape[0] * shape[1]);
      var isSmooth = options.zsmooth !== false;
      this.xData = x;
      this.yData = y;
      var colorLevels = options.colorLevels || [0];
      var colorValues = options.colorValues || [0, 0, 0, 1];
      var colorCount = colorLevels.length;
      var bounds = this.bounds;
      var lox, loy, hix, hiy;
      if (isSmooth) {
        lox = bounds[0] = x[0];
        loy = bounds[1] = y[0];
        hix = bounds[2] = x[x.length - 1];
        hiy = bounds[3] = y[y.length - 1];
      } else {
        lox = bounds[0] = x[0] + (x[1] - x[0]) / 2;
        loy = bounds[1] = y[0] + (y[1] - y[0]) / 2;
        hix = bounds[2] = x[x.length - 1] + (x[x.length - 1] - x[x.length - 2]) / 2;
        hiy = bounds[3] = y[y.length - 1] + (y[y.length - 1] - y[y.length - 2]) / 2;
      }
      var xs = 1 / (hix - lox);
      var ys = 1 / (hiy - loy);
      var numX = shape[0];
      var numY = shape[1];
      this.shape = [numX, numY];
      var numVerts = (isSmooth ? (numX - 1) * (numY - 1) : numX * numY) * (WEIGHTS.length >>> 1);
      this.numVertices = numVerts;
      var colors = pool.mallocUint8(numVerts * 4);
      var positions = pool.mallocFloat32(numVerts * 2);
      var weights = pool.mallocUint8(numVerts * 2);
      var ids = pool.mallocUint32(numVerts);
      var ptr = 0;
      var ni = isSmooth ? numX - 1 : numX;
      var nj = isSmooth ? numY - 1 : numY;
      for (var j = 0; j < nj; ++j) {
        var yc0, yc1;
        if (isSmooth) {
          yc0 = ys * (y[j] - loy);
          yc1 = ys * (y[j + 1] - loy);
        } else {
          yc0 = j < numY - 1 ? ys * (y[j] - (y[j + 1] - y[j]) / 2 - loy) : ys * (y[j] - (y[j] - y[j - 1]) / 2 - loy);
          yc1 = j < numY - 1 ? ys * (y[j] + (y[j + 1] - y[j]) / 2 - loy) : ys * (y[j] + (y[j] - y[j - 1]) / 2 - loy);
        }
        for (var i = 0; i < ni; ++i) {
          var xc0, xc1;
          if (isSmooth) {
            xc0 = xs * (x[i] - lox);
            xc1 = xs * (x[i + 1] - lox);
          } else {
            xc0 = i < numX - 1 ? xs * (x[i] - (x[i + 1] - x[i]) / 2 - lox) : xs * (x[i] - (x[i] - x[i - 1]) / 2 - lox);
            xc1 = i < numX - 1 ? xs * (x[i] + (x[i + 1] - x[i]) / 2 - lox) : xs * (x[i] + (x[i] - x[i - 1]) / 2 - lox);
          }
          for (var dd = 0; dd < WEIGHTS.length; dd += 2) {
            var dx = WEIGHTS[dd];
            var dy = WEIGHTS[dd + 1];
            var offset = isSmooth ? (j + dy) * numX + (i + dx) : j * numX + i;
            var zc = z[offset];
            var colorIdx = bsearch.le(colorLevels, zc);
            var r, g, b, a;
            if (colorIdx < 0) {
              r = colorValues[0];
              g = colorValues[1];
              b = colorValues[2];
              a = colorValues[3];
            } else if (colorIdx === colorCount - 1) {
              r = colorValues[4 * colorCount - 4];
              g = colorValues[4 * colorCount - 3];
              b = colorValues[4 * colorCount - 2];
              a = colorValues[4 * colorCount - 1];
            } else {
              var t = (zc - colorLevels[colorIdx]) / (colorLevels[colorIdx + 1] - colorLevels[colorIdx]);
              var ti = 1 - t;
              var i0 = 4 * colorIdx;
              var i1 = 4 * (colorIdx + 1);
              r = ti * colorValues[i0] + t * colorValues[i1];
              g = ti * colorValues[i0 + 1] + t * colorValues[i1 + 1];
              b = ti * colorValues[i0 + 2] + t * colorValues[i1 + 2];
              a = ti * colorValues[i0 + 3] + t * colorValues[i1 + 3];
            }
            colors[4 * ptr] = 255 * r;
            colors[4 * ptr + 1] = 255 * g;
            colors[4 * ptr + 2] = 255 * b;
            colors[4 * ptr + 3] = 255 * a;
            positions[2 * ptr] = xc0 * 0.5 + xc1 * 0.5;
            positions[2 * ptr + 1] = yc0 * 0.5 + yc1 * 0.5;
            weights[2 * ptr] = dx;
            weights[2 * ptr + 1] = dy;
            ids[ptr] = j * numX + i;
            ptr += 1;
          }
        }
      }
      this.positionBuffer.update(positions);
      this.weightBuffer.update(weights);
      this.colorBuffer.update(colors);
      this.idBuffer.update(ids);
      pool.free(positions);
      pool.free(colors);
      pool.free(weights);
      pool.free(ids);
    };
    proto.dispose = function() {
      this.shader.dispose();
      this.pickShader.dispose();
      this.positionBuffer.dispose();
      this.weightBuffer.dispose();
      this.colorBuffer.dispose();
      this.idBuffer.dispose();
      this.plot.removeObject(this);
    };
    function createHeatmap2D(plot, options) {
      var gl2 = plot.gl;
      var shader = createShader(gl2, shaders.vertex, shaders.fragment);
      var pickShader = createShader(gl2, shaders.pickVertex, shaders.pickFragment);
      var positionBuffer = createBuffer(gl2);
      var weightBuffer = createBuffer(gl2);
      var colorBuffer = createBuffer(gl2);
      var idBuffer = createBuffer(gl2);
      var heatmap = new GLHeatmap2D(
        plot,
        shader,
        pickShader,
        positionBuffer,
        weightBuffer,
        colorBuffer,
        idBuffer
      );
      heatmap.update(options);
      plot.addObject(heatmap);
      return heatmap;
    }
  }
});

// node_modules/gl-line3d/lib/shaders.js
var require_shaders4 = __commonJS({
  "node_modules/gl-line3d/lib/shaders.js"(exports2) {
    var glslify = require_browser();
    var createShader = require_gl_shader();
    var vertSrc = glslify("../shaders/vertex.glsl");
    var forwardFrag = glslify("../shaders/fragment.glsl");
    var pickFrag = glslify("../shaders/pick.glsl");
    var ATTRIBUTES = [
      { name: "position", type: "vec3" },
      { name: "nextPosition", type: "vec3" },
      { name: "arcLength", type: "float" },
      { name: "lineWidth", type: "float" },
      { name: "color", type: "vec4" }
    ];
    exports2.createShader = function(gl2) {
      return createShader(gl2, vertSrc, forwardFrag, null, ATTRIBUTES);
    };
    exports2.createPickShader = function(gl2) {
      return createShader(gl2, vertSrc, pickFrag, null, ATTRIBUTES);
    };
  }
});

// node_modules/gl-line3d/lines.js
var require_lines = __commonJS({
  "node_modules/gl-line3d/lines.js"(exports2, module2) {
    "use strict";
    module2.exports = createLinePlot;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createTexture = require_texture();
    var UINT8_VIEW = new Uint8Array(4);
    var FLOAT_VIEW = new Float32Array(UINT8_VIEW.buffer);
    function unpackFloat(x, y, z, w) {
      UINT8_VIEW[0] = w;
      UINT8_VIEW[1] = z;
      UINT8_VIEW[2] = y;
      UINT8_VIEW[3] = x;
      return FLOAT_VIEW[0];
    }
    var bsearch = require_search_bounds();
    var ndarray = require_ndarray();
    var shaders = require_shaders4();
    var createShader = shaders.createShader;
    var createPickShader = shaders.createPickShader;
    var identity = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    function distance(a, b) {
      var s = 0;
      for (var i = 0; i < 3; ++i) {
        var d = a[i] - b[i];
        s += d * d;
      }
      return Math.sqrt(s);
    }
    function filterClipBounds(bounds) {
      var result = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];
      for (var i = 0; i < 3; ++i) {
        result[0][i] = Math.max(bounds[0][i], result[0][i]);
        result[1][i] = Math.min(bounds[1][i], result[1][i]);
      }
      return result;
    }
    function PickResult(tau, position, index, dataCoordinate) {
      this.arcLength = tau;
      this.position = position;
      this.index = index;
      this.dataCoordinate = dataCoordinate;
    }
    function LinePlot(gl2, shader, pickShader, buffer, vao, texture) {
      this.gl = gl2;
      this.shader = shader;
      this.pickShader = pickShader;
      this.buffer = buffer;
      this.vao = vao;
      this.clipBounds = [
        [-Infinity, -Infinity, -Infinity],
        [Infinity, Infinity, Infinity]
      ];
      this.points = [];
      this.arcLength = [];
      this.vertexCount = 0;
      this.bounds = [[0, 0, 0], [0, 0, 0]];
      this.pickId = 0;
      this.lineWidth = 1;
      this.texture = texture;
      this.dashScale = 1;
      this.opacity = 1;
      this.hasAlpha = false;
      this.dirty = true;
      this.pixelRatio = 1;
    }
    var proto = LinePlot.prototype;
    proto.isTransparent = function() {
      return this.hasAlpha;
    };
    proto.isOpaque = function() {
      return !this.hasAlpha;
    };
    proto.pickSlots = 1;
    proto.setPickBase = function(id) {
      this.pickId = id;
    };
    proto.drawTransparent = proto.draw = function(camera) {
      if (!this.vertexCount) return;
      var gl2 = this.gl;
      var shader = this.shader;
      var vao = this.vao;
      shader.bind();
      shader.uniforms = {
        model: camera.model || identity,
        view: camera.view || identity,
        projection: camera.projection || identity,
        clipBounds: filterClipBounds(this.clipBounds),
        dashTexture: this.texture.bind(),
        dashScale: this.dashScale / this.arcLength[this.arcLength.length - 1],
        opacity: this.opacity,
        screenShape: [gl2.drawingBufferWidth, gl2.drawingBufferHeight],
        pixelRatio: this.pixelRatio
      };
      vao.bind();
      vao.draw(gl2.TRIANGLE_STRIP, this.vertexCount);
      vao.unbind();
    };
    proto.drawPick = function(camera) {
      if (!this.vertexCount) return;
      var gl2 = this.gl;
      var shader = this.pickShader;
      var vao = this.vao;
      shader.bind();
      shader.uniforms = {
        model: camera.model || identity,
        view: camera.view || identity,
        projection: camera.projection || identity,
        pickId: this.pickId,
        clipBounds: filterClipBounds(this.clipBounds),
        screenShape: [gl2.drawingBufferWidth, gl2.drawingBufferHeight],
        pixelRatio: this.pixelRatio
      };
      vao.bind();
      vao.draw(gl2.TRIANGLE_STRIP, this.vertexCount);
      vao.unbind();
    };
    proto.update = function(options) {
      var i, j;
      this.dirty = true;
      var connectGaps = !!options.connectGaps;
      if ("dashScale" in options) {
        this.dashScale = options.dashScale;
      }
      this.hasAlpha = false;
      if ("opacity" in options) {
        this.opacity = +options.opacity;
        if (this.opacity < 1) {
          this.hasAlpha = true;
        }
      }
      var buffer = [];
      var arcLengthArray = [];
      var pointArray = [];
      var arcLength = 0;
      var vertexCount = 0;
      var bounds = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      var positions = options.position || options.positions;
      if (positions) {
        var colors = options.color || options.colors || [0, 0, 0, 1];
        var lineWidth = options.lineWidth || 1;
        var hadGap = false;
        fill_loop:
          for (i = 1; i < positions.length; ++i) {
            var a = positions[i - 1];
            var b = positions[i];
            arcLengthArray.push(arcLength);
            pointArray.push(a.slice());
            for (j = 0; j < 3; ++j) {
              if (isNaN(a[j]) || isNaN(b[j]) || !isFinite(a[j]) || !isFinite(b[j])) {
                if (!connectGaps && buffer.length > 0) {
                  for (var k = 0; k < 24; ++k) {
                    buffer.push(buffer[buffer.length - 12]);
                  }
                  vertexCount += 2;
                  hadGap = true;
                }
                continue fill_loop;
              }
              bounds[0][j] = Math.min(bounds[0][j], a[j], b[j]);
              bounds[1][j] = Math.max(bounds[1][j], a[j], b[j]);
            }
            var acolor, bcolor;
            if (Array.isArray(colors[0])) {
              acolor = colors.length > i - 1 ? colors[i - 1] : (
                // using index value
                colors.length > 0 ? colors[colors.length - 1] : (
                  // using last item
                  [0, 0, 0, 1]
                )
              );
              bcolor = colors.length > i ? colors[i] : (
                // using index value
                colors.length > 0 ? colors[colors.length - 1] : (
                  // using last item
                  [0, 0, 0, 1]
                )
              );
            } else {
              acolor = bcolor = colors;
            }
            if (acolor.length === 3) {
              acolor = [acolor[0], acolor[1], acolor[2], 1];
            }
            if (bcolor.length === 3) {
              bcolor = [bcolor[0], bcolor[1], bcolor[2], 1];
            }
            if (!this.hasAlpha && acolor[3] < 1) this.hasAlpha = true;
            var w0;
            if (Array.isArray(lineWidth)) {
              w0 = lineWidth.length > i - 1 ? lineWidth[i - 1] : (
                // using index value
                lineWidth.length > 0 ? lineWidth[lineWidth.length - 1] : (
                  // using last item
                  [0, 0, 0, 1]
                )
              );
            } else {
              w0 = lineWidth;
            }
            var t0 = arcLength;
            arcLength += distance(a, b);
            if (hadGap) {
              for (j = 0; j < 2; ++j) {
                buffer.push(
                  a[0],
                  a[1],
                  a[2],
                  b[0],
                  b[1],
                  b[2],
                  t0,
                  w0,
                  acolor[0],
                  acolor[1],
                  acolor[2],
                  acolor[3]
                );
              }
              vertexCount += 2;
              hadGap = false;
            }
            buffer.push(
              a[0],
              a[1],
              a[2],
              b[0],
              b[1],
              b[2],
              t0,
              w0,
              acolor[0],
              acolor[1],
              acolor[2],
              acolor[3],
              a[0],
              a[1],
              a[2],
              b[0],
              b[1],
              b[2],
              t0,
              -w0,
              acolor[0],
              acolor[1],
              acolor[2],
              acolor[3],
              b[0],
              b[1],
              b[2],
              a[0],
              a[1],
              a[2],
              arcLength,
              -w0,
              bcolor[0],
              bcolor[1],
              bcolor[2],
              bcolor[3],
              b[0],
              b[1],
              b[2],
              a[0],
              a[1],
              a[2],
              arcLength,
              w0,
              bcolor[0],
              bcolor[1],
              bcolor[2],
              bcolor[3]
            );
            vertexCount += 4;
          }
      }
      this.buffer.update(buffer);
      arcLengthArray.push(arcLength);
      pointArray.push(positions[positions.length - 1].slice());
      this.bounds = bounds;
      this.vertexCount = vertexCount;
      this.points = pointArray;
      this.arcLength = arcLengthArray;
      if ("dashes" in options) {
        var dashArray = options.dashes;
        var prefixSum = dashArray.slice();
        prefixSum.unshift(0);
        for (i = 1; i < prefixSum.length; ++i) {
          prefixSum[i] = prefixSum[i - 1] + prefixSum[i];
        }
        var dashTexture = ndarray(new Array(256 * 4), [256, 1, 4]);
        for (i = 0; i < 256; ++i) {
          for (j = 0; j < 4; ++j) {
            dashTexture.set(i, 0, j, 0);
          }
          if (bsearch.le(prefixSum, prefixSum[prefixSum.length - 1] * i / 255) & 1) {
            dashTexture.set(i, 0, 0, 0);
          } else {
            dashTexture.set(i, 0, 0, 255);
          }
        }
        this.texture.setPixels(dashTexture);
      }
    };
    proto.dispose = function() {
      this.shader.dispose();
      this.vao.dispose();
      this.buffer.dispose();
    };
    proto.pick = function(selection) {
      if (!selection) {
        return null;
      }
      if (selection.id !== this.pickId) {
        return null;
      }
      var tau = unpackFloat(
        selection.value[0],
        selection.value[1],
        selection.value[2],
        0
      );
      var index = bsearch.le(this.arcLength, tau);
      if (index < 0) {
        return null;
      }
      if (index === this.arcLength.length - 1) {
        return new PickResult(
          this.arcLength[this.arcLength.length - 1],
          this.points[this.points.length - 1].slice(),
          index
        );
      }
      var a = this.points[index];
      var b = this.points[Math.min(index + 1, this.points.length - 1)];
      var t = (tau - this.arcLength[index]) / (this.arcLength[index + 1] - this.arcLength[index]);
      var ti = 1 - t;
      var x = [0, 0, 0];
      for (var i = 0; i < 3; ++i) {
        x[i] = ti * a[i] + t * b[i];
      }
      var dataIndex = Math.min(t < 0.5 ? index : index + 1, this.points.length - 1);
      return new PickResult(
        tau,
        x,
        dataIndex,
        this.points[dataIndex]
      );
    };
    function createLinePlot(options) {
      var gl2 = options.gl || options.scene && options.scene.gl;
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      shader.attributes.nextPosition.location = 1;
      shader.attributes.arcLength.location = 2;
      shader.attributes.lineWidth.location = 3;
      shader.attributes.color.location = 4;
      var pickShader = createPickShader(gl2);
      pickShader.attributes.position.location = 0;
      pickShader.attributes.nextPosition.location = 1;
      pickShader.attributes.arcLength.location = 2;
      pickShader.attributes.lineWidth.location = 3;
      pickShader.attributes.color.location = 4;
      var buffer = createBuffer(gl2);
      var vao = createVAO(gl2, [
        {
          "buffer": buffer,
          "size": 3,
          "offset": 0,
          "stride": 48
        },
        {
          "buffer": buffer,
          "size": 3,
          "offset": 12,
          "stride": 48
        },
        {
          "buffer": buffer,
          "size": 1,
          "offset": 24,
          "stride": 48
        },
        {
          "buffer": buffer,
          "size": 1,
          "offset": 28,
          "stride": 48
        },
        {
          "buffer": buffer,
          "size": 4,
          "offset": 32,
          "stride": 48
        }
      ]);
      var defaultTexture = ndarray(new Array(256 * 4), [256, 1, 4]);
      for (var i = 0; i < 256 * 4; ++i) {
        defaultTexture.data[i] = 255;
      }
      var texture = createTexture(gl2, defaultTexture);
      texture.wrap = gl2.REPEAT;
      var linePlot = new LinePlot(gl2, shader, pickShader, buffer, vao, texture);
      linePlot.update(options);
      return linePlot;
    }
  }
});

// node_modules/normals/normals.js
var require_normals = __commonJS({
  "node_modules/normals/normals.js"(exports2) {
    var DEFAULT_NORMALS_EPSILON = 1e-6;
    var DEFAULT_FACE_EPSILON = 1e-6;
    exports2.vertexNormals = function(faces, positions, specifiedEpsilon) {
      var N = positions.length;
      var normals = new Array(N);
      var epsilon = specifiedEpsilon === void 0 ? DEFAULT_NORMALS_EPSILON : specifiedEpsilon;
      for (var i = 0; i < N; ++i) {
        normals[i] = [0, 0, 0];
      }
      for (var i = 0; i < faces.length; ++i) {
        var f = faces[i];
        var p = 0;
        var c = f[f.length - 1];
        var n = f[0];
        for (var j = 0; j < f.length; ++j) {
          p = c;
          c = n;
          n = f[(j + 1) % f.length];
          var v0 = positions[p];
          var v1 = positions[c];
          var v2 = positions[n];
          var d01 = new Array(3);
          var m01 = 0;
          var d21 = new Array(3);
          var m21 = 0;
          for (var k = 0; k < 3; ++k) {
            d01[k] = v0[k] - v1[k];
            m01 += d01[k] * d01[k];
            d21[k] = v2[k] - v1[k];
            m21 += d21[k] * d21[k];
          }
          if (m01 * m21 > epsilon) {
            var norm = normals[c];
            var w = 1 / Math.sqrt(m01 * m21);
            for (var k = 0; k < 3; ++k) {
              var u = (k + 1) % 3;
              var v = (k + 2) % 3;
              norm[k] += w * (d21[u] * d01[v] - d21[v] * d01[u]);
            }
          }
        }
      }
      for (var i = 0; i < N; ++i) {
        var norm = normals[i];
        var m = 0;
        for (var k = 0; k < 3; ++k) {
          m += norm[k] * norm[k];
        }
        if (m > epsilon) {
          var w = 1 / Math.sqrt(m);
          for (var k = 0; k < 3; ++k) {
            norm[k] *= w;
          }
        } else {
          for (var k = 0; k < 3; ++k) {
            norm[k] = 0;
          }
        }
      }
      return normals;
    };
    exports2.faceNormals = function(faces, positions, specifiedEpsilon) {
      var N = faces.length;
      var normals = new Array(N);
      var epsilon = specifiedEpsilon === void 0 ? DEFAULT_FACE_EPSILON : specifiedEpsilon;
      for (var i = 0; i < N; ++i) {
        var f = faces[i];
        var pos = new Array(3);
        for (var j = 0; j < 3; ++j) {
          pos[j] = positions[f[j]];
        }
        var d01 = new Array(3);
        var d21 = new Array(3);
        for (var j = 0; j < 3; ++j) {
          d01[j] = pos[1][j] - pos[0][j];
          d21[j] = pos[2][j] - pos[0][j];
        }
        var n = new Array(3);
        var l = 0;
        for (var j = 0; j < 3; ++j) {
          var u = (j + 1) % 3;
          var v = (j + 2) % 3;
          n[j] = d01[u] * d21[v] - d01[v] * d21[u];
          l += n[j] * n[j];
        }
        if (l > epsilon) {
          l = 1 / Math.sqrt(l);
        } else {
          l = 0;
        }
        for (var j = 0; j < 3; ++j) {
          n[j] *= l;
        }
        normals[i] = n;
      }
      return normals;
    };
  }
});

// node_modules/ndarray-sort/lib/compile_sort.js
var require_compile_sort = __commonJS({
  "node_modules/ndarray-sort/lib/compile_sort.js"(exports2, module2) {
    "use strict";
    var pool = require_pool();
    function getMallocFree(dtype) {
      switch (dtype) {
        case "uint32":
          return [pool.mallocUint32, pool.freeUint32];
        default:
          return null;
      }
    }
    var CACHED_insertionSort = {
      "uint32,1,0": function(malloc, free) {
        return function ndarrayInsertionSort1d0uint32(left, right, data, offset, s0, s1, n0, n1, d1, e1, f1) {
          var i, j, cptr, ptr = left * s0 + offset, i1, scratch = malloc(n1), dptr, sptr, a, b;
          for (i = left + 1; i <= right; ++i) {
            j = i;
            ptr += s0;
            cptr = ptr;
            dptr = 0;
            sptr = ptr;
            for (i1 = 0; i1 < n1; ++i1) {
              scratch[dptr++] = data[sptr];
              sptr += d1;
            }
            __g: while (j-- > left) {
              dptr = 0;
              sptr = cptr - s0;
              __l: for (i1 = 0; i1 < n1; ++i1) {
                a = data[sptr];
                b = scratch[dptr];
                if (a < b) {
                  break __g;
                }
                if (a > b) {
                  break __l;
                }
                sptr += e1;
                dptr += f1;
              }
              dptr = cptr;
              sptr = cptr - s0;
              for (i1 = 0; i1 < n1; ++i1) {
                data[dptr] = data[sptr];
                dptr += d1;
                sptr += d1;
              }
              cptr -= s0;
            }
            dptr = cptr;
            sptr = 0;
            for (i1 = 0; i1 < n1; ++i1) {
              data[dptr] = scratch[sptr++];
              dptr += d1;
            }
          }
          free(scratch);
        };
      }
    };
    function createInsertionSort(order, dtype) {
      var allocator = getMallocFree(dtype);
      var key = [dtype, order].join(",");
      var result = CACHED_insertionSort[key];
      if (allocator) {
        return result(allocator[0], allocator[1]);
      } else {
        return result();
      }
    }
    var CACHED_quickSort = {
      "uint32,1,0": function(insertionSort, malloc, free) {
        return function ndarrayQuickSort1d0uint32(left, right, data, offset, s0, s1, n0, n1, d1, e1, f1) {
          var sixth = (right - left + 1) / 6 | 0, index1 = left + sixth, index5 = right - sixth, index3 = left + right >> 1, index2 = index3 - sixth, index4 = index3 + sixth, el1 = index1, el2 = index2, el3 = index3, el4 = index4, el5 = index5, less = left + 1, great = right - 1, pivots_are_equal = true, tmp, tmp0, x, y, z, k, ptr0, ptr1, ptr2, comp_pivot1 = 0, comp_pivot2 = 0, comp = 0, i1, b_ptr0, b_ptr1, b_ptr2, b_ptr3, b_ptr4, b_ptr5, b_ptr6, b_ptr7, ptr3, ptr4, ptr5, ptr6, ptr7, pivot_ptr, ptr_shift, elementSize = n1, pivot1 = malloc(elementSize), pivot2 = malloc(elementSize);
          b_ptr0 = s0 * el1;
          b_ptr1 = s0 * el2;
          ptr_shift = offset;
          __l1: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el1;
              el1 = el2;
              el2 = tmp0;
              break __l1;
            }
            if (comp < 0) {
              break __l1;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el4;
          b_ptr1 = s0 * el5;
          ptr_shift = offset;
          __l2: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el4;
              el4 = el5;
              el5 = tmp0;
              break __l2;
            }
            if (comp < 0) {
              break __l2;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el1;
          b_ptr1 = s0 * el3;
          ptr_shift = offset;
          __l3: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el1;
              el1 = el3;
              el3 = tmp0;
              break __l3;
            }
            if (comp < 0) {
              break __l3;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el2;
          b_ptr1 = s0 * el3;
          ptr_shift = offset;
          __l4: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el2;
              el2 = el3;
              el3 = tmp0;
              break __l4;
            }
            if (comp < 0) {
              break __l4;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el1;
          b_ptr1 = s0 * el4;
          ptr_shift = offset;
          __l5: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el1;
              el1 = el4;
              el4 = tmp0;
              break __l5;
            }
            if (comp < 0) {
              break __l5;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el3;
          b_ptr1 = s0 * el4;
          ptr_shift = offset;
          __l6: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el3;
              el3 = el4;
              el4 = tmp0;
              break __l6;
            }
            if (comp < 0) {
              break __l6;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el2;
          b_ptr1 = s0 * el5;
          ptr_shift = offset;
          __l7: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el2;
              el2 = el5;
              el5 = tmp0;
              break __l7;
            }
            if (comp < 0) {
              break __l7;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el2;
          b_ptr1 = s0 * el3;
          ptr_shift = offset;
          __l8: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el2;
              el2 = el3;
              el3 = tmp0;
              break __l8;
            }
            if (comp < 0) {
              break __l8;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el4;
          b_ptr1 = s0 * el5;
          ptr_shift = offset;
          __l9: for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            comp = data[ptr0] - data[ptr1];
            if (comp > 0) {
              tmp0 = el4;
              el4 = el5;
              el5 = tmp0;
              break __l9;
            }
            if (comp < 0) {
              break __l9;
            }
            ptr_shift += e1;
          }
          b_ptr0 = s0 * el1;
          b_ptr1 = s0 * el2;
          b_ptr2 = s0 * el3;
          b_ptr3 = s0 * el4;
          b_ptr4 = s0 * el5;
          b_ptr5 = s0 * index1;
          b_ptr6 = s0 * index3;
          b_ptr7 = s0 * index5;
          pivot_ptr = 0;
          ptr_shift = offset;
          for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            ptr2 = b_ptr2 + ptr_shift;
            ptr3 = b_ptr3 + ptr_shift;
            ptr4 = b_ptr4 + ptr_shift;
            ptr5 = b_ptr5 + ptr_shift;
            ptr6 = b_ptr6 + ptr_shift;
            ptr7 = b_ptr7 + ptr_shift;
            pivot1[pivot_ptr] = data[ptr1];
            pivot2[pivot_ptr] = data[ptr3];
            pivots_are_equal = pivots_are_equal && pivot1[pivot_ptr] === pivot2[pivot_ptr];
            x = data[ptr0];
            y = data[ptr2];
            z = data[ptr4];
            data[ptr5] = x;
            data[ptr6] = y;
            data[ptr7] = z;
            ++pivot_ptr;
            ptr_shift += d1;
          }
          b_ptr0 = s0 * index2;
          b_ptr1 = s0 * left;
          ptr_shift = offset;
          for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            data[ptr0] = data[ptr1];
            ptr_shift += d1;
          }
          b_ptr0 = s0 * index4;
          b_ptr1 = s0 * right;
          ptr_shift = offset;
          for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            data[ptr0] = data[ptr1];
            ptr_shift += d1;
          }
          if (pivots_are_equal) {
            for (k = less; k <= great; ++k) {
              ptr0 = offset + k * s0;
              pivot_ptr = 0;
              __l10: for (i1 = 0; i1 < n1; ++i1) {
                comp = data[ptr0] - pivot1[pivot_ptr];
                if (comp !== 0) {
                  break __l10;
                }
                pivot_ptr += f1;
                ptr0 += e1;
              }
              if (comp === 0) {
                continue;
              }
              if (comp < 0) {
                if (k !== less) {
                  b_ptr0 = s0 * k;
                  b_ptr1 = s0 * less;
                  ptr_shift = offset;
                  for (i1 = 0; i1 < n1; ++i1) {
                    ptr0 = b_ptr0 + ptr_shift;
                    ptr1 = b_ptr1 + ptr_shift;
                    tmp = data[ptr0];
                    data[ptr0] = data[ptr1];
                    data[ptr1] = tmp;
                    ptr_shift += d1;
                  }
                }
                ++less;
              } else {
                while (true) {
                  ptr0 = offset + great * s0;
                  pivot_ptr = 0;
                  __l11: for (i1 = 0; i1 < n1; ++i1) {
                    comp = data[ptr0] - pivot1[pivot_ptr];
                    if (comp !== 0) {
                      break __l11;
                    }
                    pivot_ptr += f1;
                    ptr0 += e1;
                  }
                  if (comp > 0) {
                    great--;
                  } else if (comp < 0) {
                    b_ptr0 = s0 * k;
                    b_ptr1 = s0 * less;
                    b_ptr2 = s0 * great;
                    ptr_shift = offset;
                    for (i1 = 0; i1 < n1; ++i1) {
                      ptr0 = b_ptr0 + ptr_shift;
                      ptr1 = b_ptr1 + ptr_shift;
                      ptr2 = b_ptr2 + ptr_shift;
                      tmp = data[ptr0];
                      data[ptr0] = data[ptr1];
                      data[ptr1] = data[ptr2];
                      data[ptr2] = tmp;
                      ptr_shift += d1;
                    }
                    ++less;
                    --great;
                    break;
                  } else {
                    b_ptr0 = s0 * k;
                    b_ptr1 = s0 * great;
                    ptr_shift = offset;
                    for (i1 = 0; i1 < n1; ++i1) {
                      ptr0 = b_ptr0 + ptr_shift;
                      ptr1 = b_ptr1 + ptr_shift;
                      tmp = data[ptr0];
                      data[ptr0] = data[ptr1];
                      data[ptr1] = tmp;
                      ptr_shift += d1;
                    }
                    --great;
                    break;
                  }
                }
              }
            }
          } else {
            for (k = less; k <= great; ++k) {
              ptr0 = offset + k * s0;
              pivot_ptr = 0;
              __l12: for (i1 = 0; i1 < n1; ++i1) {
                comp_pivot1 = data[ptr0] - pivot1[pivot_ptr];
                if (comp_pivot1 !== 0) {
                  break __l12;
                }
                pivot_ptr += f1;
                ptr0 += e1;
              }
              if (comp_pivot1 < 0) {
                if (k !== less) {
                  b_ptr0 = s0 * k;
                  b_ptr1 = s0 * less;
                  ptr_shift = offset;
                  for (i1 = 0; i1 < n1; ++i1) {
                    ptr0 = b_ptr0 + ptr_shift;
                    ptr1 = b_ptr1 + ptr_shift;
                    tmp = data[ptr0];
                    data[ptr0] = data[ptr1];
                    data[ptr1] = tmp;
                    ptr_shift += d1;
                  }
                }
                ++less;
              } else {
                ptr0 = offset + k * s0;
                pivot_ptr = 0;
                __l13: for (i1 = 0; i1 < n1; ++i1) {
                  comp_pivot2 = data[ptr0] - pivot2[pivot_ptr];
                  if (comp_pivot2 !== 0) {
                    break __l13;
                  }
                  pivot_ptr += f1;
                  ptr0 += e1;
                }
                if (comp_pivot2 > 0) {
                  while (true) {
                    ptr0 = offset + great * s0;
                    pivot_ptr = 0;
                    __l14: for (i1 = 0; i1 < n1; ++i1) {
                      comp = data[ptr0] - pivot2[pivot_ptr];
                      if (comp !== 0) {
                        break __l14;
                      }
                      pivot_ptr += f1;
                      ptr0 += e1;
                    }
                    if (comp > 0) {
                      if (--great < k) {
                        break;
                      }
                      continue;
                    } else {
                      ptr0 = offset + great * s0;
                      pivot_ptr = 0;
                      __l15: for (i1 = 0; i1 < n1; ++i1) {
                        comp = data[ptr0] - pivot1[pivot_ptr];
                        if (comp !== 0) {
                          break __l15;
                        }
                        pivot_ptr += f1;
                        ptr0 += e1;
                      }
                      if (comp < 0) {
                        b_ptr0 = s0 * k;
                        b_ptr1 = s0 * less;
                        b_ptr2 = s0 * great;
                        ptr_shift = offset;
                        for (i1 = 0; i1 < n1; ++i1) {
                          ptr0 = b_ptr0 + ptr_shift;
                          ptr1 = b_ptr1 + ptr_shift;
                          ptr2 = b_ptr2 + ptr_shift;
                          tmp = data[ptr0];
                          data[ptr0] = data[ptr1];
                          data[ptr1] = data[ptr2];
                          data[ptr2] = tmp;
                          ptr_shift += d1;
                        }
                        ++less;
                        --great;
                      } else {
                        b_ptr0 = s0 * k;
                        b_ptr1 = s0 * great;
                        ptr_shift = offset;
                        for (i1 = 0; i1 < n1; ++i1) {
                          ptr0 = b_ptr0 + ptr_shift;
                          ptr1 = b_ptr1 + ptr_shift;
                          tmp = data[ptr0];
                          data[ptr0] = data[ptr1];
                          data[ptr1] = tmp;
                          ptr_shift += d1;
                        }
                        --great;
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
          b_ptr0 = s0 * left;
          b_ptr1 = s0 * (less - 1);
          pivot_ptr = 0;
          ptr_shift = offset;
          for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            data[ptr0] = data[ptr1];
            data[ptr1] = pivot1[pivot_ptr];
            ++pivot_ptr;
            ptr_shift += d1;
          }
          b_ptr0 = s0 * right;
          b_ptr1 = s0 * (great + 1);
          pivot_ptr = 0;
          ptr_shift = offset;
          for (i1 = 0; i1 < n1; ++i1) {
            ptr0 = b_ptr0 + ptr_shift;
            ptr1 = b_ptr1 + ptr_shift;
            data[ptr0] = data[ptr1];
            data[ptr1] = pivot2[pivot_ptr];
            ++pivot_ptr;
            ptr_shift += d1;
          }
          if (less - 2 - left <= 32) {
            insertionSort(left, less - 2, data, offset, s0, s1, n0, n1, d1, e1, f1);
          } else {
            ndarrayQuickSort1d0uint32(left, less - 2, data, offset, s0, s1, n0, n1, d1, e1, f1);
          }
          if (right - (great + 2) <= 32) {
            insertionSort(great + 2, right, data, offset, s0, s1, n0, n1, d1, e1, f1);
          } else {
            ndarrayQuickSort1d0uint32(great + 2, right, data, offset, s0, s1, n0, n1, d1, e1, f1);
          }
          if (pivots_are_equal) {
            free(pivot1);
            free(pivot2);
            return;
          }
          if (less < index1 && great > index5) {
            __l16: while (true) {
              ptr0 = offset + less * s0;
              pivot_ptr = 0;
              ptr_shift = offset;
              for (i1 = 0; i1 < n1; ++i1) {
                if (data[ptr0] !== pivot1[pivot_ptr]) {
                  break __l16;
                }
                ++pivot_ptr;
                ptr0 += d1;
              }
              ++less;
            }
            __l17: while (true) {
              ptr0 = offset + great * s0;
              pivot_ptr = 0;
              ptr_shift = offset;
              for (i1 = 0; i1 < n1; ++i1) {
                if (data[ptr0] !== pivot2[pivot_ptr]) {
                  break __l17;
                }
                ++pivot_ptr;
                ptr0 += d1;
              }
              --great;
            }
            for (k = less; k <= great; ++k) {
              ptr0 = offset + k * s0;
              pivot_ptr = 0;
              __l18: for (i1 = 0; i1 < n1; ++i1) {
                comp_pivot1 = data[ptr0] - pivot1[pivot_ptr];
                if (comp_pivot1 !== 0) {
                  break __l18;
                }
                pivot_ptr += f1;
                ptr0 += e1;
              }
              if (comp_pivot1 === 0) {
                if (k !== less) {
                  b_ptr0 = s0 * k;
                  b_ptr1 = s0 * less;
                  ptr_shift = offset;
                  for (i1 = 0; i1 < n1; ++i1) {
                    ptr0 = b_ptr0 + ptr_shift;
                    ptr1 = b_ptr1 + ptr_shift;
                    tmp = data[ptr0];
                    data[ptr0] = data[ptr1];
                    data[ptr1] = tmp;
                    ptr_shift += d1;
                  }
                }
                ++less;
              } else {
                ptr0 = offset + k * s0;
                pivot_ptr = 0;
                __l19: for (i1 = 0; i1 < n1; ++i1) {
                  comp_pivot2 = data[ptr0] - pivot2[pivot_ptr];
                  if (comp_pivot2 !== 0) {
                    break __l19;
                  }
                  pivot_ptr += f1;
                  ptr0 += e1;
                }
                if (comp_pivot2 === 0) {
                  while (true) {
                    ptr0 = offset + great * s0;
                    pivot_ptr = 0;
                    __l20: for (i1 = 0; i1 < n1; ++i1) {
                      comp = data[ptr0] - pivot2[pivot_ptr];
                      if (comp !== 0) {
                        break __l20;
                      }
                      pivot_ptr += f1;
                      ptr0 += e1;
                    }
                    if (comp === 0) {
                      if (--great < k) {
                        break;
                      }
                      continue;
                    } else {
                      ptr0 = offset + great * s0;
                      pivot_ptr = 0;
                      __l21: for (i1 = 0; i1 < n1; ++i1) {
                        comp = data[ptr0] - pivot1[pivot_ptr];
                        if (comp !== 0) {
                          break __l21;
                        }
                        pivot_ptr += f1;
                        ptr0 += e1;
                      }
                      if (comp < 0) {
                        b_ptr0 = s0 * k;
                        b_ptr1 = s0 * less;
                        b_ptr2 = s0 * great;
                        ptr_shift = offset;
                        for (i1 = 0; i1 < n1; ++i1) {
                          ptr0 = b_ptr0 + ptr_shift;
                          ptr1 = b_ptr1 + ptr_shift;
                          ptr2 = b_ptr2 + ptr_shift;
                          tmp = data[ptr0];
                          data[ptr0] = data[ptr1];
                          data[ptr1] = data[ptr2];
                          data[ptr2] = tmp;
                          ptr_shift += d1;
                        }
                        ++less;
                        --great;
                      } else {
                        b_ptr0 = s0 * k;
                        b_ptr1 = s0 * great;
                        ptr_shift = offset;
                        for (i1 = 0; i1 < n1; ++i1) {
                          ptr0 = b_ptr0 + ptr_shift;
                          ptr1 = b_ptr1 + ptr_shift;
                          tmp = data[ptr0];
                          data[ptr0] = data[ptr1];
                          data[ptr1] = tmp;
                          ptr_shift += d1;
                        }
                        --great;
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
          free(pivot1);
          free(pivot2);
          if (great - less <= 32) {
            insertionSort(less, great, data, offset, s0, s1, n0, n1, d1, e1, f1);
          } else {
            ndarrayQuickSort1d0uint32(less, great, data, offset, s0, s1, n0, n1, d1, e1, f1);
          }
        };
      }
    };
    function createQuickSort(order, dtype, insertionSort) {
      var allocator = getMallocFree(dtype);
      var key = [dtype, order].join(",");
      var result = CACHED_quickSort[key];
      if (order.length > 1 && allocator) {
        return result(insertionSort, allocator[0], allocator[1]);
      } else {
        return result(insertionSort);
      }
    }
    var CACHED_sort = {
      "uint32,1,0": function(insertionSort, quickSort) {
        return function(array) {
          var data = array.data, offset = array.offset | 0, shape = array.shape, stride = array.stride, s0 = stride[0] | 0, n0 = shape[0] | 0, s1 = stride[1] | 0, n1 = shape[1] | 0, d1 = s1, e1 = s1, f1 = 1;
          if (n0 <= 32) {
            insertionSort(0, n0 - 1, data, offset, s0, s1, n0, n1, d1, e1, f1);
          } else {
            quickSort(0, n0 - 1, data, offset, s0, s1, n0, n1, d1, e1, f1);
          }
        };
      }
    };
    function compileSort(order, dtype) {
      var key = [dtype, order].join(",");
      var result = CACHED_sort[key];
      var insertionSort = createInsertionSort(order, dtype);
      var quickSort = createQuickSort(order, dtype, insertionSort);
      return result(insertionSort, quickSort);
    }
    module2.exports = compileSort;
  }
});

// node_modules/ndarray-sort/sort.js
var require_sort = __commonJS({
  "node_modules/ndarray-sort/sort.js"(exports2, module2) {
    "use strict";
    var compile = require_compile_sort();
    var CACHE = {};
    function sort(array) {
      var order = array.order;
      var dtype = array.dtype;
      var typeSig = [order, dtype];
      var typeName = typeSig.join(":");
      var compiled = CACHE[typeName];
      if (!compiled) {
        CACHE[typeName] = compiled = compile(order, dtype);
      }
      compiled(array);
      return array;
    }
    module2.exports = sort;
  }
});

// node_modules/simplicial-complex-contour/lib/codegen.js
var require_codegen = __commonJS({
  "node_modules/simplicial-complex-contour/lib/codegen.js"(exports2, module2) {
    "use strict";
    module2.exports = getPolygonizer;
    var allFns = [
      function cellPolygonizer_0() {
        function B(C, E, i, j) {
          var a = Math.min(i, j) | 0, b = Math.max(i, j) | 0, l = C[2 * a], h = C[2 * a + 1];
          while (l < h) {
            var m = l + h >> 1, v = E[2 * m + 1];
            if (v === b) {
              return m;
            }
            if (b < v) {
              h = m;
            } else {
              l = m + 1;
            }
          }
          return l;
        }
        function getContour0d(F, E, C, S) {
          var n = F.length, R = [];
          for (var i = 0; i < n; ++i) {
            var c = F[i], l = c.length;
          }
          return R;
        }
        return getContour0d;
      },
      function cellPolygonizer_1() {
        function B(C, E, i, j) {
          var a = Math.min(i, j) | 0, b = Math.max(i, j) | 0, l = C[2 * a], h = C[2 * a + 1];
          while (l < h) {
            var m = l + h >> 1, v = E[2 * m + 1];
            if (v === b) {
              return m;
            }
            if (b < v) {
              h = m;
            } else {
              l = m + 1;
            }
          }
          return l;
        }
        function getContour1d(F, E, C, S) {
          var n = F.length, R = [];
          for (var i = 0; i < n; ++i) {
            var c = F[i], l = c.length;
            if (l === 2) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1);
              if (M === 0 || M === 3) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[1])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[0])]);
                  break;
                case 3:
                  break;
              }
            }
          }
          return R;
        }
        return getContour1d;
      },
      function cellPolygonizer_2() {
        function B(C, E, i, j) {
          var a = Math.min(i, j) | 0, b = Math.max(i, j) | 0, l = C[2 * a], h = C[2 * a + 1];
          while (l < h) {
            var m = l + h >> 1, v = E[2 * m + 1];
            if (v === b) {
              return m;
            }
            if (b < v) {
              h = m;
            } else {
              l = m + 1;
            }
          }
          return l;
        }
        function getContour2d(F, E, C, S) {
          var n = F.length, R = [];
          for (var i = 0; i < n; ++i) {
            var c = F[i], l = c.length;
            if (l === 3) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2);
              if (M === 0 || M === 7) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[2]), B(C, E, c[0], c[1])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[0]), B(C, E, c[1], c[2])]);
                  break;
                case 3:
                  R.push([B(C, E, c[0], c[2]), B(C, E, c[1], c[2])]);
                  break;
                case 4:
                  R.push([B(C, E, c[2], c[1]), B(C, E, c[2], c[0])]);
                  break;
                case 5:
                  R.push([B(C, E, c[2], c[1]), B(C, E, c[0], c[1])]);
                  break;
                case 6:
                  R.push([B(C, E, c[1], c[0]), B(C, E, c[2], c[0])]);
                  break;
                case 7:
                  break;
              }
            } else if (l === 2) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1);
              if (M === 0 || M === 3) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[1])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[0])]);
                  break;
                case 3:
                  break;
              }
            }
          }
          return R;
        }
        return getContour2d;
      },
      function cellPolygonizer_3() {
        function B(C, E, i, j) {
          var a = Math.min(i, j) | 0, b = Math.max(i, j) | 0, l = C[2 * a], h = C[2 * a + 1];
          while (l < h) {
            var m = l + h >> 1, v = E[2 * m + 1];
            if (v === b) {
              return m;
            }
            if (b < v) {
              h = m;
            } else {
              l = m + 1;
            }
          }
          return l;
        }
        function getContour3d(F, E, C, S) {
          var n = F.length, R = [];
          for (var i = 0; i < n; ++i) {
            var c = F[i], l = c.length;
            if (l === 4) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2) + (S[c[3]] << 3);
              if (M === 0 || M === 15) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[1]), B(C, E, c[0], c[2]), B(C, E, c[0], c[3])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[2]), B(C, E, c[1], c[0]), B(C, E, c[1], c[3])]);
                  break;
                case 3:
                  R.push([B(C, E, c[1], c[2]), B(C, E, c[0], c[2]), B(C, E, c[0], c[3])], [B(C, E, c[1], c[3]), B(C, E, c[1], c[2]), B(C, E, c[0], c[3])]);
                  break;
                case 4:
                  R.push([B(C, E, c[2], c[0]), B(C, E, c[2], c[1]), B(C, E, c[2], c[3])]);
                  break;
                case 5:
                  R.push([B(C, E, c[0], c[1]), B(C, E, c[2], c[1]), B(C, E, c[0], c[3])], [B(C, E, c[2], c[1]), B(C, E, c[2], c[3]), B(C, E, c[0], c[3])]);
                  break;
                case 6:
                  R.push([B(C, E, c[2], c[0]), B(C, E, c[1], c[0]), B(C, E, c[1], c[3])], [B(C, E, c[2], c[3]), B(C, E, c[2], c[0]), B(C, E, c[1], c[3])]);
                  break;
                case 7:
                  R.push([B(C, E, c[0], c[3]), B(C, E, c[1], c[3]), B(C, E, c[2], c[3])]);
                  break;
                case 8:
                  R.push([B(C, E, c[3], c[1]), B(C, E, c[3], c[0]), B(C, E, c[3], c[2])]);
                  break;
                case 9:
                  R.push([B(C, E, c[3], c[1]), B(C, E, c[0], c[1]), B(C, E, c[0], c[2])], [B(C, E, c[3], c[2]), B(C, E, c[3], c[1]), B(C, E, c[0], c[2])]);
                  break;
                case 10:
                  R.push([B(C, E, c[1], c[0]), B(C, E, c[3], c[0]), B(C, E, c[1], c[2])], [B(C, E, c[3], c[0]), B(C, E, c[3], c[2]), B(C, E, c[1], c[2])]);
                  break;
                case 11:
                  R.push([B(C, E, c[1], c[2]), B(C, E, c[0], c[2]), B(C, E, c[3], c[2])]);
                  break;
                case 12:
                  R.push([B(C, E, c[3], c[0]), B(C, E, c[2], c[0]), B(C, E, c[2], c[1])], [B(C, E, c[3], c[1]), B(C, E, c[3], c[0]), B(C, E, c[2], c[1])]);
                  break;
                case 13:
                  R.push([B(C, E, c[0], c[1]), B(C, E, c[2], c[1]), B(C, E, c[3], c[1])]);
                  break;
                case 14:
                  R.push([B(C, E, c[2], c[0]), B(C, E, c[1], c[0]), B(C, E, c[3], c[0])]);
                  break;
                case 15:
                  break;
              }
            } else if (l === 3) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2);
              if (M === 0 || M === 7) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[2]), B(C, E, c[0], c[1])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[0]), B(C, E, c[1], c[2])]);
                  break;
                case 3:
                  R.push([B(C, E, c[0], c[2]), B(C, E, c[1], c[2])]);
                  break;
                case 4:
                  R.push([B(C, E, c[2], c[1]), B(C, E, c[2], c[0])]);
                  break;
                case 5:
                  R.push([B(C, E, c[2], c[1]), B(C, E, c[0], c[1])]);
                  break;
                case 6:
                  R.push([B(C, E, c[1], c[0]), B(C, E, c[2], c[0])]);
                  break;
                case 7:
                  break;
              }
            } else if (l === 2) {
              var M = (S[c[0]] << 0) + (S[c[1]] << 1);
              if (M === 0 || M === 3) {
                continue;
              }
              switch (M) {
                case 0:
                  break;
                case 1:
                  R.push([B(C, E, c[0], c[1])]);
                  break;
                case 2:
                  R.push([B(C, E, c[1], c[0])]);
                  break;
                case 3:
                  break;
              }
            }
          }
          return R;
        }
        return getContour3d;
      }
    ];
    function getPolygonizer(d) {
      return allFns[d]();
    }
  }
});

// node_modules/simplicial-complex-contour/contour.js
var require_contour = __commonJS({
  "node_modules/simplicial-complex-contour/contour.js"(exports2, module2) {
    "use strict";
    module2.exports = extractContour;
    var ndarray = require_ndarray();
    var pool = require_pool();
    var ndsort = require_sort();
    var contourAlgorithm = require_codegen();
    function getDimension(cells) {
      var numCells = cells.length;
      var d = 0;
      for (var i = 0; i < numCells; ++i) {
        d = Math.max(d, cells[i].length) | 0;
      }
      return d - 1;
    }
    function getSigns(values, level) {
      var numVerts = values.length;
      var vertexSigns = pool.mallocUint8(numVerts);
      for (var i = 0; i < numVerts; ++i) {
        vertexSigns[i] = values[i] < level | 0;
      }
      return vertexSigns;
    }
    function getEdges(cells, d) {
      var numCells = cells.length;
      var maxEdges = d * (d + 1) / 2 * numCells | 0;
      var edges = pool.mallocUint32(maxEdges * 2);
      var ePtr = 0;
      for (var i = 0; i < numCells; ++i) {
        var c = cells[i];
        var d = c.length;
        for (var j = 0; j < d; ++j) {
          for (var k = 0; k < j; ++k) {
            var a = c[k];
            var b = c[j];
            edges[ePtr++] = Math.min(a, b) | 0;
            edges[ePtr++] = Math.max(a, b) | 0;
          }
        }
      }
      var nedges = ePtr / 2 | 0;
      ndsort(ndarray(edges, [nedges, 2]));
      var ptr = 2;
      for (var i = 2; i < ePtr; i += 2) {
        if (edges[i - 2] === edges[i] && edges[i - 1] === edges[i + 1]) {
          continue;
        }
        edges[ptr++] = edges[i];
        edges[ptr++] = edges[i + 1];
      }
      return ndarray(edges, [ptr / 2 | 0, 2]);
    }
    function getCrossingWeights(edges, values, signs, level) {
      var edata = edges.data;
      var numEdges = edges.shape[0];
      var weights = pool.mallocDouble(numEdges);
      var ptr = 0;
      for (var i = 0; i < numEdges; ++i) {
        var a = edata[2 * i];
        var b = edata[2 * i + 1];
        if (signs[a] === signs[b]) {
          continue;
        }
        var va = values[a];
        var vb = values[b];
        edata[2 * ptr] = a;
        edata[2 * ptr + 1] = b;
        weights[ptr++] = (vb - level) / (vb - va);
      }
      edges.shape[0] = ptr;
      return ndarray(weights, [ptr]);
    }
    function getCascade(edges, numVerts) {
      var result = pool.mallocInt32(numVerts * 2);
      var numEdges = edges.shape[0];
      var edata = edges.data;
      result[0] = 0;
      var lastV = 0;
      for (var i = 0; i < numEdges; ++i) {
        var a = edata[2 * i];
        if (a !== lastV) {
          result[2 * lastV + 1] = i;
          while (++lastV < a) {
            result[2 * lastV] = i;
            result[2 * lastV + 1] = i;
          }
          result[2 * lastV] = i;
        }
      }
      result[2 * lastV + 1] = numEdges;
      while (++lastV < numVerts) {
        result[2 * lastV] = result[2 * lastV + 1] = numEdges;
      }
      return result;
    }
    function unpackEdges(edges) {
      var ne = edges.shape[0] | 0;
      var edata = edges.data;
      var result = new Array(ne);
      for (var i = 0; i < ne; ++i) {
        result[i] = [edata[2 * i], edata[2 * i + 1]];
      }
      return result;
    }
    function extractContour(cells, values, level, d) {
      level = level || 0;
      if (typeof d === "undefined") {
        d = getDimension(cells);
      }
      var numCells = cells.length;
      if (numCells === 0 || d < 1) {
        return {
          cells: [],
          vertexIds: [],
          vertexWeights: []
        };
      }
      var vertexSigns = getSigns(values, +level);
      var edges = getEdges(cells, d);
      var weights = getCrossingWeights(edges, values, vertexSigns, +level);
      var vcascade = getCascade(edges, values.length | 0);
      var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns);
      var uedges = unpackEdges(edges);
      var uweights = [].slice.call(weights.data, 0, weights.shape[0]);
      pool.free(vertexSigns);
      pool.free(edges.data);
      pool.free(weights.data);
      pool.free(vcascade);
      return {
        cells: faces,
        vertexIds: uedges,
        vertexWeights: uweights
      };
    }
  }
});

// node_modules/gl-mesh3d/lib/shaders.js
var require_shaders5 = __commonJS({
  "node_modules/gl-mesh3d/lib/shaders.js"(exports2) {
    var glslify = require_browser();
    var triVertSrc = glslify("./triangle-vertex.glsl");
    var triFragSrc = glslify("./triangle-fragment.glsl");
    var edgeVertSrc = glslify("./edge-vertex.glsl");
    var edgeFragSrc = glslify("./edge-fragment.glsl");
    var pointVertSrc = glslify("./point-vertex.glsl");
    var pointFragSrc = glslify("./point-fragment.glsl");
    var pickVertSrc = glslify("./pick-vertex.glsl");
    var pickFragSrc = glslify("./pick-fragment.glsl");
    var pickPointVertSrc = glslify("./pick-point-vertex.glsl");
    var contourVertSrc = glslify("./contour-vertex.glsl");
    var contourFragSrc = glslify("./contour-fragment.glsl");
    exports2.meshShader = {
      vertex: triVertSrc,
      fragment: triFragSrc,
      attributes: [
        { name: "position", type: "vec3" },
        { name: "normal", type: "vec3" },
        { name: "color", type: "vec4" },
        { name: "uv", type: "vec2" }
      ]
    };
    exports2.wireShader = {
      vertex: edgeVertSrc,
      fragment: edgeFragSrc,
      attributes: [
        { name: "position", type: "vec3" },
        { name: "color", type: "vec4" },
        { name: "uv", type: "vec2" }
      ]
    };
    exports2.pointShader = {
      vertex: pointVertSrc,
      fragment: pointFragSrc,
      attributes: [
        { name: "position", type: "vec3" },
        { name: "color", type: "vec4" },
        { name: "uv", type: "vec2" },
        { name: "pointSize", type: "float" }
      ]
    };
    exports2.pickShader = {
      vertex: pickVertSrc,
      fragment: pickFragSrc,
      attributes: [
        { name: "position", type: "vec3" },
        { name: "id", type: "vec4" }
      ]
    };
    exports2.pointPickShader = {
      vertex: pickPointVertSrc,
      fragment: pickFragSrc,
      attributes: [
        { name: "position", type: "vec3" },
        { name: "pointSize", type: "float" },
        { name: "id", type: "vec4" }
      ]
    };
    exports2.contourShader = {
      vertex: contourVertSrc,
      fragment: contourFragSrc,
      attributes: [
        { name: "position", type: "vec3" }
      ]
    };
  }
});

// node_modules/barycentric/barycentric.js
var require_barycentric = __commonJS({
  "node_modules/barycentric/barycentric.js"(exports2, module2) {
    "use strict";
    module2.exports = barycentric;
    var solve = require_linsolve();
    function reduce(x) {
      var r = 0;
      for (var i = 0; i < x.length; ++i) {
        r += x[i];
      }
      return r;
    }
    function barycentric(simplex, point) {
      var d = point.length;
      var A = new Array(d + 1);
      for (var i = 0; i < d; ++i) {
        var row = new Array(d + 1);
        for (var j = 0; j <= d; ++j) {
          row[j] = simplex[j][i];
        }
        A[i] = row;
      }
      A[d] = new Array(d + 1);
      for (var i = 0; i <= d; ++i) {
        A[d][i] = 1;
      }
      var b = new Array(d + 1);
      for (var i = 0; i < d; ++i) {
        b[i] = point[i];
      }
      b[d] = 1;
      var x = solve(A, b);
      var w = reduce(x[d + 1]);
      if (w === 0) {
        w = 1;
      }
      var y = new Array(d + 1);
      for (var i = 0; i <= d; ++i) {
        y[i] = reduce(x[i]) / w;
      }
      return y;
    }
  }
});

// node_modules/polytope-closest-point/lib/closest_point_2d.js
var require_closest_point_2d = __commonJS({
  "node_modules/polytope-closest-point/lib/closest_point_2d.js"(exports2, module2) {
    "use strict";
    var diff = new Float64Array(4);
    var edge0 = new Float64Array(4);
    var edge1 = new Float64Array(4);
    function closestPoint2d(V0, V1, V2, point, result) {
      if (diff.length < point.length) {
        diff = new Float64Array(point.length);
        edge0 = new Float64Array(point.length);
        edge1 = new Float64Array(point.length);
      }
      for (var i = 0; i < point.length; ++i) {
        diff[i] = V0[i] - point[i];
        edge0[i] = V1[i] - V0[i];
        edge1[i] = V2[i] - V0[i];
      }
      var a00 = 0, a01 = 0, a11 = 0, b0 = 0, b1 = 0, c = 0;
      for (var i = 0; i < point.length; ++i) {
        var e0 = edge0[i], e1 = edge1[i], d = diff[i];
        a00 += e0 * e0;
        a01 += e0 * e1;
        a11 += e1 * e1;
        b0 += d * e0;
        b1 += d * e1;
        c += d * d;
      }
      var det = Math.abs(a00 * a11 - a01 * a01);
      var s = a01 * b1 - a11 * b0;
      var t = a01 * b0 - a00 * b1;
      var sqrDistance;
      if (s + t <= det) {
        if (s < 0) {
          if (t < 0) {
            if (b0 < 0) {
              t = 0;
              if (-b0 >= a00) {
                s = 1;
                sqrDistance = a00 + 2 * b0 + c;
              } else {
                s = -b0 / a00;
                sqrDistance = b0 * s + c;
              }
            } else {
              s = 0;
              if (b1 >= 0) {
                t = 0;
                sqrDistance = c;
              } else if (-b1 >= a11) {
                t = 1;
                sqrDistance = a11 + 2 * b1 + c;
              } else {
                t = -b1 / a11;
                sqrDistance = b1 * t + c;
              }
            }
          } else {
            s = 0;
            if (b1 >= 0) {
              t = 0;
              sqrDistance = c;
            } else if (-b1 >= a11) {
              t = 1;
              sqrDistance = a11 + 2 * b1 + c;
            } else {
              t = -b1 / a11;
              sqrDistance = b1 * t + c;
            }
          }
        } else if (t < 0) {
          t = 0;
          if (b0 >= 0) {
            s = 0;
            sqrDistance = c;
          } else if (-b0 >= a00) {
            s = 1;
            sqrDistance = a00 + 2 * b0 + c;
          } else {
            s = -b0 / a00;
            sqrDistance = b0 * s + c;
          }
        } else {
          var invDet = 1 / det;
          s *= invDet;
          t *= invDet;
          sqrDistance = s * (a00 * s + a01 * t + 2 * b0) + t * (a01 * s + a11 * t + 2 * b1) + c;
        }
      } else {
        var tmp0, tmp1, numer, denom;
        if (s < 0) {
          tmp0 = a01 + b0;
          tmp1 = a11 + b1;
          if (tmp1 > tmp0) {
            numer = tmp1 - tmp0;
            denom = a00 - 2 * a01 + a11;
            if (numer >= denom) {
              s = 1;
              t = 0;
              sqrDistance = a00 + 2 * b0 + c;
            } else {
              s = numer / denom;
              t = 1 - s;
              sqrDistance = s * (a00 * s + a01 * t + 2 * b0) + t * (a01 * s + a11 * t + 2 * b1) + c;
            }
          } else {
            s = 0;
            if (tmp1 <= 0) {
              t = 1;
              sqrDistance = a11 + 2 * b1 + c;
            } else if (b1 >= 0) {
              t = 0;
              sqrDistance = c;
            } else {
              t = -b1 / a11;
              sqrDistance = b1 * t + c;
            }
          }
        } else if (t < 0) {
          tmp0 = a01 + b1;
          tmp1 = a00 + b0;
          if (tmp1 > tmp0) {
            numer = tmp1 - tmp0;
            denom = a00 - 2 * a01 + a11;
            if (numer >= denom) {
              t = 1;
              s = 0;
              sqrDistance = a11 + 2 * b1 + c;
            } else {
              t = numer / denom;
              s = 1 - t;
              sqrDistance = s * (a00 * s + a01 * t + 2 * b0) + t * (a01 * s + a11 * t + 2 * b1) + c;
            }
          } else {
            t = 0;
            if (tmp1 <= 0) {
              s = 1;
              sqrDistance = a00 + 2 * b0 + c;
            } else if (b0 >= 0) {
              s = 0;
              sqrDistance = c;
            } else {
              s = -b0 / a00;
              sqrDistance = b0 * s + c;
            }
          }
        } else {
          numer = a11 + b1 - a01 - b0;
          if (numer <= 0) {
            s = 0;
            t = 1;
            sqrDistance = a11 + 2 * b1 + c;
          } else {
            denom = a00 - 2 * a01 + a11;
            if (numer >= denom) {
              s = 1;
              t = 0;
              sqrDistance = a00 + 2 * b0 + c;
            } else {
              s = numer / denom;
              t = 1 - s;
              sqrDistance = s * (a00 * s + a01 * t + 2 * b0) + t * (a01 * s + a11 * t + 2 * b1) + c;
            }
          }
        }
      }
      var u = 1 - s - t;
      for (var i = 0; i < point.length; ++i) {
        result[i] = u * V0[i] + s * V1[i] + t * V2[i];
      }
      if (sqrDistance < 0) {
        return 0;
      }
      return sqrDistance;
    }
    module2.exports = closestPoint2d;
  }
});

// node_modules/gl-mesh3d/lib/closest-point.js
var require_closest_point = __commonJS({
  "node_modules/gl-mesh3d/lib/closest-point.js"(exports2, module2) {
    "use strict";
    var barycentric = require_barycentric();
    var closestPointToTriangle = require_closest_point_2d();
    module2.exports = closestPointToPickLocation;
    function xformMatrix(m, v) {
      var out = [0, 0, 0, 0];
      for (var i = 0; i < 4; ++i) {
        for (var j = 0; j < 4; ++j) {
          out[j] += m[4 * i + j] * v[i];
        }
      }
      return out;
    }
    function projectVertex(v, model, view, projection, resolution) {
      var p = xformMatrix(
        projection,
        xformMatrix(
          view,
          xformMatrix(model, [v[0], v[1], v[2], 1])
        )
      );
      for (var i = 0; i < 3; ++i) {
        p[i] /= p[3];
      }
      return [0.5 * resolution[0] * (1 + p[0]), 0.5 * resolution[1] * (1 - p[1])];
    }
    function barycentricCoord(simplex, point) {
      if (simplex.length === 2) {
        var d0 = 0;
        var d1 = 0;
        for (var i = 0; i < 2; ++i) {
          d0 += Math.pow(point[i] - simplex[0][i], 2);
          d1 += Math.pow(point[i] - simplex[1][i], 2);
        }
        d0 = Math.sqrt(d0);
        d1 = Math.sqrt(d1);
        if (d0 + d1 < 1e-6) {
          return [1, 0];
        }
        return [d1 / (d0 + d1), d0 / (d1 + d0)];
      } else if (simplex.length === 3) {
        var closestPoint = [0, 0];
        closestPointToTriangle(simplex[0], simplex[1], simplex[2], point, closestPoint);
        return barycentric(simplex, closestPoint);
      }
      return [];
    }
    function interpolate(simplex, weights) {
      var result = [0, 0, 0];
      for (var i = 0; i < simplex.length; ++i) {
        var p = simplex[i];
        var w = weights[i];
        for (var j = 0; j < 3; ++j) {
          result[j] += w * p[j];
        }
      }
      return result;
    }
    function closestPointToPickLocation(simplex, pixelCoord, model, view, projection, resolution) {
      if (simplex.length === 1) {
        return [0, simplex[0].slice()];
      }
      var simplex2D = new Array(simplex.length);
      for (var i = 0; i < simplex.length; ++i) {
        simplex2D[i] = projectVertex(simplex[i], model, view, projection, resolution);
      }
      var closestIndex = 0;
      var closestDist = Infinity;
      for (var i = 0; i < simplex2D.length; ++i) {
        var d2 = 0;
        for (var j = 0; j < 2; ++j) {
          d2 += Math.pow(simplex2D[i][j] - pixelCoord[j], 2);
        }
        if (d2 < closestDist) {
          closestDist = d2;
          closestIndex = i;
        }
      }
      var weights = barycentricCoord(simplex2D, pixelCoord);
      var s = 0;
      for (var i = 0; i < 3; ++i) {
        if (weights[i] < -1e-3 || weights[i] > 1.0001) {
          return null;
        }
        s += weights[i];
      }
      if (Math.abs(s - 1) > 1e-3) {
        return null;
      }
      return [closestIndex, interpolate(simplex, weights), weights];
    }
  }
});

// node_modules/gl-mesh3d/mesh.js
var require_mesh = __commonJS({
  "node_modules/gl-mesh3d/mesh.js"(exports2, module2) {
    "use strict";
    var DEFAULT_VERTEX_NORMALS_EPSILON = 1e-6;
    var DEFAULT_FACE_NORMALS_EPSILON = 1e-6;
    var createShader = require_gl_shader();
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createTexture = require_texture();
    var normals = require_normals();
    var multiply = require_multiply2();
    var invert = require_invert();
    var ndarray = require_ndarray();
    var colormap = require_colormap();
    var getContour = require_contour();
    var pool = require_pool();
    var shaders = require_shaders5();
    var closestPoint = require_closest_point();
    var meshShader = shaders.meshShader;
    var wireShader = shaders.wireShader;
    var pointShader = shaders.pointShader;
    var pickShader = shaders.pickShader;
    var pointPickShader = shaders.pointPickShader;
    var contourShader = shaders.contourShader;
    var IDENTITY = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    function SimplicialMesh(gl2, texture, triShader, lineShader, pointShader2, pickShader2, pointPickShader2, contourShader2, trianglePositions, triangleIds, triangleColors, triangleUVs, triangleNormals, triangleVAO, edgePositions, edgeIds, edgeColors, edgeUVs, edgeVAO, pointPositions, pointIds, pointColors, pointUVs, pointSizes, pointVAO, contourPositions, contourVAO) {
      this.gl = gl2;
      this.pixelRatio = 1;
      this.cells = [];
      this.positions = [];
      this.intensity = [];
      this.texture = texture;
      this.dirty = true;
      this.triShader = triShader;
      this.lineShader = lineShader;
      this.pointShader = pointShader2;
      this.pickShader = pickShader2;
      this.pointPickShader = pointPickShader2;
      this.contourShader = contourShader2;
      this.trianglePositions = trianglePositions;
      this.triangleColors = triangleColors;
      this.triangleNormals = triangleNormals;
      this.triangleUVs = triangleUVs;
      this.triangleIds = triangleIds;
      this.triangleVAO = triangleVAO;
      this.triangleCount = 0;
      this.lineWidth = 1;
      this.edgePositions = edgePositions;
      this.edgeColors = edgeColors;
      this.edgeUVs = edgeUVs;
      this.edgeIds = edgeIds;
      this.edgeVAO = edgeVAO;
      this.edgeCount = 0;
      this.pointPositions = pointPositions;
      this.pointColors = pointColors;
      this.pointUVs = pointUVs;
      this.pointSizes = pointSizes;
      this.pointIds = pointIds;
      this.pointVAO = pointVAO;
      this.pointCount = 0;
      this.contourLineWidth = 1;
      this.contourPositions = contourPositions;
      this.contourVAO = contourVAO;
      this.contourCount = 0;
      this.contourColor = [0, 0, 0];
      this.contourEnable = true;
      this.pickVertex = true;
      this.pickId = 1;
      this.bounds = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      this.clipBounds = [
        [-Infinity, -Infinity, -Infinity],
        [Infinity, Infinity, Infinity]
      ];
      this.lightPosition = [1e5, 1e5, 0];
      this.ambientLight = 0.8;
      this.diffuseLight = 0.8;
      this.specularLight = 2;
      this.roughness = 0.5;
      this.fresnel = 1.5;
      this.opacity = 1;
      this.hasAlpha = false;
      this.opacityscale = false;
      this._model = IDENTITY;
      this._view = IDENTITY;
      this._projection = IDENTITY;
      this._resolution = [1, 1];
    }
    var proto = SimplicialMesh.prototype;
    proto.isOpaque = function() {
      return !this.hasAlpha;
    };
    proto.isTransparent = function() {
      return this.hasAlpha;
    };
    proto.pickSlots = 1;
    proto.setPickBase = function(id) {
      this.pickId = id;
    };
    function getOpacityFromScale(ratio, opacityscale) {
      if (!opacityscale) return 1;
      if (!opacityscale.length) return 1;
      for (var i = 0; i < opacityscale.length; ++i) {
        if (opacityscale.length < 2) return 1;
        if (opacityscale[i][0] === ratio) return opacityscale[i][1];
        if (opacityscale[i][0] > ratio && i > 0) {
          var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);
          return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];
        }
      }
      return 1;
    }
    function genColormap(param, opacityscale) {
      var colors = colormap({
        colormap: param,
        nshades: 256,
        format: "rgba"
      });
      var result = new Uint8Array(256 * 4);
      for (var i = 0; i < 256; ++i) {
        var c = colors[i];
        for (var j = 0; j < 3; ++j) {
          result[4 * i + j] = c[j];
        }
        if (!opacityscale) {
          result[4 * i + 3] = 255 * c[3];
        } else {
          result[4 * i + 3] = 255 * getOpacityFromScale(i / 255, opacityscale);
        }
      }
      return ndarray(result, [256, 256, 4], [4, 0, 1]);
    }
    function takeZComponent(array) {
      var n = array.length;
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = array[i][2];
      }
      return result;
    }
    proto.highlight = function(selection) {
      if (!selection || !this.contourEnable) {
        this.contourCount = 0;
        return;
      }
      var level = getContour(this.cells, this.intensity, selection.intensity);
      var cells = level.cells;
      var vertexIds = level.vertexIds;
      var vertexWeights = level.vertexWeights;
      var numCells = cells.length;
      var result = pool.mallocFloat32(2 * 3 * numCells);
      var ptr = 0;
      for (var i = 0; i < numCells; ++i) {
        var c = cells[i];
        for (var j = 0; j < 2; ++j) {
          var v = c[0];
          if (c.length === 2) {
            v = c[j];
          }
          var a = vertexIds[v][0];
          var b = vertexIds[v][1];
          var w = vertexWeights[v];
          var wi = 1 - w;
          var pa = this.positions[a];
          var pb = this.positions[b];
          for (var k = 0; k < 3; ++k) {
            result[ptr++] = w * pa[k] + wi * pb[k];
          }
        }
      }
      this.contourCount = ptr / 3 | 0;
      this.contourPositions.update(result.subarray(0, ptr));
      pool.free(result);
    };
    proto.update = function(params) {
      params = params || {};
      var gl2 = this.gl;
      this.dirty = true;
      if ("contourEnable" in params) {
        this.contourEnable = params.contourEnable;
      }
      if ("contourColor" in params) {
        this.contourColor = params.contourColor;
      }
      if ("lineWidth" in params) {
        this.lineWidth = params.lineWidth;
      }
      if ("lightPosition" in params) {
        this.lightPosition = params.lightPosition;
      }
      this.hasAlpha = false;
      if ("opacity" in params) {
        this.opacity = params.opacity;
        if (this.opacity < 1) {
          this.hasAlpha = true;
        }
      }
      if ("opacityscale" in params) {
        this.opacityscale = params.opacityscale;
        this.hasAlpha = true;
      }
      if ("ambient" in params) {
        this.ambientLight = params.ambient;
      }
      if ("diffuse" in params) {
        this.diffuseLight = params.diffuse;
      }
      if ("specular" in params) {
        this.specularLight = params.specular;
      }
      if ("roughness" in params) {
        this.roughness = params.roughness;
      }
      if ("fresnel" in params) {
        this.fresnel = params.fresnel;
      }
      if (params.texture) {
        this.texture.dispose();
        this.texture = createTexture(gl2, params.texture);
      } else if (params.colormap) {
        this.texture.shape = [256, 256];
        this.texture.minFilter = gl2.LINEAR_MIPMAP_LINEAR;
        this.texture.magFilter = gl2.LINEAR;
        this.texture.setPixels(genColormap(params.colormap, this.opacityscale));
        this.texture.generateMipmap();
      }
      var cells = params.cells;
      var positions = params.positions;
      if (!positions || !cells) {
        return;
      }
      var tPos = [];
      var tCol = [];
      var tNor = [];
      var tUVs = [];
      var tIds = [];
      var ePos = [];
      var eCol = [];
      var eUVs = [];
      var eIds = [];
      var pPos = [];
      var pCol = [];
      var pUVs = [];
      var pSiz = [];
      var pIds = [];
      this.cells = cells;
      this.positions = positions;
      var vertexNormals = params.vertexNormals;
      var cellNormals = params.cellNormals;
      var vertexNormalsEpsilon = params.vertexNormalsEpsilon === void 0 ? DEFAULT_VERTEX_NORMALS_EPSILON : params.vertexNormalsEpsilon;
      var faceNormalsEpsilon = params.faceNormalsEpsilon === void 0 ? DEFAULT_FACE_NORMALS_EPSILON : params.faceNormalsEpsilon;
      if (params.useFacetNormals && !cellNormals) {
        cellNormals = normals.faceNormals(cells, positions, faceNormalsEpsilon);
      }
      if (!cellNormals && !vertexNormals) {
        vertexNormals = normals.vertexNormals(cells, positions, vertexNormalsEpsilon);
      }
      var vertexColors = params.vertexColors;
      var cellColors = params.cellColors;
      var meshColor = params.meshColor || [1, 1, 1, 1];
      var vertexUVs = params.vertexUVs;
      var vertexIntensity = params.vertexIntensity;
      var cellUVs = params.cellUVs;
      var cellIntensity = params.cellIntensity;
      var intensityLo = Infinity;
      var intensityHi = -Infinity;
      if (!vertexUVs && !cellUVs) {
        if (vertexIntensity) {
          if (params.vertexIntensityBounds) {
            intensityLo = +params.vertexIntensityBounds[0];
            intensityHi = +params.vertexIntensityBounds[1];
          } else {
            for (var i = 0; i < vertexIntensity.length; ++i) {
              var f = vertexIntensity[i];
              intensityLo = Math.min(intensityLo, f);
              intensityHi = Math.max(intensityHi, f);
            }
          }
        } else if (cellIntensity) {
          if (params.cellIntensityBounds) {
            intensityLo = +params.cellIntensityBounds[0];
            intensityHi = +params.cellIntensityBounds[1];
          } else {
            for (var i = 0; i < cellIntensity.length; ++i) {
              var f = cellIntensity[i];
              intensityLo = Math.min(intensityLo, f);
              intensityHi = Math.max(intensityHi, f);
            }
          }
        } else {
          for (var i = 0; i < positions.length; ++i) {
            var f = positions[i][2];
            intensityLo = Math.min(intensityLo, f);
            intensityHi = Math.max(intensityHi, f);
          }
        }
      }
      if (vertexIntensity) {
        this.intensity = vertexIntensity;
      } else if (cellIntensity) {
        this.intensity = cellIntensity;
      } else {
        this.intensity = takeZComponent(positions);
      }
      this.pickVertex = !(cellIntensity || cellColors);
      var pointSizes = params.pointSizes;
      var meshPointSize = params.pointSize || 1;
      this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      for (var i = 0; i < positions.length; ++i) {
        var p = positions[i];
        for (var j = 0; j < 3; ++j) {
          if (isNaN(p[j]) || !isFinite(p[j])) {
            continue;
          }
          this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);
          this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);
        }
      }
      var triangleCount = 0;
      var edgeCount = 0;
      var pointCount = 0;
      fill_loop:
        for (var i = 0; i < cells.length; ++i) {
          var cell = cells[i];
          switch (cell.length) {
            case 1:
              var v = cell[0];
              var p = positions[v];
              for (var j = 0; j < 3; ++j) {
                if (isNaN(p[j]) || !isFinite(p[j])) {
                  continue fill_loop;
                }
              }
              pPos.push(p[0], p[1], p[2]);
              var c;
              if (vertexColors) {
                c = vertexColors[v];
              } else if (cellColors) {
                c = cellColors[i];
              } else {
                c = meshColor;
              }
              if (this.opacityscale && vertexIntensity) {
                tCol.push(
                  c[0],
                  c[1],
                  c[2],
                  this.opacity * getOpacityFromScale(
                    (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                    this.opacityscale
                  )
                );
              } else if (c.length === 3) {
                pCol.push(c[0], c[1], c[2], this.opacity);
              } else {
                pCol.push(c[0], c[1], c[2], c[3] * this.opacity);
                if (c[3] < 1) this.hasAlpha = true;
              }
              var uv;
              if (vertexUVs) {
                uv = vertexUVs[v];
              } else if (vertexIntensity) {
                uv = [
                  (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                  0
                ];
              } else if (cellUVs) {
                uv = cellUVs[i];
              } else if (cellIntensity) {
                uv = [
                  (cellIntensity[i] - intensityLo) / (intensityHi - intensityLo),
                  0
                ];
              } else {
                uv = [
                  (p[2] - intensityLo) / (intensityHi - intensityLo),
                  0
                ];
              }
              pUVs.push(uv[0], uv[1]);
              if (pointSizes) {
                pSiz.push(pointSizes[v]);
              } else {
                pSiz.push(meshPointSize);
              }
              pIds.push(i);
              pointCount += 1;
              break;
            case 2:
              for (var j = 0; j < 2; ++j) {
                var v = cell[j];
                var p = positions[v];
                for (var k = 0; k < 3; ++k) {
                  if (isNaN(p[k]) || !isFinite(p[k])) {
                    continue fill_loop;
                  }
                }
              }
              for (var j = 0; j < 2; ++j) {
                var v = cell[j];
                var p = positions[v];
                ePos.push(p[0], p[1], p[2]);
                var c;
                if (vertexColors) {
                  c = vertexColors[v];
                } else if (cellColors) {
                  c = cellColors[i];
                } else {
                  c = meshColor;
                }
                if (this.opacityscale && vertexIntensity) {
                  tCol.push(
                    c[0],
                    c[1],
                    c[2],
                    this.opacity * getOpacityFromScale(
                      (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                      this.opacityscale
                    )
                  );
                } else if (c.length === 3) {
                  eCol.push(c[0], c[1], c[2], this.opacity);
                } else {
                  eCol.push(c[0], c[1], c[2], c[3] * this.opacity);
                  if (c[3] < 1) this.hasAlpha = true;
                }
                var uv;
                if (vertexUVs) {
                  uv = vertexUVs[v];
                } else if (vertexIntensity) {
                  uv = [
                    (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                } else if (cellUVs) {
                  uv = cellUVs[i];
                } else if (cellIntensity) {
                  uv = [
                    (cellIntensity[i] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                } else {
                  uv = [
                    (p[2] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                }
                eUVs.push(uv[0], uv[1]);
                eIds.push(i);
              }
              edgeCount += 1;
              break;
            case 3:
              for (var j = 0; j < 3; ++j) {
                var v = cell[j];
                var p = positions[v];
                for (var k = 0; k < 3; ++k) {
                  if (isNaN(p[k]) || !isFinite(p[k])) {
                    continue fill_loop;
                  }
                }
              }
              for (var j = 0; j < 3; ++j) {
                var v = cell[2 - j];
                var p = positions[v];
                tPos.push(p[0], p[1], p[2]);
                var c;
                if (vertexColors) {
                  c = vertexColors[v];
                } else if (cellColors) {
                  c = cellColors[i];
                } else {
                  c = meshColor;
                }
                if (!c) {
                  tCol.push(0.5, 0.5, 0.5, 1);
                } else if (this.opacityscale && vertexIntensity) {
                  tCol.push(
                    c[0],
                    c[1],
                    c[2],
                    this.opacity * getOpacityFromScale(
                      (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                      this.opacityscale
                    )
                  );
                } else if (c.length === 3) {
                  tCol.push(c[0], c[1], c[2], this.opacity);
                } else {
                  tCol.push(c[0], c[1], c[2], c[3] * this.opacity);
                  if (c[3] < 1) this.hasAlpha = true;
                }
                var uv;
                if (vertexUVs) {
                  uv = vertexUVs[v];
                } else if (vertexIntensity) {
                  uv = [
                    (vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                } else if (cellUVs) {
                  uv = cellUVs[i];
                } else if (cellIntensity) {
                  uv = [
                    (cellIntensity[i] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                } else {
                  uv = [
                    (p[2] - intensityLo) / (intensityHi - intensityLo),
                    0
                  ];
                }
                tUVs.push(uv[0], uv[1]);
                var q;
                if (vertexNormals) {
                  q = vertexNormals[v];
                } else {
                  q = cellNormals[i];
                }
                tNor.push(q[0], q[1], q[2]);
                tIds.push(i);
              }
              triangleCount += 1;
              break;
            default:
              break;
          }
        }
      this.pointCount = pointCount;
      this.edgeCount = edgeCount;
      this.triangleCount = triangleCount;
      this.pointPositions.update(pPos);
      this.pointColors.update(pCol);
      this.pointUVs.update(pUVs);
      this.pointSizes.update(pSiz);
      this.pointIds.update(new Uint32Array(pIds));
      this.edgePositions.update(ePos);
      this.edgeColors.update(eCol);
      this.edgeUVs.update(eUVs);
      this.edgeIds.update(new Uint32Array(eIds));
      this.trianglePositions.update(tPos);
      this.triangleColors.update(tCol);
      this.triangleUVs.update(tUVs);
      this.triangleNormals.update(tNor);
      this.triangleIds.update(new Uint32Array(tIds));
    };
    proto.drawTransparent = proto.draw = function(params) {
      params = params || {};
      var gl2 = this.gl;
      var model = params.model || IDENTITY;
      var view = params.view || IDENTITY;
      var projection = params.projection || IDENTITY;
      var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];
      for (var i = 0; i < 3; ++i) {
        clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);
        clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);
      }
      var uniforms = {
        model,
        view,
        projection,
        inverseModel: IDENTITY.slice(),
        clipBounds,
        kambient: this.ambientLight,
        kdiffuse: this.diffuseLight,
        kspecular: this.specularLight,
        roughness: this.roughness,
        fresnel: this.fresnel,
        eyePosition: [0, 0, 0],
        lightPosition: [0, 0, 0],
        contourColor: this.contourColor,
        texture: 0
      };
      uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);
      gl2.disable(gl2.CULL_FACE);
      this.texture.bind(0);
      var invCameraMatrix = new Array(16);
      multiply(invCameraMatrix, uniforms.view, uniforms.model);
      multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);
      invert(invCameraMatrix, invCameraMatrix);
      for (var i = 0; i < 3; ++i) {
        uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];
      }
      var w = invCameraMatrix[15];
      for (var i = 0; i < 3; ++i) {
        w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];
      }
      for (var i = 0; i < 3; ++i) {
        var s = invCameraMatrix[12 + i];
        for (var j = 0; j < 3; ++j) {
          s += invCameraMatrix[4 * j + i] * this.lightPosition[j];
        }
        uniforms.lightPosition[i] = s / w;
      }
      if (this.triangleCount > 0) {
        var shader = this.triShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.triangleVAO.bind();
        gl2.drawArrays(gl2.TRIANGLES, 0, this.triangleCount * 3);
        this.triangleVAO.unbind();
      }
      if (this.edgeCount > 0 && this.lineWidth > 0) {
        var shader = this.lineShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.edgeVAO.bind();
        gl2.lineWidth(this.lineWidth * this.pixelRatio);
        gl2.drawArrays(gl2.LINES, 0, this.edgeCount * 2);
        this.edgeVAO.unbind();
      }
      if (this.pointCount > 0) {
        var shader = this.pointShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.pointVAO.bind();
        gl2.drawArrays(gl2.POINTS, 0, this.pointCount);
        this.pointVAO.unbind();
      }
      if (this.contourEnable && this.contourCount > 0 && this.contourLineWidth > 0) {
        var shader = this.contourShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.contourVAO.bind();
        gl2.drawArrays(gl2.LINES, 0, this.contourCount);
        this.contourVAO.unbind();
      }
    };
    proto.drawPick = function(params) {
      params = params || {};
      var gl2 = this.gl;
      var model = params.model || IDENTITY;
      var view = params.view || IDENTITY;
      var projection = params.projection || IDENTITY;
      var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];
      for (var i = 0; i < 3; ++i) {
        clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);
        clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);
      }
      this._model = [].slice.call(model);
      this._view = [].slice.call(view);
      this._projection = [].slice.call(projection);
      this._resolution = [gl2.drawingBufferWidth, gl2.drawingBufferHeight];
      var uniforms = {
        model,
        view,
        projection,
        clipBounds,
        pickId: this.pickId / 255
      };
      var shader = this.pickShader;
      shader.bind();
      shader.uniforms = uniforms;
      if (this.triangleCount > 0) {
        this.triangleVAO.bind();
        gl2.drawArrays(gl2.TRIANGLES, 0, this.triangleCount * 3);
        this.triangleVAO.unbind();
      }
      if (this.edgeCount > 0) {
        this.edgeVAO.bind();
        gl2.lineWidth(this.lineWidth * this.pixelRatio);
        gl2.drawArrays(gl2.LINES, 0, this.edgeCount * 2);
        this.edgeVAO.unbind();
      }
      if (this.pointCount > 0) {
        var shader = this.pointPickShader;
        shader.bind();
        shader.uniforms = uniforms;
        this.pointVAO.bind();
        gl2.drawArrays(gl2.POINTS, 0, this.pointCount);
        this.pointVAO.unbind();
      }
    };
    proto.pick = function(pickData) {
      if (!pickData) {
        return null;
      }
      if (pickData.id !== this.pickId) {
        return null;
      }
      var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];
      var cell = this.cells[cellId];
      var positions = this.positions;
      var simplex = new Array(cell.length);
      for (var i = 0; i < cell.length; ++i) {
        simplex[i] = positions[cell[i]];
      }
      var x = pickData.coord[0];
      var y = pickData.coord[1];
      if (!this.pickVertex) {
        var A = this.positions[cell[0]];
        var B = this.positions[cell[1]];
        var C = this.positions[cell[2]];
        var dataCoordinate = [
          (A[0] + B[0] + C[0]) / 3,
          (A[1] + B[1] + C[1]) / 3,
          (A[2] + B[2] + C[2]) / 3
        ];
        return {
          _cellCenter: true,
          position: [x, y],
          index: cellId,
          cell,
          cellId,
          intensity: this.intensity[cellId],
          dataCoordinate
        };
      }
      var data = closestPoint(
        simplex,
        [x * this.pixelRatio, this._resolution[1] - y * this.pixelRatio],
        this._model,
        this._view,
        this._projection,
        this._resolution
      );
      if (!data) {
        return null;
      }
      var weights = data[2];
      var interpIntensity = 0;
      for (var i = 0; i < cell.length; ++i) {
        interpIntensity += weights[i] * this.intensity[cell[i]];
      }
      return {
        position: data[1],
        index: cell[data[0]],
        cell,
        cellId,
        intensity: interpIntensity,
        dataCoordinate: this.positions[cell[data[0]]]
      };
    };
    proto.dispose = function() {
      this.texture.dispose();
      this.triShader.dispose();
      this.lineShader.dispose();
      this.pointShader.dispose();
      this.pickShader.dispose();
      this.pointPickShader.dispose();
      this.triangleVAO.dispose();
      this.trianglePositions.dispose();
      this.triangleColors.dispose();
      this.triangleUVs.dispose();
      this.triangleNormals.dispose();
      this.triangleIds.dispose();
      this.edgeVAO.dispose();
      this.edgePositions.dispose();
      this.edgeColors.dispose();
      this.edgeUVs.dispose();
      this.edgeIds.dispose();
      this.pointVAO.dispose();
      this.pointPositions.dispose();
      this.pointColors.dispose();
      this.pointUVs.dispose();
      this.pointSizes.dispose();
      this.pointIds.dispose();
      this.contourVAO.dispose();
      this.contourPositions.dispose();
      this.contourShader.dispose();
    };
    function createMeshShader(gl2) {
      var shader = createShader(gl2, meshShader.vertex, meshShader.fragment);
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 2;
      shader.attributes.uv.location = 3;
      shader.attributes.normal.location = 4;
      return shader;
    }
    function createWireShader(gl2) {
      var shader = createShader(gl2, wireShader.vertex, wireShader.fragment);
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 2;
      shader.attributes.uv.location = 3;
      return shader;
    }
    function createPointShader(gl2) {
      var shader = createShader(gl2, pointShader.vertex, pointShader.fragment);
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 2;
      shader.attributes.uv.location = 3;
      shader.attributes.pointSize.location = 4;
      return shader;
    }
    function createPickShader(gl2) {
      var shader = createShader(gl2, pickShader.vertex, pickShader.fragment);
      shader.attributes.position.location = 0;
      shader.attributes.id.location = 1;
      return shader;
    }
    function createPointPickShader(gl2) {
      var shader = createShader(gl2, pointPickShader.vertex, pointPickShader.fragment);
      shader.attributes.position.location = 0;
      shader.attributes.id.location = 1;
      shader.attributes.pointSize.location = 4;
      return shader;
    }
    function createContourShader(gl2) {
      var shader = createShader(gl2, contourShader.vertex, contourShader.fragment);
      shader.attributes.position.location = 0;
      return shader;
    }
    function createSimplicialMesh(gl2, params) {
      if (arguments.length === 1) {
        params = gl2;
        gl2 = params.gl;
      }
      var ext = gl2.getExtension("OES_standard_derivatives") || gl2.getExtension("MOZ_OES_standard_derivatives") || gl2.getExtension("WEBKIT_OES_standard_derivatives");
      if (!ext)
        throw new Error("derivatives not supported");
      var triShader = createMeshShader(gl2);
      var lineShader = createWireShader(gl2);
      var pointShader2 = createPointShader(gl2);
      var pickShader2 = createPickShader(gl2);
      var pointPickShader2 = createPointPickShader(gl2);
      var contourShader2 = createContourShader(gl2);
      var meshTexture = createTexture(
        gl2,
        ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4])
      );
      meshTexture.generateMipmap();
      meshTexture.minFilter = gl2.LINEAR_MIPMAP_LINEAR;
      meshTexture.magFilter = gl2.LINEAR;
      var trianglePositions = createBuffer(gl2);
      var triangleColors = createBuffer(gl2);
      var triangleUVs = createBuffer(gl2);
      var triangleNormals = createBuffer(gl2);
      var triangleIds = createBuffer(gl2);
      var triangleVAO = createVAO(gl2, [
        {
          buffer: trianglePositions,
          type: gl2.FLOAT,
          size: 3
        },
        {
          buffer: triangleIds,
          type: gl2.UNSIGNED_BYTE,
          size: 4,
          normalized: true
        },
        {
          buffer: triangleColors,
          type: gl2.FLOAT,
          size: 4
        },
        {
          buffer: triangleUVs,
          type: gl2.FLOAT,
          size: 2
        },
        {
          buffer: triangleNormals,
          type: gl2.FLOAT,
          size: 3
        }
      ]);
      var edgePositions = createBuffer(gl2);
      var edgeColors = createBuffer(gl2);
      var edgeUVs = createBuffer(gl2);
      var edgeIds = createBuffer(gl2);
      var edgeVAO = createVAO(gl2, [
        {
          buffer: edgePositions,
          type: gl2.FLOAT,
          size: 3
        },
        {
          buffer: edgeIds,
          type: gl2.UNSIGNED_BYTE,
          size: 4,
          normalized: true
        },
        {
          buffer: edgeColors,
          type: gl2.FLOAT,
          size: 4
        },
        {
          buffer: edgeUVs,
          type: gl2.FLOAT,
          size: 2
        }
      ]);
      var pointPositions = createBuffer(gl2);
      var pointColors = createBuffer(gl2);
      var pointUVs = createBuffer(gl2);
      var pointSizes = createBuffer(gl2);
      var pointIds = createBuffer(gl2);
      var pointVAO = createVAO(gl2, [
        {
          buffer: pointPositions,
          type: gl2.FLOAT,
          size: 3
        },
        {
          buffer: pointIds,
          type: gl2.UNSIGNED_BYTE,
          size: 4,
          normalized: true
        },
        {
          buffer: pointColors,
          type: gl2.FLOAT,
          size: 4
        },
        {
          buffer: pointUVs,
          type: gl2.FLOAT,
          size: 2
        },
        {
          buffer: pointSizes,
          type: gl2.FLOAT,
          size: 1
        }
      ]);
      var contourPositions = createBuffer(gl2);
      var contourVAO = createVAO(gl2, [
        {
          buffer: contourPositions,
          type: gl2.FLOAT,
          size: 3
        }
      ]);
      var mesh = new SimplicialMesh(
        gl2,
        meshTexture,
        triShader,
        lineShader,
        pointShader2,
        pickShader2,
        pointPickShader2,
        contourShader2,
        trianglePositions,
        triangleIds,
        triangleColors,
        triangleUVs,
        triangleNormals,
        triangleVAO,
        edgePositions,
        edgeIds,
        edgeColors,
        edgeUVs,
        edgeVAO,
        pointPositions,
        pointIds,
        pointColors,
        pointUVs,
        pointSizes,
        pointVAO,
        contourPositions,
        contourVAO
      );
      mesh.update(params);
      return mesh;
    }
    module2.exports = createSimplicialMesh;
  }
});

// node_modules/gl-fbo/fbo.js
var require_fbo = __commonJS({
  "node_modules/gl-fbo/fbo.js"(exports2, module2) {
    "use strict";
    var createTexture = require_texture();
    module2.exports = createFBO;
    var colorAttachmentArrays = null;
    var FRAMEBUFFER_UNSUPPORTED;
    var FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
    var FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
    var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
    function saveFBOState(gl2) {
      var fbo = gl2.getParameter(gl2.FRAMEBUFFER_BINDING);
      var rbo = gl2.getParameter(gl2.RENDERBUFFER_BINDING);
      var tex = gl2.getParameter(gl2.TEXTURE_BINDING_2D);
      return [fbo, rbo, tex];
    }
    function restoreFBOState(gl2, data) {
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, data[0]);
      gl2.bindRenderbuffer(gl2.RENDERBUFFER, data[1]);
      gl2.bindTexture(gl2.TEXTURE_2D, data[2]);
    }
    function lazyInitColorAttachments(gl2, ext) {
      var maxColorAttachments = gl2.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);
      colorAttachmentArrays = new Array(maxColorAttachments + 1);
      for (var i = 0; i <= maxColorAttachments; ++i) {
        var x = new Array(maxColorAttachments);
        for (var j = 0; j < i; ++j) {
          x[j] = gl2.COLOR_ATTACHMENT0 + j;
        }
        for (var j = i; j < maxColorAttachments; ++j) {
          x[j] = gl2.NONE;
        }
        colorAttachmentArrays[i] = x;
      }
    }
    function throwFBOError(status) {
      switch (status) {
        case FRAMEBUFFER_UNSUPPORTED:
          throw new Error("gl-fbo: Framebuffer unsupported");
        case FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error("gl-fbo: Framebuffer incomplete attachment");
        case FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error("gl-fbo: Framebuffer incomplete dimensions");
        case FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("gl-fbo: Framebuffer incomplete missing attachment");
        default:
          throw new Error("gl-fbo: Framebuffer failed for unspecified reason");
      }
    }
    function initTexture(gl2, width, height, type, format, attachment) {
      if (!type) {
        return null;
      }
      var result = createTexture(gl2, width, height, format, type);
      result.magFilter = gl2.NEAREST;
      result.minFilter = gl2.NEAREST;
      result.mipSamples = 1;
      result.bind();
      gl2.framebufferTexture2D(gl2.FRAMEBUFFER, attachment, gl2.TEXTURE_2D, result.handle, 0);
      return result;
    }
    function initRenderBuffer(gl2, width, height, component, attachment) {
      var result = gl2.createRenderbuffer();
      gl2.bindRenderbuffer(gl2.RENDERBUFFER, result);
      gl2.renderbufferStorage(gl2.RENDERBUFFER, component, width, height);
      gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, attachment, gl2.RENDERBUFFER, result);
      return result;
    }
    function rebuildFBO(fbo) {
      var state = saveFBOState(fbo.gl);
      var gl2 = fbo.gl;
      var handle = fbo.handle = gl2.createFramebuffer();
      var width = fbo._shape[0];
      var height = fbo._shape[1];
      var numColors = fbo.color.length;
      var ext = fbo._ext;
      var useStencil = fbo._useStencil;
      var useDepth = fbo._useDepth;
      var colorType = fbo._colorType;
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, handle);
      for (var i = 0; i < numColors; ++i) {
        fbo.color[i] = initTexture(gl2, width, height, colorType, gl2.RGBA, gl2.COLOR_ATTACHMENT0 + i);
      }
      if (numColors === 0) {
        fbo._color_rb = initRenderBuffer(gl2, width, height, gl2.RGBA4, gl2.COLOR_ATTACHMENT0);
        if (ext) {
          ext.drawBuffersWEBGL(colorAttachmentArrays[0]);
        }
      } else if (numColors > 1) {
        ext.drawBuffersWEBGL(colorAttachmentArrays[numColors]);
      }
      var WEBGL_depth_texture = gl2.getExtension("WEBGL_depth_texture");
      if (WEBGL_depth_texture) {
        if (useStencil) {
          fbo.depth = initTexture(
            gl2,
            width,
            height,
            WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL,
            gl2.DEPTH_STENCIL,
            gl2.DEPTH_STENCIL_ATTACHMENT
          );
        } else if (useDepth) {
          fbo.depth = initTexture(
            gl2,
            width,
            height,
            gl2.UNSIGNED_SHORT,
            gl2.DEPTH_COMPONENT,
            gl2.DEPTH_ATTACHMENT
          );
        }
      } else {
        if (useDepth && useStencil) {
          fbo._depth_rb = initRenderBuffer(gl2, width, height, gl2.DEPTH_STENCIL, gl2.DEPTH_STENCIL_ATTACHMENT);
        } else if (useDepth) {
          fbo._depth_rb = initRenderBuffer(gl2, width, height, gl2.DEPTH_COMPONENT16, gl2.DEPTH_ATTACHMENT);
        } else if (useStencil) {
          fbo._depth_rb = initRenderBuffer(gl2, width, height, gl2.STENCIL_INDEX, gl2.STENCIL_ATTACHMENT);
        }
      }
      var status = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER);
      if (status !== gl2.FRAMEBUFFER_COMPLETE) {
        fbo._destroyed = true;
        gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
        gl2.deleteFramebuffer(fbo.handle);
        fbo.handle = null;
        if (fbo.depth) {
          fbo.depth.dispose();
          fbo.depth = null;
        }
        if (fbo._depth_rb) {
          gl2.deleteRenderbuffer(fbo._depth_rb);
          fbo._depth_rb = null;
        }
        for (var i = 0; i < fbo.color.length; ++i) {
          fbo.color[i].dispose();
          fbo.color[i] = null;
        }
        if (fbo._color_rb) {
          gl2.deleteRenderbuffer(fbo._color_rb);
          fbo._color_rb = null;
        }
        restoreFBOState(gl2, state);
        throwFBOError(status);
      }
      restoreFBOState(gl2, state);
    }
    function Framebuffer(gl2, width, height, colorType, numColors, useDepth, useStencil, ext) {
      this.gl = gl2;
      this._shape = [width | 0, height | 0];
      this._destroyed = false;
      this._ext = ext;
      this.color = new Array(numColors);
      for (var i = 0; i < numColors; ++i) {
        this.color[i] = null;
      }
      this._color_rb = null;
      this.depth = null;
      this._depth_rb = null;
      this._colorType = colorType;
      this._useDepth = useDepth;
      this._useStencil = useStencil;
      var parent = this;
      var shapeVector = [width | 0, height | 0];
      Object.defineProperties(shapeVector, {
        0: {
          get: function() {
            return parent._shape[0];
          },
          set: function(w) {
            return parent.width = w;
          }
        },
        1: {
          get: function() {
            return parent._shape[1];
          },
          set: function(h) {
            return parent.height = h;
          }
        }
      });
      this._shapeVector = shapeVector;
      rebuildFBO(this);
    }
    var proto = Framebuffer.prototype;
    function reshapeFBO(fbo, w, h) {
      if (fbo._destroyed) {
        throw new Error("gl-fbo: Can't resize destroyed FBO");
      }
      if (fbo._shape[0] === w && fbo._shape[1] === h) {
        return;
      }
      var gl2 = fbo.gl;
      var maxFBOSize = gl2.getParameter(gl2.MAX_RENDERBUFFER_SIZE);
      if (w < 0 || w > maxFBOSize || h < 0 || h > maxFBOSize) {
        throw new Error("gl-fbo: Can't resize FBO, invalid dimensions");
      }
      fbo._shape[0] = w;
      fbo._shape[1] = h;
      var state = saveFBOState(gl2);
      for (var i = 0; i < fbo.color.length; ++i) {
        fbo.color[i].shape = fbo._shape;
      }
      if (fbo._color_rb) {
        gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo._color_rb);
        gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.RGBA4, fbo._shape[0], fbo._shape[1]);
      }
      if (fbo.depth) {
        fbo.depth.shape = fbo._shape;
      }
      if (fbo._depth_rb) {
        gl2.bindRenderbuffer(gl2.RENDERBUFFER, fbo._depth_rb);
        if (fbo._useDepth && fbo._useStencil) {
          gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_STENCIL, fbo._shape[0], fbo._shape[1]);
        } else if (fbo._useDepth) {
          gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_COMPONENT16, fbo._shape[0], fbo._shape[1]);
        } else if (fbo._useStencil) {
          gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.STENCIL_INDEX, fbo._shape[0], fbo._shape[1]);
        }
      }
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, fbo.handle);
      var status = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER);
      if (status !== gl2.FRAMEBUFFER_COMPLETE) {
        fbo.dispose();
        restoreFBOState(gl2, state);
        throwFBOError(status);
      }
      restoreFBOState(gl2, state);
    }
    Object.defineProperties(proto, {
      "shape": {
        get: function() {
          if (this._destroyed) {
            return [0, 0];
          }
          return this._shapeVector;
        },
        set: function(x) {
          if (!Array.isArray(x)) {
            x = [x | 0, x | 0];
          }
          if (x.length !== 2) {
            throw new Error("gl-fbo: Shape vector must be length 2");
          }
          var w = x[0] | 0;
          var h = x[1] | 0;
          reshapeFBO(this, w, h);
          return [w, h];
        },
        enumerable: false
      },
      "width": {
        get: function() {
          if (this._destroyed) {
            return 0;
          }
          return this._shape[0];
        },
        set: function(w) {
          w = w | 0;
          reshapeFBO(this, w, this._shape[1]);
          return w;
        },
        enumerable: false
      },
      "height": {
        get: function() {
          if (this._destroyed) {
            return 0;
          }
          return this._shape[1];
        },
        set: function(h) {
          h = h | 0;
          reshapeFBO(this, this._shape[0], h);
          return h;
        },
        enumerable: false
      }
    });
    proto.bind = function() {
      if (this._destroyed) {
        return;
      }
      var gl2 = this.gl;
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, this.handle);
      gl2.viewport(0, 0, this._shape[0], this._shape[1]);
    };
    proto.dispose = function() {
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      var gl2 = this.gl;
      gl2.deleteFramebuffer(this.handle);
      this.handle = null;
      if (this.depth) {
        this.depth.dispose();
        this.depth = null;
      }
      if (this._depth_rb) {
        gl2.deleteRenderbuffer(this._depth_rb);
        this._depth_rb = null;
      }
      for (var i = 0; i < this.color.length; ++i) {
        this.color[i].dispose();
        this.color[i] = null;
      }
      if (this._color_rb) {
        gl2.deleteRenderbuffer(this._color_rb);
        this._color_rb = null;
      }
    };
    function createFBO(gl2, width, height, options) {
      if (!FRAMEBUFFER_UNSUPPORTED) {
        FRAMEBUFFER_UNSUPPORTED = gl2.FRAMEBUFFER_UNSUPPORTED;
        FRAMEBUFFER_INCOMPLETE_ATTACHMENT = gl2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
        FRAMEBUFFER_INCOMPLETE_DIMENSIONS = gl2.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;
        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = gl2.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;
      }
      var WEBGL_draw_buffers = gl2.getExtension("WEBGL_draw_buffers");
      if (!colorAttachmentArrays && WEBGL_draw_buffers) {
        lazyInitColorAttachments(gl2, WEBGL_draw_buffers);
      }
      if (Array.isArray(width)) {
        options = height;
        height = width[1] | 0;
        width = width[0] | 0;
      }
      if (typeof width !== "number") {
        throw new Error("gl-fbo: Missing shape parameter");
      }
      var maxFBOSize = gl2.getParameter(gl2.MAX_RENDERBUFFER_SIZE);
      if (width < 0 || width > maxFBOSize || height < 0 || height > maxFBOSize) {
        throw new Error("gl-fbo: Parameters are too large for FBO");
      }
      options = options || {};
      var numColors = 1;
      if ("color" in options) {
        numColors = Math.max(options.color | 0, 0);
        if (numColors < 0) {
          throw new Error("gl-fbo: Must specify a nonnegative number of colors");
        }
        if (numColors > 1) {
          if (!WEBGL_draw_buffers) {
            throw new Error("gl-fbo: Multiple draw buffer extension not supported");
          } else if (numColors > gl2.getParameter(WEBGL_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL)) {
            throw new Error("gl-fbo: Context does not support " + numColors + " draw buffers");
          }
        }
      }
      var colorType = gl2.UNSIGNED_BYTE;
      var OES_texture_float = gl2.getExtension("OES_texture_float");
      if (options.float && numColors > 0) {
        if (!OES_texture_float) {
          throw new Error("gl-fbo: Context does not support floating point textures");
        }
        colorType = gl2.FLOAT;
      } else if (options.preferFloat && numColors > 0) {
        if (OES_texture_float) {
          colorType = gl2.FLOAT;
        }
      }
      var useDepth = true;
      if ("depth" in options) {
        useDepth = !!options.depth;
      }
      var useStencil = false;
      if ("stencil" in options) {
        useStencil = !!options.stencil;
      }
      return new Framebuffer(
        gl2,
        width,
        height,
        colorType,
        numColors,
        useDepth,
        useStencil,
        WEBGL_draw_buffers
      );
    }
  }
});

// node_modules/gl-select-static/select.js
var require_select = __commonJS({
  "node_modules/gl-select-static/select.js"(exports2, module2) {
    "use strict";
    module2.exports = createSelectBuffer;
    var createFBO = require_fbo();
    var pool = require_pool();
    var ndarray = require_ndarray();
    var nextPow2 = require_twiddle().nextPow2;
    var selectRange = function(arr, x, y) {
      var closestD2 = 1e8;
      var closestX = -1;
      var closestY = -1;
      var ni = arr.shape[0];
      var nj = arr.shape[1];
      for (var i = 0; i < ni; i++) {
        for (var j = 0; j < nj; j++) {
          var r = arr.get(i, j, 0);
          var g = arr.get(i, j, 1);
          var b = arr.get(i, j, 2);
          var a = arr.get(i, j, 3);
          if (r < 255 || g < 255 || b < 255 || a < 255) {
            var dx = x - i;
            var dy = y - j;
            var d2 = dx * dx + dy * dy;
            if (d2 < closestD2) {
              closestD2 = d2;
              closestX = i;
              closestY = j;
            }
          }
        }
      }
      return [closestX, closestY, closestD2];
    };
    function SelectResult(x, y, id, value, distance) {
      this.coord = [x, y];
      this.id = id;
      this.value = value;
      this.distance = distance;
    }
    function SelectBuffer(gl2, fbo, buffer) {
      this.gl = gl2;
      this.fbo = fbo;
      this.buffer = buffer;
      this._readTimeout = null;
      var self = this;
      this._readCallback = function() {
        if (!self.gl) {
          return;
        }
        fbo.bind();
        gl2.readPixels(0, 0, fbo.shape[0], fbo.shape[1], gl2.RGBA, gl2.UNSIGNED_BYTE, self.buffer);
        self._readTimeout = null;
      };
    }
    var proto = SelectBuffer.prototype;
    Object.defineProperty(proto, "shape", {
      get: function() {
        if (!this.gl) {
          return [0, 0];
        }
        return this.fbo.shape.slice();
      },
      set: function(v) {
        if (!this.gl) {
          return;
        }
        this.fbo.shape = v;
        var c = this.fbo.shape[0];
        var r = this.fbo.shape[1];
        if (r * c * 4 > this.buffer.length) {
          pool.free(this.buffer);
          var buffer = this.buffer = pool.mallocUint8(nextPow2(r * c * 4));
          for (var i = 0; i < r * c * 4; ++i) {
            buffer[i] = 255;
          }
        }
        return v;
      }
    });
    proto.begin = function() {
      var gl2 = this.gl;
      var shape = this.shape;
      if (!gl2) {
        return;
      }
      this.fbo.bind();
      gl2.clearColor(1, 1, 1, 1);
      gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT);
    };
    proto.end = function() {
      var gl2 = this.gl;
      if (!gl2) {
        return;
      }
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
      if (!this._readTimeout) {
        clearTimeout(this._readTimeout);
      }
      this._readTimeout = setTimeout(this._readCallback, 1);
    };
    proto.query = function(x, y, radius) {
      if (!this.gl) {
        return null;
      }
      var shape = this.fbo.shape.slice();
      x = x | 0;
      y = y | 0;
      if (typeof radius !== "number") {
        radius = 1;
      }
      var x0 = Math.min(Math.max(x - radius, 0), shape[0]) | 0;
      var x1 = Math.min(Math.max(x + radius, 0), shape[0]) | 0;
      var y0 = Math.min(Math.max(y - radius, 0), shape[1]) | 0;
      var y1 = Math.min(Math.max(y + radius, 0), shape[1]) | 0;
      if (x1 <= x0 || y1 <= y0) {
        return null;
      }
      var dims = [x1 - x0, y1 - y0];
      var region = ndarray(
        this.buffer,
        [dims[0], dims[1], 4],
        [4, shape[0] * 4, 1],
        4 * (x0 + shape[0] * y0)
      );
      var closest = selectRange(region.hi(dims[0], dims[1], 1), radius, radius);
      var dx = closest[0];
      var dy = closest[1];
      if (dx < 0 || Math.pow(this.radius, 2) < closest[2]) {
        return null;
      }
      var c0 = region.get(dx, dy, 0);
      var c1 = region.get(dx, dy, 1);
      var c2 = region.get(dx, dy, 2);
      var c3 = region.get(dx, dy, 3);
      return new SelectResult(
        dx + x0 | 0,
        dy + y0 | 0,
        c0,
        [c1, c2, c3],
        Math.sqrt(closest[2])
      );
    };
    proto.dispose = function() {
      if (!this.gl) {
        return;
      }
      this.fbo.dispose();
      pool.free(this.buffer);
      this.gl = null;
      if (this._readTimeout) {
        clearTimeout(this._readTimeout);
      }
    };
    function createSelectBuffer(gl2, shape) {
      var width = shape[0];
      var height = shape[1];
      var options = {};
      var fbo = createFBO(gl2, width, height, options);
      var buffer = pool.mallocUint8(width * height * 4);
      return new SelectBuffer(gl2, fbo, buffer);
    }
  }
});

// node_modules/gl-plot2d/lib/shaders.js
var require_shaders6 = __commonJS({
  "node_modules/gl-plot2d/lib/shaders.js"(exports2, module2) {
    "use strict";
    var glslify = require_browser();
    var FRAGMENT = glslify("./shaders/fragment.glsl");
    module2.exports = {
      lineVert: glslify("./shaders/line-vertex.glsl"),
      lineFrag: FRAGMENT,
      textVert: glslify("./shaders/text-vertex.glsl"),
      textFrag: FRAGMENT,
      gridVert: glslify("./shaders/grid-vertex.glsl"),
      gridFrag: FRAGMENT,
      boxVert: glslify("./shaders/box-vertex.glsl"),
      tickVert: glslify("./shaders/tick-vertex.glsl")
    };
  }
});

// node_modules/gl-plot2d/lib/grid.js
var require_grid = __commonJS({
  "node_modules/gl-plot2d/lib/grid.js"(exports2, module2) {
    "use strict";
    module2.exports = createGrid;
    var createBuffer = require_buffer2();
    var createShader = require_gl_shader();
    var bsearch = require_search_bounds();
    var shaders = require_shaders6();
    function Grid(plot, vbo, shader, tickShader) {
      this.plot = plot;
      this.vbo = vbo;
      this.shader = shader;
      this.tickShader = tickShader;
      this.ticks = [[], []];
    }
    function compareTickNum(a, b) {
      return a - b;
    }
    var proto = Grid.prototype;
    proto.draw = /* @__PURE__ */ function() {
      var DATA_SHIFT = [0, 0];
      var DATA_SCALE = [0, 0];
      var DATA_AXIS = [0, 0];
      return function() {
        var plot = this.plot;
        var vbo = this.vbo;
        var shader = this.shader;
        var ticks = this.ticks;
        var gl2 = plot.gl;
        var bounds = plot._tickBounds;
        var dataBox = plot.dataBox;
        var viewPixels = plot.viewBox;
        var lineWidth = plot.gridLineWidth;
        var gridColor = plot.gridLineColor;
        var gridEnable = plot.gridLineEnable;
        var pixelRatio = plot.pixelRatio;
        for (var i = 0; i < 2; ++i) {
          var lo = bounds[i];
          var hi = bounds[i + 2];
          var boundScale = hi - lo;
          var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
          var dataWidth = dataBox[i + 2] - dataBox[i];
          DATA_SCALE[i] = 2 * boundScale / dataWidth;
          DATA_SHIFT[i] = 2 * (lo - dataCenter) / dataWidth;
        }
        shader.bind();
        vbo.bind();
        shader.attributes.dataCoord.pointer();
        shader.uniforms.dataShift = DATA_SHIFT;
        shader.uniforms.dataScale = DATA_SCALE;
        var offset = 0;
        for (var i = 0; i < 2; ++i) {
          DATA_AXIS[0] = DATA_AXIS[1] = 0;
          DATA_AXIS[i] = 1;
          shader.uniforms.dataAxis = DATA_AXIS;
          shader.uniforms.lineWidth = lineWidth[i] / (viewPixels[i + 2] - viewPixels[i]) * pixelRatio;
          shader.uniforms.color = gridColor[i];
          var size = ticks[i].length * 6;
          if (gridEnable[i] && size) {
            gl2.drawArrays(gl2.TRIANGLES, offset, size);
          }
          offset += size;
        }
      };
    }();
    proto.drawTickMarks = /* @__PURE__ */ function() {
      var DATA_SHIFT = [0, 0];
      var DATA_SCALE = [0, 0];
      var X_AXIS = [1, 0];
      var Y_AXIS = [0, 1];
      var SCR_OFFSET = [0, 0];
      var TICK_SCALE = [0, 0];
      return function() {
        var plot = this.plot;
        var vbo = this.vbo;
        var shader = this.tickShader;
        var ticks = this.ticks;
        var gl2 = plot.gl;
        var bounds = plot._tickBounds;
        var dataBox = plot.dataBox;
        var viewBox = plot.viewBox;
        var pixelRatio = plot.pixelRatio;
        var screenBox = plot.screenBox;
        var screenWidth = screenBox[2] - screenBox[0];
        var screenHeight = screenBox[3] - screenBox[1];
        var viewWidth = viewBox[2] - viewBox[0];
        var viewHeight = viewBox[3] - viewBox[1];
        for (var i = 0; i < 2; ++i) {
          var lo = bounds[i];
          var hi = bounds[i + 2];
          var boundScale = hi - lo;
          var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
          var dataWidth = dataBox[i + 2] - dataBox[i];
          DATA_SCALE[i] = 2 * boundScale / dataWidth;
          DATA_SHIFT[i] = 2 * (lo - dataCenter) / dataWidth;
        }
        DATA_SCALE[0] *= viewWidth / screenWidth;
        DATA_SHIFT[0] *= viewWidth / screenWidth;
        DATA_SCALE[1] *= viewHeight / screenHeight;
        DATA_SHIFT[1] *= viewHeight / screenHeight;
        shader.bind();
        vbo.bind();
        shader.attributes.dataCoord.pointer();
        var uniforms = shader.uniforms;
        uniforms.dataShift = DATA_SHIFT;
        uniforms.dataScale = DATA_SCALE;
        var tickMarkLength = plot.tickMarkLength;
        var tickMarkWidth = plot.tickMarkWidth;
        var tickMarkColor = plot.tickMarkColor;
        var xTicksOffset = 0;
        var yTicksOffset = ticks[0].length * 6;
        var xStart = Math.min(bsearch.ge(ticks[0], (dataBox[0] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);
        var xEnd = Math.min(bsearch.gt(ticks[0], (dataBox[2] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);
        var xOffset = xTicksOffset + 6 * xStart;
        var xCount = 6 * Math.max(0, xEnd - xStart);
        var yStart = Math.min(bsearch.ge(ticks[1], (dataBox[1] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);
        var yEnd = Math.min(bsearch.gt(ticks[1], (dataBox[3] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);
        var yOffset = yTicksOffset + 6 * yStart;
        var yCount = 6 * Math.max(0, yEnd - yStart);
        SCR_OFFSET[0] = 2 * (viewBox[0] - tickMarkLength[1]) / screenWidth - 1;
        SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1;
        TICK_SCALE[0] = tickMarkLength[1] * pixelRatio / screenWidth;
        TICK_SCALE[1] = tickMarkWidth[1] * pixelRatio / screenHeight;
        if (yCount) {
          uniforms.color = tickMarkColor[1];
          uniforms.tickScale = TICK_SCALE;
          uniforms.dataAxis = Y_AXIS;
          uniforms.screenOffset = SCR_OFFSET;
          gl2.drawArrays(gl2.TRIANGLES, yOffset, yCount);
        }
        SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1;
        SCR_OFFSET[1] = 2 * (viewBox[1] - tickMarkLength[0]) / screenHeight - 1;
        TICK_SCALE[0] = tickMarkWidth[0] * pixelRatio / screenWidth;
        TICK_SCALE[1] = tickMarkLength[0] * pixelRatio / screenHeight;
        if (xCount) {
          uniforms.color = tickMarkColor[0];
          uniforms.tickScale = TICK_SCALE;
          uniforms.dataAxis = X_AXIS;
          uniforms.screenOffset = SCR_OFFSET;
          gl2.drawArrays(gl2.TRIANGLES, xOffset, xCount);
        }
        SCR_OFFSET[0] = 2 * (viewBox[2] + tickMarkLength[3]) / screenWidth - 1;
        SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1;
        TICK_SCALE[0] = tickMarkLength[3] * pixelRatio / screenWidth;
        TICK_SCALE[1] = tickMarkWidth[3] * pixelRatio / screenHeight;
        if (yCount) {
          uniforms.color = tickMarkColor[3];
          uniforms.tickScale = TICK_SCALE;
          uniforms.dataAxis = Y_AXIS;
          uniforms.screenOffset = SCR_OFFSET;
          gl2.drawArrays(gl2.TRIANGLES, yOffset, yCount);
        }
        SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1;
        SCR_OFFSET[1] = 2 * (viewBox[3] + tickMarkLength[2]) / screenHeight - 1;
        TICK_SCALE[0] = tickMarkWidth[2] * pixelRatio / screenWidth;
        TICK_SCALE[1] = tickMarkLength[2] * pixelRatio / screenHeight;
        if (xCount) {
          uniforms.color = tickMarkColor[2];
          uniforms.tickScale = TICK_SCALE;
          uniforms.dataAxis = X_AXIS;
          uniforms.screenOffset = SCR_OFFSET;
          gl2.drawArrays(gl2.TRIANGLES, xOffset, xCount);
        }
      };
    }();
    proto.update = /* @__PURE__ */ function() {
      var OFFSET_X = [1, 1, -1, -1, 1, -1];
      var OFFSET_Y = [1, -1, 1, 1, -1, -1];
      return function(options) {
        var ticks = options.ticks;
        var bounds = options.bounds;
        var data = new Float32Array(6 * 3 * (ticks[0].length + ticks[1].length));
        var zeroLineEnable = this.plot.zeroLineEnable;
        var ptr = 0;
        var gridTicks = [[], []];
        for (var dim = 0; dim < 2; ++dim) {
          var localTicks = gridTicks[dim];
          var axisTicks = ticks[dim];
          var lo = bounds[dim];
          var hi = bounds[dim + 2];
          for (var i = 0; i < axisTicks.length; ++i) {
            var x = (axisTicks[i].x - lo) / (hi - lo);
            localTicks.push(x);
            for (var j = 0; j < 6; ++j) {
              data[ptr++] = x;
              data[ptr++] = OFFSET_X[j];
              data[ptr++] = OFFSET_Y[j];
            }
          }
        }
        this.ticks = gridTicks;
        this.vbo.update(data);
      };
    }();
    proto.dispose = function() {
      this.vbo.dispose();
      this.shader.dispose();
      this.tickShader.dispose();
    };
    function createGrid(plot) {
      var gl2 = plot.gl;
      var vbo = createBuffer(gl2);
      var shader = createShader(gl2, shaders.gridVert, shaders.gridFrag);
      var tickShader = createShader(gl2, shaders.tickVert, shaders.gridFrag);
      var grid = new Grid(plot, vbo, shader, tickShader);
      return grid;
    }
  }
});

// node_modules/ndarray-extract-contour/contour.js
var require_contour2 = __commonJS({
  "node_modules/ndarray-extract-contour/contour.js"(exports2, module2) {
    "use strict";
    var pool = require_pool();
    module2.exports = createSurfaceExtractor;
    var allFns = {
      "false,0,1": function surfaceProcedure(vertex, face, phase, mallocUint32, freeUint32) {
        return function extractContour0_1(a0, x0, x1, x2) {
          var s0 = a0.shape[0] | 0, s1 = a0.shape[1] | 0, d0 = a0.data, o0 = a0.offset | 0, t0_0 = a0.stride[0] | 0, t0_1 = a0.stride[1] | 0, p0 = o0, c0_0, d0_1 = -t0_0 | 0, c0_1 = 0, d0_2 = -t0_1 | 0, c0_2 = 0, d0_3 = -t0_0 - t0_1 | 0, c0_3 = 0, u0_0 = t0_0 | 0, u0_1 = t0_1 - t0_0 * s0 | 0, i0 = 0, i1 = 0, N = 0, Q = 2 * s0 | 0, P = mallocUint32(Q), V = mallocUint32(Q), X = 0, b0 = 0, e1 = -1 | 0, y1 = -1 | 0, b1 = 0, e2 = -s0 | 0, y2 = s0 | 0, b2 = 0, e3 = -s0 - 1 | 0, y3 = s0 - 1 | 0, b3 = 0, v0 = 0, T = 0;
          for (i0 = 0; i0 < s0; ++i0) {
            P[X++] = phase(d0[p0], x0, x1, x2);
            p0 += u0_0;
          }
          p0 += u0_1;
          if (s1 > 0) {
            i1 = 1;
            P[X++] = phase(d0[p0], x0, x1, x2);
            p0 += u0_0;
            if (s0 > 0) {
              i0 = 1;
              c0_0 = d0[p0];
              b0 = P[X] = phase(c0_0, x0, x1, x2);
              b1 = P[X + e1];
              b2 = P[X + e2];
              b3 = P[X + e3];
              if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                c0_1 = d0[p0 + d0_1];
                c0_2 = d0[p0 + d0_2];
                c0_3 = d0[p0 + d0_3];
                vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                v0 = V[X] = N++;
              }
              X += 1;
              p0 += u0_0;
              for (i0 = 2; i0 < s0; ++i0) {
                c0_0 = d0[p0];
                b0 = P[X] = phase(c0_0, x0, x1, x2);
                b1 = P[X + e1];
                b2 = P[X + e2];
                b3 = P[X + e3];
                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                  c0_1 = d0[p0 + d0_1];
                  c0_2 = d0[p0 + d0_2];
                  c0_3 = d0[p0 + d0_3];
                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                  v0 = V[X] = N++;
                  if (b3 !== b1) {
                    face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);
                  }
                }
                X += 1;
                p0 += u0_0;
              }
            }
            p0 += u0_1;
            X = 0;
            T = e1;
            e1 = y1;
            y1 = T;
            T = e2;
            e2 = y2;
            y2 = T;
            T = e3;
            e3 = y3;
            y3 = T;
            for (i1 = 2; i1 < s1; ++i1) {
              P[X++] = phase(d0[p0], x0, x1, x2);
              p0 += u0_0;
              if (s0 > 0) {
                i0 = 1;
                c0_0 = d0[p0];
                b0 = P[X] = phase(c0_0, x0, x1, x2);
                b1 = P[X + e1];
                b2 = P[X + e2];
                b3 = P[X + e3];
                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                  c0_1 = d0[p0 + d0_1];
                  c0_2 = d0[p0 + d0_2];
                  c0_3 = d0[p0 + d0_3];
                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                  v0 = V[X] = N++;
                  if (b3 !== b2) {
                    face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);
                  }
                }
                X += 1;
                p0 += u0_0;
                for (i0 = 2; i0 < s0; ++i0) {
                  c0_0 = d0[p0];
                  b0 = P[X] = phase(c0_0, x0, x1, x2);
                  b1 = P[X + e1];
                  b2 = P[X + e2];
                  b3 = P[X + e3];
                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                    c0_1 = d0[p0 + d0_1];
                    c0_2 = d0[p0 + d0_2];
                    c0_3 = d0[p0 + d0_3];
                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                    v0 = V[X] = N++;
                    if (b3 !== b2) {
                      face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);
                    }
                    if (b3 !== b1) {
                      face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);
                    }
                  }
                  X += 1;
                  p0 += u0_0;
                }
              }
              if (i1 & 1) {
                X = 0;
              }
              T = e1;
              e1 = y1;
              y1 = T;
              T = e2;
              e2 = y2;
              y2 = T;
              T = e3;
              e3 = y3;
              y3 = T;
              p0 += u0_1;
            }
          }
          freeUint32(V);
          freeUint32(P);
        };
      },
      "false,1,0": function anonymous(vertex, face, phase, mallocUint32, freeUint32) {
        return function extractContour1_0(a0, x0, x1, x2) {
          var s0 = a0.shape[0] | 0, s1 = a0.shape[1] | 0, d0 = a0.data, o0 = a0.offset | 0, t0_0 = a0.stride[0] | 0, t0_1 = a0.stride[1] | 0, p0 = o0, c0_0, d0_1 = -t0_0 | 0, c0_1 = 0, d0_2 = -t0_1 | 0, c0_2 = 0, d0_3 = -t0_0 - t0_1 | 0, c0_3 = 0, u0_1 = t0_1 | 0, u0_0 = t0_0 - t0_1 * s1 | 0, i0 = 0, i1 = 0, N = 0, Q = 2 * s1 | 0, P = mallocUint32(Q), V = mallocUint32(Q), X = 0, b0 = 0, e2 = -1 | 0, y2 = -1 | 0, b2 = 0, e1 = -s1 | 0, y1 = s1 | 0, b1 = 0, e3 = -s1 - 1 | 0, y3 = s1 - 1 | 0, b3 = 0, v0 = 0, T = 0;
          for (i1 = 0; i1 < s1; ++i1) {
            P[X++] = phase(d0[p0], x0, x1, x2);
            p0 += u0_1;
          }
          p0 += u0_0;
          if (s0 > 0) {
            i0 = 1;
            P[X++] = phase(d0[p0], x0, x1, x2);
            p0 += u0_1;
            if (s1 > 0) {
              i1 = 1;
              c0_0 = d0[p0];
              b0 = P[X] = phase(c0_0, x0, x1, x2);
              b1 = P[X + e1];
              b2 = P[X + e2];
              b3 = P[X + e3];
              if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                c0_1 = d0[p0 + d0_1];
                c0_2 = d0[p0 + d0_2];
                c0_3 = d0[p0 + d0_3];
                vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                v0 = V[X] = N++;
              }
              X += 1;
              p0 += u0_1;
              for (i1 = 2; i1 < s1; ++i1) {
                c0_0 = d0[p0];
                b0 = P[X] = phase(c0_0, x0, x1, x2);
                b1 = P[X + e1];
                b2 = P[X + e2];
                b3 = P[X + e3];
                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                  c0_1 = d0[p0 + d0_1];
                  c0_2 = d0[p0 + d0_2];
                  c0_3 = d0[p0 + d0_3];
                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                  v0 = V[X] = N++;
                  if (b3 !== b2) {
                    face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);
                  }
                }
                X += 1;
                p0 += u0_1;
              }
            }
            p0 += u0_0;
            X = 0;
            T = e1;
            e1 = y1;
            y1 = T;
            T = e2;
            e2 = y2;
            y2 = T;
            T = e3;
            e3 = y3;
            y3 = T;
            for (i0 = 2; i0 < s0; ++i0) {
              P[X++] = phase(d0[p0], x0, x1, x2);
              p0 += u0_1;
              if (s1 > 0) {
                i1 = 1;
                c0_0 = d0[p0];
                b0 = P[X] = phase(c0_0, x0, x1, x2);
                b1 = P[X + e1];
                b2 = P[X + e2];
                b3 = P[X + e3];
                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                  c0_1 = d0[p0 + d0_1];
                  c0_2 = d0[p0 + d0_2];
                  c0_3 = d0[p0 + d0_3];
                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                  v0 = V[X] = N++;
                  if (b3 !== b1) {
                    face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);
                  }
                }
                X += 1;
                p0 += u0_1;
                for (i1 = 2; i1 < s1; ++i1) {
                  c0_0 = d0[p0];
                  b0 = P[X] = phase(c0_0, x0, x1, x2);
                  b1 = P[X + e1];
                  b2 = P[X + e2];
                  b3 = P[X + e3];
                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {
                    c0_1 = d0[p0 + d0_1];
                    c0_2 = d0[p0 + d0_2];
                    c0_3 = d0[p0 + d0_3];
                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);
                    v0 = V[X] = N++;
                    if (b3 !== b2) {
                      face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);
                    }
                    if (b3 !== b1) {
                      face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);
                    }
                  }
                  X += 1;
                  p0 += u0_1;
                }
              }
              if (i0 & 1) {
                X = 0;
              }
              T = e1;
              e1 = y1;
              y1 = T;
              T = e2;
              e2 = y2;
              y2 = T;
              T = e3;
              e3 = y3;
              y3 = T;
              p0 += u0_0;
            }
          }
          freeUint32(V);
          freeUint32(P);
        };
      }
    };
    function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {
      var key = [typesig, order].join(",");
      var proc = allFns[key];
      return proc(
        vertexFunc,
        faceFunc,
        phaseFunc,
        pool.mallocUint32,
        pool.freeUint32
      );
    }
    function createSurfaceExtractor(args) {
      function error(msg) {
        throw new Error("ndarray-extract-contour: " + msg);
      }
      if (typeof args !== "object") {
        error("Must specify arguments");
      }
      var order = args.order;
      if (!Array.isArray(order)) {
        error("Must specify order");
      }
      var arrays = args.arrayArguments || 1;
      if (arrays < 1) {
        error("Must have at least one array argument");
      }
      var scalars = args.scalarArguments || 0;
      if (scalars < 0) {
        error("Scalar arg count must be > 0");
      }
      if (typeof args.vertex !== "function") {
        error("Must specify vertex creation function");
      }
      if (typeof args.cell !== "function") {
        error("Must specify cell creation function");
      }
      if (typeof args.phase !== "function") {
        error("Must specify phase function");
      }
      var getters = args.getters || [];
      var typesig = new Array(arrays);
      for (var i = 0; i < arrays; ++i) {
        if (getters.indexOf(i) >= 0) {
          typesig[i] = true;
        } else {
          typesig[i] = false;
        }
      }
      return compileSurfaceProcedure(
        args.vertex,
        args.cell,
        args.phase,
        scalars,
        order,
        typesig
      );
    }
  }
});

// node_modules/zero-crossings/lib/zc-core.js
var require_zc_core = __commonJS({
  "node_modules/zero-crossings/lib/zc-core.js"(exports2, module2) {
    "use strict";
    function CWiseOp() {
      return function(SS, a0, t0, p0, Y0, Y1) {
        var s0 = SS[0], t0p0 = t0[0], index = [0], q0 = t0p0;
        p0 |= 0;
        var i0 = 0, d0s0 = t0p0;
        for (i0 = 0; i0 < s0; ++i0) {
          {
            var da = a0[p0] - Y1;
            var db = a0[p0 + q0] - Y1;
            if (da >= 0 !== db >= 0) {
              Y0.push(index[0] + 0.5 + 0.5 * (da + db) / (da - db));
            }
          }
          p0 += d0s0;
          ++index[0];
        }
      };
    }
    function generateCWiseOp() {
      return CWiseOp();
    }
    var compile = generateCWiseOp;
    function thunk(compile2) {
      var CACHED = {};
      return function zeroCrossings_cwise_thunk(array0, scalar2, scalar3) {
        var t0 = array0.dtype, r0 = array0.order, type = [t0, r0.join()].join(), proc = CACHED[type];
        if (!proc) {
          CACHED[type] = proc = compile2([t0, r0]);
        }
        return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar2, scalar3);
      };
    }
    function createThunk(proc) {
      return thunk(compile.bind(void 0, proc));
    }
    function compileCwise(user_args) {
      return createThunk({
        funcName: user_args.funcName
      });
    }
    module2.exports = compileCwise({
      funcName: "zeroCrossings"
    });
  }
});

// node_modules/zero-crossings/zc.js
var require_zc = __commonJS({
  "node_modules/zero-crossings/zc.js"(exports2, module2) {
    "use strict";
    module2.exports = findZeroCrossings;
    var core = require_zc_core();
    function findZeroCrossings(array, level) {
      var cross = [];
      level = +level || 0;
      core(array.hi(array.shape[0] - 1), cross, level);
      return cross;
    }
  }
});

// node_modules/surface-nets/surfacenets.js
var require_surfacenets = __commonJS({
  "node_modules/surface-nets/surfacenets.js"(exports2, module2) {
    "use strict";
    module2.exports = surfaceNets;
    var generateContourExtractor = require_contour2();
    var zeroCrossings = require_zc();
    var allFns = {
      "2d": function(genContour, order, dtype) {
        var contour = genContour({
          order,
          scalarArguments: 3,
          getters: dtype === "generic" ? [0] : void 0,
          phase: function phaseFunc(p, a, b, c) {
            return p > c | 0;
          },
          vertex: function vertexFunc(d0, d1, v0, v1, v2, v3, p0, p1, p2, p3, a, b, c) {
            var m = (p0 << 0) + (p1 << 1) + (p2 << 2) + (p3 << 3) | 0;
            if (m === 0 || m === 15) {
              return;
            }
            switch (m) {
              case 0:
                a.push([d0 - 0.5, d1 - 0.5]);
                break;
              case 1:
                a.push([d0 - 0.25 - 0.25 * (v1 + v0 - 2 * c) / (v0 - v1), d1 - 0.25 - 0.25 * (v2 + v0 - 2 * c) / (v0 - v2)]);
                break;
              case 2:
                a.push([d0 - 0.75 - 0.25 * (-v1 - v0 + 2 * c) / (v1 - v0), d1 - 0.25 - 0.25 * (v3 + v1 - 2 * c) / (v1 - v3)]);
                break;
              case 3:
                a.push([d0 - 0.5, d1 - 0.5 - 0.5 * (v2 + v0 + v3 + v1 - 4 * c) / (v0 - v2 + v1 - v3)]);
                break;
              case 4:
                a.push([d0 - 0.25 - 0.25 * (v3 + v2 - 2 * c) / (v2 - v3), d1 - 0.75 - 0.25 * (-v2 - v0 + 2 * c) / (v2 - v0)]);
                break;
              case 5:
                a.push([d0 - 0.5 - 0.5 * (v1 + v0 + v3 + v2 - 4 * c) / (v0 - v1 + v2 - v3), d1 - 0.5]);
                break;
              case 6:
                a.push([d0 - 0.5 - 0.25 * (-v1 - v0 + v3 + v2) / (v1 - v0 + v2 - v3), d1 - 0.5 - 0.25 * (-v2 - v0 + v3 + v1) / (v2 - v0 + v1 - v3)]);
                break;
              case 7:
                a.push([d0 - 0.75 - 0.25 * (v3 + v2 - 2 * c) / (v2 - v3), d1 - 0.75 - 0.25 * (v3 + v1 - 2 * c) / (v1 - v3)]);
                break;
              case 8:
                a.push([d0 - 0.75 - 0.25 * (-v3 - v2 + 2 * c) / (v3 - v2), d1 - 0.75 - 0.25 * (-v3 - v1 + 2 * c) / (v3 - v1)]);
                break;
              case 9:
                a.push([d0 - 0.5 - 0.25 * (v1 + v0 + -v3 - v2) / (v0 - v1 + v3 - v2), d1 - 0.5 - 0.25 * (v2 + v0 + -v3 - v1) / (v0 - v2 + v3 - v1)]);
                break;
              case 10:
                a.push([d0 - 0.5 - 0.5 * (-v1 - v0 + -v3 - v2 + 4 * c) / (v1 - v0 + v3 - v2), d1 - 0.5]);
                break;
              case 11:
                a.push([d0 - 0.25 - 0.25 * (-v3 - v2 + 2 * c) / (v3 - v2), d1 - 0.75 - 0.25 * (v2 + v0 - 2 * c) / (v0 - v2)]);
                break;
              case 12:
                a.push([d0 - 0.5, d1 - 0.5 - 0.5 * (-v2 - v0 + -v3 - v1 + 4 * c) / (v2 - v0 + v3 - v1)]);
                break;
              case 13:
                a.push([d0 - 0.75 - 0.25 * (v1 + v0 - 2 * c) / (v0 - v1), d1 - 0.25 - 0.25 * (-v3 - v1 + 2 * c) / (v3 - v1)]);
                break;
              case 14:
                a.push([d0 - 0.25 - 0.25 * (-v1 - v0 + 2 * c) / (v1 - v0), d1 - 0.25 - 0.25 * (-v2 - v0 + 2 * c) / (v2 - v0)]);
                break;
              case 15:
                a.push([d0 - 0.5, d1 - 0.5]);
                break;
            }
          },
          cell: function cellFunc(v0, v1, c0, c1, p0, p1, a, b, c) {
            if (p0) {
              b.push([v0, v1]);
            } else {
              b.push([v1, v0]);
            }
          }
        });
        return function(array, level) {
          var verts = [], cells = [];
          contour(array, verts, cells, level);
          return { positions: verts, cells };
        };
      }
    };
    function buildSurfaceNets(order, dtype) {
      var inKey = order.length + "d";
      var fn = allFns[inKey];
      if (fn) return fn(generateContourExtractor, order, dtype);
    }
    function mesh1D(array, level) {
      var zc = zeroCrossings(array, level);
      var n = zc.length;
      var npos = new Array(n);
      var ncel = new Array(n);
      for (var i = 0; i < n; ++i) {
        npos[i] = [zc[i]];
        ncel[i] = [i];
      }
      return {
        positions: npos,
        cells: ncel
      };
    }
    var CACHE = {};
    function surfaceNets(array, level) {
      if (array.dimension <= 0) {
        return { positions: [], cells: [] };
      } else if (array.dimension === 1) {
        return mesh1D(array, level);
      }
      var typesig = array.order.join() + "-" + array.dtype;
      var proc = CACHE[typesig];
      var level = +level || 0;
      if (!proc) {
        proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype);
      }
      return proc(array, level);
    }
  }
});

// node_modules/simplify-planar-graph/node_modules/bit-twiddle/twiddle.js
var require_twiddle2 = __commonJS({
  "node_modules/simplify-planar-graph/node_modules/bit-twiddle/twiddle.js"(exports2) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports2.INT_BITS = INT_BITS;
    exports2.INT_MAX = 2147483647;
    exports2.INT_MIN = -1 << INT_BITS - 1;
    exports2.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports2.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports2.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports2.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports2.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports2.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports2.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports2.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    }
    exports2.countTrailingZeros = countTrailingZeros;
    exports2.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports2.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports2.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports2.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports2.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports2.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports2.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports2.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports2.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// node_modules/simplify-planar-graph/node_modules/union-find/index.js
var require_union_find2 = __commonJS({
  "node_modules/simplify-planar-graph/node_modules/union-find/index.js"(exports2, module2) {
    "use strict";
    "use restrict";
    module2.exports = UnionFind;
    function UnionFind(count) {
      this.roots = new Array(count);
      this.ranks = new Array(count);
      for (var i = 0; i < count; ++i) {
        this.roots[i] = i;
        this.ranks[i] = 0;
      }
    }
    UnionFind.prototype.length = function() {
      return this.roots.length;
    };
    UnionFind.prototype.makeSet = function() {
      var n = this.roots.length;
      this.roots.push(n);
      this.ranks.push(0);
      return n;
    };
    UnionFind.prototype.find = function(x) {
      var roots = this.roots;
      while (roots[x] !== x) {
        var y = roots[x];
        roots[x] = roots[y];
        x = y;
      }
      return x;
    };
    UnionFind.prototype.link = function(x, y) {
      var xr = this.find(x), yr = this.find(y);
      if (xr === yr) {
        return;
      }
      var ranks = this.ranks, roots = this.roots, xd = ranks[xr], yd = ranks[yr];
      if (xd < yd) {
        roots[xr] = yr;
      } else if (yd < xd) {
        roots[yr] = xr;
      } else {
        roots[yr] = xr;
        ++ranks[xr];
      }
    };
  }
});

// node_modules/simplify-planar-graph/node_modules/simplicial-complex/topology.js
var require_topology2 = __commonJS({
  "node_modules/simplify-planar-graph/node_modules/simplicial-complex/topology.js"(exports2) {
    "use strict";
    "use restrict";
    var bits = require_twiddle2();
    var UnionFind = require_union_find2();
    function dimension(cells) {
      var d = 0, max = Math.max;
      for (var i = 0, il = cells.length; i < il; ++i) {
        d = max(d, cells[i].length);
      }
      return d - 1;
    }
    exports2.dimension = dimension;
    function countVertices(cells) {
      var vc = -1, max = Math.max;
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i];
        for (var j = 0, jl = c.length; j < jl; ++j) {
          vc = max(vc, c[j]);
        }
      }
      return vc + 1;
    }
    exports2.countVertices = countVertices;
    function cloneCells(cells) {
      var ncells = new Array(cells.length);
      for (var i = 0, il = cells.length; i < il; ++i) {
        ncells[i] = cells[i].slice(0);
      }
      return ncells;
    }
    exports2.cloneCells = cloneCells;
    function compareCells(a, b) {
      var n = a.length, t = a.length - b.length, min = Math.min;
      if (t) {
        return t;
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          return a[0] - b[0];
        case 2:
          var d = a[0] + a[1] - b[0] - b[1];
          if (d) {
            return d;
          }
          return min(a[0], a[1]) - min(b[0], b[1]);
        case 3:
          var l1 = a[0] + a[1], m1 = b[0] + b[1];
          d = l1 + a[2] - (m1 + b[2]);
          if (d) {
            return d;
          }
          var l0 = min(a[0], a[1]), m0 = min(b[0], b[1]), d = min(l0, a[2]) - min(m0, b[2]);
          if (d) {
            return d;
          }
          return min(l0 + a[2], l1) - min(m0 + b[2], m1);
        //TODO: Maybe optimize n=4 as well?
        default:
          var as = a.slice(0);
          as.sort();
          var bs = b.slice(0);
          bs.sort();
          for (var i = 0; i < n; ++i) {
            t = as[i] - bs[i];
            if (t) {
              return t;
            }
          }
          return 0;
      }
    }
    exports2.compareCells = compareCells;
    function compareZipped(a, b) {
      return compareCells(a[0], b[0]);
    }
    function normalize(cells, attr) {
      if (attr) {
        var len = cells.length;
        var zipped = new Array(len);
        for (var i = 0; i < len; ++i) {
          zipped[i] = [cells[i], attr[i]];
        }
        zipped.sort(compareZipped);
        for (var i = 0; i < len; ++i) {
          cells[i] = zipped[i][0];
          attr[i] = zipped[i][1];
        }
        return cells;
      } else {
        cells.sort(compareCells);
        return cells;
      }
    }
    exports2.normalize = normalize;
    function unique(cells) {
      if (cells.length === 0) {
        return [];
      }
      var ptr = 1, len = cells.length;
      for (var i = 1; i < len; ++i) {
        var a = cells[i];
        if (compareCells(a, cells[i - 1])) {
          if (i === ptr) {
            ptr++;
            continue;
          }
          cells[ptr++] = a;
        }
      }
      cells.length = ptr;
      return cells;
    }
    exports2.unique = unique;
    function findCell(cells, c) {
      var lo = 0, hi = cells.length - 1, r = -1;
      while (lo <= hi) {
        var mid = lo + hi >> 1, s = compareCells(cells[mid], c);
        if (s <= 0) {
          if (s === 0) {
            r = mid;
          }
          lo = mid + 1;
        } else if (s > 0) {
          hi = mid - 1;
        }
      }
      return r;
    }
    exports2.findCell = findCell;
    function incidence(from_cells, to_cells) {
      var index = new Array(from_cells.length);
      for (var i = 0, il = index.length; i < il; ++i) {
        index[i] = [];
      }
      var b = [];
      for (var i = 0, n = to_cells.length; i < n; ++i) {
        var c = to_cells[i];
        var cl = c.length;
        for (var k = 1, kn = 1 << cl; k < kn; ++k) {
          b.length = bits.popCount(k);
          var l = 0;
          for (var j = 0; j < cl; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          var idx = findCell(from_cells, b);
          if (idx < 0) {
            continue;
          }
          while (true) {
            index[idx++].push(i);
            if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
              break;
            }
          }
        }
      }
      return index;
    }
    exports2.incidence = incidence;
    function dual(cells, vertex_count) {
      if (!vertex_count) {
        return incidence(unique(skeleton(cells, 0)), cells, 0);
      }
      var res = new Array(vertex_count);
      for (var i = 0; i < vertex_count; ++i) {
        res[i] = [];
      }
      for (var i = 0, len = cells.length; i < len; ++i) {
        var c = cells[i];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          res[c[j]].push(i);
        }
      }
      return res;
    }
    exports2.dual = dual;
    function explode(cells) {
      var result = [];
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i], cl = c.length | 0;
        for (var j = 1, jl = 1 << cl; j < jl; ++j) {
          var b = [];
          for (var k = 0; k < cl; ++k) {
            if (j >>> k & 1) {
              b.push(c[k]);
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports2.explode = explode;
    function skeleton(cells, n) {
      if (n < 0) {
        return [];
      }
      var result = [], k0 = (1 << n + 1) - 1;
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {
          var b = new Array(n + 1), l = 0;
          for (var j = 0; j < c.length; ++j) {
            if (k & 1 << j) {
              b[l++] = c[j];
            }
          }
          result.push(b);
        }
      }
      return normalize(result);
    }
    exports2.skeleton = skeleton;
    function boundary(cells) {
      var res = [];
      for (var i = 0, il = cells.length; i < il; ++i) {
        var c = cells[i];
        for (var j = 0, cl = c.length; j < cl; ++j) {
          var b = new Array(c.length - 1);
          for (var k = 0, l = 0; k < cl; ++k) {
            if (k !== j) {
              b[l++] = c[k];
            }
          }
          res.push(b);
        }
      }
      return normalize(res);
    }
    exports2.boundary = boundary;
    function connectedComponents_dense(cells, vertex_count) {
      var labels = new UnionFind(vertex_count);
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var j = 0; j < c.length; ++j) {
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(c[j], c[k]);
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i = 0; i < component_labels.length; ++i) {
        component_labels[i] = -1;
      }
      for (var i = 0; i < cells.length; ++i) {
        var l = labels.find(cells[i][0]);
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i].slice(0));
        }
      }
      return components;
    }
    function connectedComponents_sparse(cells) {
      var vertices = unique(normalize(skeleton(cells, 0))), labels = new UnionFind(vertices.length);
      for (var i = 0; i < cells.length; ++i) {
        var c = cells[i];
        for (var j = 0; j < c.length; ++j) {
          var vj = findCell(vertices, [c[j]]);
          for (var k = j + 1; k < c.length; ++k) {
            labels.link(vj, findCell(vertices, [c[k]]));
          }
        }
      }
      var components = [], component_labels = labels.ranks;
      for (var i = 0; i < component_labels.length; ++i) {
        component_labels[i] = -1;
      }
      for (var i = 0; i < cells.length; ++i) {
        var l = labels.find(findCell(vertices, [cells[i][0]]));
        if (component_labels[l] < 0) {
          component_labels[l] = components.length;
          components.push([cells[i].slice(0)]);
        } else {
          components[component_labels[l]].push(cells[i].slice(0));
        }
      }
      return components;
    }
    function connectedComponents(cells, vertex_count) {
      if (vertex_count) {
        return connectedComponents_dense(cells, vertex_count);
      }
      return connectedComponents_sparse(cells);
    }
    exports2.connectedComponents = connectedComponents;
  }
});

// node_modules/simplify-planar-graph/simplify.js
var require_simplify = __commonJS({
  "node_modules/simplify-planar-graph/simplify.js"(exports2, module2) {
    "use strict";
    module2.exports = simplifyPolygon;
    var orient = require_orientation();
    var sc = require_topology2();
    function errorWeight(base, a, b) {
      var area = Math.abs(orient(base, a, b));
      var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
      return area / perim;
    }
    function simplifyPolygon(cells, positions, minArea) {
      var n = positions.length;
      var nc = cells.length;
      var inv = new Array(n);
      var outv = new Array(n);
      var weights = new Array(n);
      var dead = new Array(n);
      for (var i = 0; i < n; ++i) {
        inv[i] = outv[i] = -1;
        weights[i] = Infinity;
        dead[i] = false;
      }
      for (var i = 0; i < nc; ++i) {
        var c = cells[i];
        if (c.length !== 2) {
          throw new Error("Input must be a graph");
        }
        var s = c[1];
        var t = c[0];
        if (outv[t] !== -1) {
          outv[t] = -2;
        } else {
          outv[t] = s;
        }
        if (inv[s] !== -1) {
          inv[s] = -2;
        } else {
          inv[s] = t;
        }
      }
      function computeWeight(i2) {
        if (dead[i2]) {
          return Infinity;
        }
        var s2 = inv[i2];
        var t2 = outv[i2];
        if (s2 < 0 || t2 < 0) {
          return Infinity;
        } else {
          return errorWeight(positions[i2], positions[s2], positions[t2]);
        }
      }
      function heapSwap(i2, j) {
        var a = heap[i2];
        var b = heap[j];
        heap[i2] = b;
        heap[j] = a;
        index[a] = j;
        index[b] = i2;
      }
      function heapWeight(i2) {
        return weights[heap[i2]];
      }
      function heapParent(i2) {
        if (i2 & 1) {
          return i2 - 1 >> 1;
        }
        return (i2 >> 1) - 1;
      }
      function heapDown(i2) {
        var w2 = heapWeight(i2);
        while (true) {
          var tw = w2;
          var left = 2 * i2 + 1;
          var right = 2 * (i2 + 1);
          var next = i2;
          if (left < heapCount) {
            var lw = heapWeight(left);
            if (lw < tw) {
              next = left;
              tw = lw;
            }
          }
          if (right < heapCount) {
            var rw = heapWeight(right);
            if (rw < tw) {
              next = right;
            }
          }
          if (next === i2) {
            return i2;
          }
          heapSwap(i2, next);
          i2 = next;
        }
      }
      function heapUp(i2) {
        var w2 = heapWeight(i2);
        while (i2 > 0) {
          var parent = heapParent(i2);
          if (parent >= 0) {
            var pw = heapWeight(parent);
            if (w2 < pw) {
              heapSwap(i2, parent);
              i2 = parent;
              continue;
            }
          }
          return i2;
        }
      }
      function heapPop() {
        if (heapCount > 0) {
          var head = heap[0];
          heapSwap(0, heapCount - 1);
          heapCount -= 1;
          heapDown(0);
          return head;
        }
        return -1;
      }
      function heapUpdate(i2, w2) {
        var a = heap[i2];
        if (weights[a] === w2) {
          return i2;
        }
        weights[a] = -Infinity;
        heapUp(i2);
        heapPop();
        weights[a] = w2;
        heapCount += 1;
        return heapUp(heapCount - 1);
      }
      function kill(i2) {
        if (dead[i2]) {
          return;
        }
        dead[i2] = true;
        var s2 = inv[i2];
        var t2 = outv[i2];
        if (inv[t2] >= 0) {
          inv[t2] = s2;
        }
        if (outv[s2] >= 0) {
          outv[s2] = t2;
        }
        if (index[s2] >= 0) {
          heapUpdate(index[s2], computeWeight(s2));
        }
        if (index[t2] >= 0) {
          heapUpdate(index[t2], computeWeight(t2));
        }
      }
      var heap = [];
      var index = new Array(n);
      for (var i = 0; i < n; ++i) {
        var w = weights[i] = computeWeight(i);
        if (w < Infinity) {
          index[i] = heap.length;
          heap.push(i);
        } else {
          index[i] = -1;
        }
      }
      var heapCount = heap.length;
      for (var i = heapCount >> 1; i >= 0; --i) {
        heapDown(i);
      }
      while (true) {
        var hmin = heapPop();
        if (hmin < 0 || weights[hmin] > minArea) {
          break;
        }
        kill(hmin);
      }
      var npositions = [];
      for (var i = 0; i < n; ++i) {
        if (!dead[i]) {
          index[i] = npositions.length;
          npositions.push(positions[i].slice());
        }
      }
      var nv = npositions.length;
      function tortoiseHare(seq, start) {
        if (seq[start] < 0) {
          return start;
        }
        var t2 = start;
        var h = start;
        do {
          var nh = seq[h];
          if (!dead[h] || nh < 0 || nh === h) {
            break;
          }
          h = nh;
          nh = seq[h];
          if (!dead[h] || nh < 0 || nh === h) {
            break;
          }
          h = nh;
          t2 = seq[t2];
        } while (t2 !== h);
        for (var v = start; v !== h; v = seq[v]) {
          seq[v] = h;
        }
        return h;
      }
      var ncells = [];
      cells.forEach(function(c2) {
        var tin = tortoiseHare(inv, c2[0]);
        var tout = tortoiseHare(outv, c2[1]);
        if (tin >= 0 && tout >= 0 && tin !== tout) {
          var cin = index[tin];
          var cout = index[tout];
          if (cin !== cout) {
            ncells.push([cin, cout]);
          }
        }
      });
      sc.unique(sc.normalize(ncells));
      return {
        positions: npositions,
        edges: ncells
      };
    }
  }
});

// node_modules/box-intersect/lib/sort.js
var require_sort2 = __commonJS({
  "node_modules/box-intersect/lib/sort.js"(exports2, module2) {
    "use strict";
    module2.exports = wrapper;
    var INSERT_SORT_CUTOFF = 32;
    function wrapper(data, n0) {
      if (n0 <= 4 * INSERT_SORT_CUTOFF) {
        insertionSort(0, n0 - 1, data);
      } else {
        quickSort(0, n0 - 1, data);
      }
    }
    function insertionSort(left, right, data) {
      var ptr = 2 * (left + 1);
      for (var i = left + 1; i <= right; ++i) {
        var a = data[ptr++];
        var b = data[ptr++];
        var j = i;
        var jptr = ptr - 2;
        while (j-- > left) {
          var x = data[jptr - 2];
          var y = data[jptr - 1];
          if (x < a) {
            break;
          } else if (x === a && y < b) {
            break;
          }
          data[jptr] = x;
          data[jptr + 1] = y;
          jptr -= 2;
        }
        data[jptr] = a;
        data[jptr + 1] = b;
      }
    }
    function swap(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = x;
      data[j + 1] = y;
    }
    function move(i, j, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[i + 1] = data[j + 1];
    }
    function rotate(i, j, k, data) {
      i *= 2;
      j *= 2;
      k *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = data[k];
      data[j + 1] = data[k + 1];
      data[k] = x;
      data[k + 1] = y;
    }
    function shufflePivot(i, j, px, py, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[j] = px;
      data[i + 1] = data[j + 1];
      data[j + 1] = py;
    }
    function compare(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i], y = data[j];
      if (x < y) {
        return false;
      } else if (x === y) {
        return data[i + 1] > data[j + 1];
      }
      return true;
    }
    function comparePivot(i, y, b, data) {
      i *= 2;
      var x = data[i];
      if (x < y) {
        return true;
      } else if (x === y) {
        return data[i + 1] < b;
      }
      return false;
    }
    function quickSort(left, right, data) {
      var sixth = (right - left + 1) / 6 | 0, index1 = left + sixth, index5 = right - sixth, index3 = left + right >> 1, index2 = index3 - sixth, index4 = index3 + sixth, el1 = index1, el2 = index2, el3 = index3, el4 = index4, el5 = index5, less = left + 1, great = right - 1, tmp = 0;
      if (compare(el1, el2, data)) {
        tmp = el1;
        el1 = el2;
        el2 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      if (compare(el1, el3, data)) {
        tmp = el1;
        el1 = el3;
        el3 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el1, el4, data)) {
        tmp = el1;
        el1 = el4;
        el4 = tmp;
      }
      if (compare(el3, el4, data)) {
        tmp = el3;
        el3 = el4;
        el4 = tmp;
      }
      if (compare(el2, el5, data)) {
        tmp = el2;
        el2 = el5;
        el5 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      var pivot1X = data[2 * el2];
      var pivot1Y = data[2 * el2 + 1];
      var pivot2X = data[2 * el4];
      var pivot2Y = data[2 * el4 + 1];
      var ptr0 = 2 * el1;
      var ptr2 = 2 * el3;
      var ptr4 = 2 * el5;
      var ptr5 = 2 * index1;
      var ptr6 = 2 * index3;
      var ptr7 = 2 * index5;
      for (var i1 = 0; i1 < 2; ++i1) {
        var x = data[ptr0 + i1];
        var y = data[ptr2 + i1];
        var z = data[ptr4 + i1];
        data[ptr5 + i1] = x;
        data[ptr6 + i1] = y;
        data[ptr7 + i1] = z;
      }
      move(index2, left, data);
      move(index4, right, data);
      for (var k = less; k <= great; ++k) {
        if (comparePivot(k, pivot1X, pivot1Y, data)) {
          if (k !== less) {
            swap(k, less, data);
          }
          ++less;
        } else {
          if (!comparePivot(k, pivot2X, pivot2Y, data)) {
            while (true) {
              if (!comparePivot(great, pivot2X, pivot2Y, data)) {
                if (--great < k) {
                  break;
                }
                continue;
              } else {
                if (comparePivot(great, pivot1X, pivot1Y, data)) {
                  rotate(k, less, great, data);
                  ++less;
                  --great;
                } else {
                  swap(k, great, data);
                  --great;
                }
                break;
              }
            }
          }
        }
      }
      shufflePivot(left, less - 1, pivot1X, pivot1Y, data);
      shufflePivot(right, great + 1, pivot2X, pivot2Y, data);
      if (less - 2 - left <= INSERT_SORT_CUTOFF) {
        insertionSort(left, less - 2, data);
      } else {
        quickSort(left, less - 2, data);
      }
      if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
        insertionSort(great + 2, right, data);
      } else {
        quickSort(great + 2, right, data);
      }
      if (great - less <= INSERT_SORT_CUTOFF) {
        insertionSort(less, great, data);
      } else {
        quickSort(less, great, data);
      }
    }
  }
});

// node_modules/box-intersect/lib/sweep.js
var require_sweep = __commonJS({
  "node_modules/box-intersect/lib/sweep.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      init: sqInit,
      sweepBipartite,
      sweepComplete,
      scanBipartite,
      scanComplete
    };
    var pool = require_pool();
    var bits = require_twiddle();
    var isort = require_sort2();
    var BLUE_FLAG = 1 << 28;
    var INIT_CAPACITY = 1024;
    var RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8);
    function sqInit(count) {
      var rcount = bits.nextPow2(count);
      if (RED_SWEEP_QUEUE.length < rcount) {
        pool.free(RED_SWEEP_QUEUE);
        RED_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (RED_SWEEP_INDEX.length < rcount) {
        pool.free(RED_SWEEP_INDEX);
        RED_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_QUEUE.length < rcount) {
        pool.free(BLUE_SWEEP_QUEUE);
        BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_INDEX.length < rcount) {
        pool.free(BLUE_SWEEP_INDEX);
        BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_QUEUE.length < rcount) {
        pool.free(COMMON_SWEEP_QUEUE);
        COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_INDEX.length < rcount) {
        pool.free(COMMON_SWEEP_INDEX);
        COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      var eventLength = 8 * rcount;
      if (SWEEP_EVENTS.length < eventLength) {
        pool.free(SWEEP_EVENTS);
        SWEEP_EVENTS = pool.mallocDouble(eventLength);
      }
    }
    function sqPop(queue, index, count, item) {
      var idx = index[item];
      var top = queue[count - 1];
      queue[idx] = top;
      index[top] = idx;
    }
    function sqPush(queue, index, count, item) {
      queue[count] = item;
      index[item] = count;
    }
    function sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i];
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -(idx + 1);
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + BLUE_FLAG;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e >= BLUE_FLAG) {
          e = e - BLUE_FLAG | 0;
          sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);
        } else if (e >= 0) {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);
        } else if (e <= -BLUE_FLAG) {
          e = -e - BLUE_FLAG | 0;
          for (var j = 0; j < redActive; ++j) {
            var retval = visit(RED_SWEEP_QUEUE[j], e);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);
        } else {
          e = -e - 1 | 0;
          for (var j = 0; j < blueActive; ++j) {
            var retval = visit(e, BLUE_SWEEP_QUEUE[j]);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);
        }
      }
    }
    function sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i] + 1 << 1;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + 1 << 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx | 1;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx | 1;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      var commonActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        var color = e & 1;
        if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {
          color = 2;
          i += 1;
        }
        if (e < 0) {
          var id = -(e >> 1) - 1;
          for (var j = 0; j < commonActive; ++j) {
            var retval = visit(COMMON_SWEEP_QUEUE[j], id);
            if (retval !== void 0) {
              return retval;
            }
          }
          if (color !== 0) {
            for (var j = 0; j < redActive; ++j) {
              var retval = visit(RED_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color !== 1) {
            for (var j = 0; j < blueActive; ++j) {
              var retval = visit(BLUE_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color === 0) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);
          } else if (color === 1) {
            sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);
          } else if (color === 2) {
            sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);
          }
        } else {
          var id = (e >> 1) - 1;
          if (color === 0) {
            sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);
          } else if (color === 1) {
            sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);
          } else if (color === 2) {
            sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);
          }
        }
      }
    }
    function scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      var redShift = 1;
      var blueShift = 1;
      if (flip) {
        blueShift = BLUE_FLAG;
      } else {
        redShift = BLUE_FLAG;
      }
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + redShift;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + blueShift;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          var isRed = false;
          if (idx >= BLUE_FLAG) {
            isRed = !flip;
            idx -= BLUE_FLAG;
          } else {
            isRed = !!flip;
            idx -= 1;
          }
          if (isRed) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);
          } else {
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var redId = redIndex[oidx];
                var retval;
                if (flip) {
                  retval = visit(blueId, redId);
                } else {
                  retval = visit(redId, blueId);
                }
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);
        }
      }
    }
    function scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + BLUE_FLAG;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          if (idx >= BLUE_FLAG) {
            RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;
          } else {
            idx -= 1;
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redId = redIndex[oidx];
                if (redId === blueId) {
                  break;
                }
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var retval = visit(redId, blueId);
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          var idx = e - BLUE_FLAG;
          for (var j = redActive - 1; j >= 0; --j) {
            if (RED_SWEEP_QUEUE[j] === idx) {
              for (var k = j + 1; k < redActive; ++k) {
                RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];
              }
              break;
            }
          }
          --redActive;
        }
      }
    }
  }
});

// node_modules/box-intersect/lib/brute.js
var require_brute = __commonJS({
  "node_modules/box-intersect/lib/brute.js"(exports2) {
    "use strict";
    function full() {
      function bruteForceRedFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
          var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
          Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
            var y0 = bb[ax + bp], y1 = bb[ax + bp + d], yi = bi[j];
            if (y1 < x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(xi, yi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForceBlueFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
          var y0 = bb[ax + bp], y1 = bb[ax + bp + d], yi = bi[j];
          Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
            var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
            if (y1 < x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(xi, yi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForceFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        if (re - rs > be - bs) {
          return bruteForceRedFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
        } else {
          return bruteForceBlueFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
        }
      }
      return bruteForceFull;
    }
    function partial() {
      function bruteForceRedFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
          var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
          Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
            var y0 = bb[ax + bp], yi = bi[j];
            if (y0 <= x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(yi, xi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForceRed(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
          var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
          Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
            var y0 = bb[ax + bp], yi = bi[j];
            if (y0 < x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(xi, yi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForceBlueFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
          var y0 = bb[ax + bp], yi = bi[j];
          Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
            var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
            if (y0 <= x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(yi, xi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForceBlue(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {
        var es = 2 * d;
        for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {
          var y0 = bb[ax + bp], yi = bi[j];
          Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {
            var x0 = rb[ax + rp], x1 = rb[ax + rp + d], xi = ri[i];
            if (y0 < x0 || x1 < y0) continue;
            for (var k = ax + 1; k < d; ++k) {
              var r0 = rb[k + rp], r1 = rb[k + d + rp], b0 = bb[k + bp], b1 = bb[k + d + bp];
              if (r1 < b0 || b1 < r0) continue Q;
            }
            var rv = vv(xi, yi);
            if (rv !== void 0) return rv;
          }
        }
      }
      function bruteForcePartial(d, ax, vv, fp, rs, re, rb, ri, bs, be, bb, bi) {
        if (re - rs > be - bs) {
          if (fp) {
            return bruteForceRedFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
          } else {
            return bruteForceRed(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
          }
        } else {
          if (fp) {
            return bruteForceBlueFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
          } else {
            return bruteForceBlue(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);
          }
        }
      }
      return bruteForcePartial;
    }
    function bruteForcePlanner(isFull) {
      return isFull ? full() : partial();
    }
    exports2.partial = bruteForcePlanner(false);
    exports2.full = bruteForcePlanner(true);
  }
});

// node_modules/box-intersect/lib/partition.js
var require_partition = __commonJS({
  "node_modules/box-intersect/lib/partition.js"(exports2, module2) {
    "use strict";
    module2.exports = genPartition;
    var P2F = {
      "lo===p0": lo_equal_p0,
      "lo<p0": lo_lessThan_p0,
      "lo<=p0": lo_lessOrEqual_p0,
      "hi<=p0": hi_lessOrEqual_p0,
      "lo<p0&&p0<=hi": lo_lessThan_p0_and_p0_lessOrEqual_hi,
      "lo<=p0&&p0<=hi": lo_lassOrEqual_p0_and_p0_lessOrEqual_hi,
      "!(lo>=p0)&&!(p1>=hi)": lo_lessThan_p0_and_p1_lessThan_hi
    };
    function genPartition(predicate) {
      return P2F[predicate];
    }
    function lo_equal_p0(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var lo = e[k + n];
        if (lo === p0) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function lo_lessThan_p0(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var lo = e[k + n];
        if (lo < p0) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function lo_lessOrEqual_p0(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var hi = e[k + o];
        if (hi <= p0) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function hi_lessOrEqual_p0(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var hi = e[k + o];
        if (hi <= p0) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function lo_lassOrEqual_p0_and_p0_lessOrEqual_hi(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var lo = e[k + n], hi = e[k + o];
        if (lo <= p0 && p0 <= hi) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function lo_lessThan_p0_and_p0_lessOrEqual_hi(a, b, c, d, e, f, p0) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var lo = e[k + n], hi = e[k + o];
        if (lo < p0 && p0 <= hi) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
    function lo_lessThan_p0_and_p1_lessThan_hi(a, b, c, d, e, f, p0, p1) {
      for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {
        var lo = e[k + n], hi = e[k + o];
        if (!(lo >= p0) && !(p1 >= hi)) if (m === p) m += 1, l += j;
        else {
          for (var s = 0; j > s; ++s) {
            var t = e[k + s];
            e[k + s] = e[l], e[l++] = t;
          }
          var u = f[p];
          f[p] = f[m], f[m++] = u;
        }
      }
      return m;
    }
  }
});

// node_modules/box-intersect/lib/median.js
var require_median = __commonJS({
  "node_modules/box-intersect/lib/median.js"(exports2, module2) {
    "use strict";
    module2.exports = findMedian;
    var genPartition = require_partition();
    var partitionStartLessThan = genPartition("lo<p0");
    var PARTITION_THRESHOLD = 8;
    function insertionSort(d, axis, start, end, boxes, ids) {
      var elemSize = 2 * d;
      var boxPtr = elemSize * (start + 1) + axis;
      for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {
        var x = boxes[boxPtr];
        for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {
          var aPtr = ptr;
          var bPtr = ptr + elemSize;
          for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {
            var y = boxes[aPtr];
            boxes[aPtr] = boxes[bPtr];
            boxes[bPtr] = y;
          }
          var tmp = ids[j];
          ids[j] = ids[j - 1];
          ids[j - 1] = tmp;
        }
      }
    }
    function findMedian(d, axis, start, end, boxes, ids) {
      if (end <= start + 1) {
        return start;
      }
      var lo = start;
      var hi = end;
      var mid = end + start >>> 1;
      var elemSize = 2 * d;
      var pivot = mid;
      var value = boxes[elemSize * mid + axis];
      while (lo < hi) {
        if (hi - lo < PARTITION_THRESHOLD) {
          insertionSort(d, axis, lo, hi, boxes, ids);
          value = boxes[elemSize * mid + axis];
          break;
        }
        var count = hi - lo;
        var pivot0 = Math.random() * count + lo | 0;
        var value0 = boxes[elemSize * pivot0 + axis];
        var pivot1 = Math.random() * count + lo | 0;
        var value1 = boxes[elemSize * pivot1 + axis];
        var pivot2 = Math.random() * count + lo | 0;
        var value2 = boxes[elemSize * pivot2 + axis];
        if (value0 <= value1) {
          if (value2 >= value1) {
            pivot = pivot1;
            value = value1;
          } else if (value0 >= value2) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        } else {
          if (value1 >= value2) {
            pivot = pivot1;
            value = value1;
          } else if (value2 >= value0) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        }
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        pivot = partitionStartLessThan(
          d,
          axis,
          lo,
          hi - 1,
          boxes,
          ids,
          value
        );
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        if (mid < pivot) {
          hi = pivot - 1;
          while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {
            hi -= 1;
          }
          hi += 1;
        } else if (pivot < mid) {
          lo = pivot + 1;
          while (lo < hi && boxes[elemSize * lo + axis] === value) {
            lo += 1;
          }
        } else {
          break;
        }
      }
      return partitionStartLessThan(
        d,
        axis,
        start,
        mid,
        boxes,
        ids,
        boxes[elemSize * mid + axis]
      );
    }
  }
});

// node_modules/box-intersect/lib/intersect.js
var require_intersect = __commonJS({
  "node_modules/box-intersect/lib/intersect.js"(exports2, module2) {
    "use strict";
    module2.exports = boxIntersectIter;
    var pool = require_pool();
    var bits = require_twiddle();
    var bruteForce = require_brute();
    var bruteForcePartial = bruteForce.partial;
    var bruteForceFull = bruteForce.full;
    var sweep = require_sweep();
    var findMedian = require_median();
    var genPartition = require_partition();
    var BRUTE_FORCE_CUTOFF = 128;
    var SCAN_CUTOFF = 1 << 22;
    var SCAN_COMPLETE_CUTOFF = 1 << 22;
    var partitionInteriorContainsInterval = genPartition(
      "!(lo>=p0)&&!(p1>=hi)"
    );
    var partitionStartEqual = genPartition(
      "lo===p0"
    );
    var partitionStartLessThan = genPartition(
      "lo<p0"
    );
    var partitionEndLessThanEqual = genPartition(
      "hi<=p0"
    );
    var partitionContainsPoint = genPartition(
      "lo<=p0&&p0<=hi"
    );
    var partitionContainsPointProper = genPartition(
      "lo<p0&&p0<=hi"
    );
    var IFRAME_SIZE = 6;
    var DFRAME_SIZE = 2;
    var INIT_CAPACITY = 1024;
    var BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);
    var BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY);
    function iterInit(d, count) {
      var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;
      var maxInts = bits.nextPow2(IFRAME_SIZE * levels);
      if (BOX_ISTACK.length < maxInts) {
        pool.free(BOX_ISTACK);
        BOX_ISTACK = pool.mallocInt32(maxInts);
      }
      var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);
      if (BOX_DSTACK.length < maxDoubles) {
        pool.free(BOX_DSTACK);
        BOX_DSTACK = pool.mallocDouble(maxDoubles);
      }
    }
    function iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {
      var iptr = IFRAME_SIZE * ptr;
      BOX_ISTACK[iptr] = axis;
      BOX_ISTACK[iptr + 1] = redStart;
      BOX_ISTACK[iptr + 2] = redEnd;
      BOX_ISTACK[iptr + 3] = blueStart;
      BOX_ISTACK[iptr + 4] = blueEnd;
      BOX_ISTACK[iptr + 5] = state;
      var dptr = DFRAME_SIZE * ptr;
      BOX_DSTACK[dptr] = lo;
      BOX_DSTACK[dptr + 1] = hi;
    }
    function onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          if (flip && blueX === r0) {
            continue;
          }
          var redId = redIndex[i];
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval;
          if (flip) {
            retval = visit(blueId, redId);
          } else {
            retval = visit(redId, blueId);
          }
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var redId = redIndex[i];
          if (redId === blueId) {
            continue;
          }
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval = visit(redId, blueId);
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {
      iterInit(d, xSize + ySize);
      var top = 0;
      var elemSize = 2 * d;
      var retval;
      iterPush(
        top++,
        0,
        0,
        xSize,
        0,
        ySize,
        initFull ? 16 : 0,
        -Infinity,
        Infinity
      );
      if (!initFull) {
        iterPush(
          top++,
          0,
          0,
          ySize,
          0,
          xSize,
          1,
          -Infinity,
          Infinity
        );
      }
      while (top > 0) {
        top -= 1;
        var iptr = top * IFRAME_SIZE;
        var axis = BOX_ISTACK[iptr];
        var redStart = BOX_ISTACK[iptr + 1];
        var redEnd = BOX_ISTACK[iptr + 2];
        var blueStart = BOX_ISTACK[iptr + 3];
        var blueEnd = BOX_ISTACK[iptr + 4];
        var state = BOX_ISTACK[iptr + 5];
        var dptr = top * DFRAME_SIZE;
        var lo = BOX_DSTACK[dptr];
        var hi = BOX_DSTACK[dptr + 1];
        var flip = state & 1;
        var full = !!(state & 16);
        var red = xBoxes;
        var redIndex = xIndex;
        var blue = yBoxes;
        var blueIndex = yIndex;
        if (flip) {
          red = yBoxes;
          redIndex = yIndex;
          blue = xBoxes;
          blueIndex = xIndex;
        }
        if (state & 2) {
          redEnd = partitionStartLessThan(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            hi
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        if (state & 4) {
          redStart = partitionEndLessThanEqual(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            lo
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        var redCount = redEnd - redStart;
        var blueCount = blueEnd - blueStart;
        if (full) {
          if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
            retval = sweep.scanComplete(
              d,
              axis,
              visit,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        } else {
          if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForcePartial(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          } else if (d * redCount * blueCount < SCAN_CUTOFF) {
            retval = sweep.scanBipartite(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        }
        var red0 = partitionInteriorContainsInterval(
          d,
          axis,
          redStart,
          redEnd,
          red,
          redIndex,
          lo,
          hi
        );
        if (redStart < red0) {
          if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForceFull(
              d,
              axis + 1,
              visit,
              redStart,
              red0,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
          } else if (axis === d - 2) {
            if (flip) {
              retval = sweep.sweepBipartite(
                d,
                visit,
                blueStart,
                blueEnd,
                blue,
                blueIndex,
                redStart,
                red0,
                red,
                redIndex
              );
            } else {
              retval = sweep.sweepBipartite(
                d,
                visit,
                redStart,
                red0,
                red,
                redIndex,
                blueStart,
                blueEnd,
                blue,
                blueIndex
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else {
            iterPush(
              top++,
              axis + 1,
              redStart,
              red0,
              blueStart,
              blueEnd,
              flip,
              -Infinity,
              Infinity
            );
            iterPush(
              top++,
              axis + 1,
              blueStart,
              blueEnd,
              redStart,
              red0,
              flip ^ 1,
              -Infinity,
              Infinity
            );
          }
        }
        if (red0 < redEnd) {
          var blue0 = findMedian(
            d,
            axis,
            blueStart,
            blueEnd,
            blue,
            blueIndex
          );
          var mid = blue[elemSize * blue0 + axis];
          var blue1 = partitionStartEqual(
            d,
            axis,
            blue0,
            blueEnd,
            blue,
            blueIndex,
            mid
          );
          if (blue1 < blueEnd) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blue1,
              blueEnd,
              (flip | 4) + (full ? 16 : 0),
              mid,
              hi
            );
          }
          if (blueStart < blue0) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blueStart,
              blue0,
              (flip | 2) + (full ? 16 : 0),
              lo,
              mid
            );
          }
          if (blue0 + 1 === blue1) {
            if (full) {
              retval = onePointFull(
                d,
                axis,
                visit,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            } else {
              retval = onePointPartial(
                d,
                axis,
                visit,
                flip,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else if (blue0 < blue1) {
            var red1;
            if (full) {
              red1 = partitionContainsPoint(
                d,
                axis,
                red0,
                redEnd,
                red,
                redIndex,
                mid
              );
              if (red0 < red1) {
                var redX = partitionStartEqual(
                  d,
                  axis,
                  red0,
                  red1,
                  red,
                  redIndex,
                  mid
                );
                if (axis === d - 2) {
                  if (red0 < redX) {
                    retval = sweep.sweepComplete(
                      d,
                      visit,
                      red0,
                      redX,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                  if (redX < red1) {
                    retval = sweep.sweepBipartite(
                      d,
                      visit,
                      redX,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                } else {
                  if (red0 < redX) {
                    iterPush(
                      top++,
                      axis + 1,
                      red0,
                      redX,
                      blue0,
                      blue1,
                      16,
                      -Infinity,
                      Infinity
                    );
                  }
                  if (redX < red1) {
                    iterPush(
                      top++,
                      axis + 1,
                      redX,
                      red1,
                      blue0,
                      blue1,
                      0,
                      -Infinity,
                      Infinity
                    );
                    iterPush(
                      top++,
                      axis + 1,
                      blue0,
                      blue1,
                      redX,
                      red1,
                      1,
                      -Infinity,
                      Infinity
                    );
                  }
                }
              }
            } else {
              if (flip) {
                red1 = partitionContainsPointProper(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              } else {
                red1 = partitionContainsPoint(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              }
              if (red0 < red1) {
                if (axis === d - 2) {
                  if (flip) {
                    retval = sweep.sweepBipartite(
                      d,
                      visit,
                      blue0,
                      blue1,
                      blue,
                      blueIndex,
                      red0,
                      red1,
                      red,
                      redIndex
                    );
                  } else {
                    retval = sweep.sweepBipartite(
                      d,
                      visit,
                      red0,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                  }
                } else {
                  iterPush(
                    top++,
                    axis + 1,
                    red0,
                    red1,
                    blue0,
                    blue1,
                    flip,
                    -Infinity,
                    Infinity
                  );
                  iterPush(
                    top++,
                    axis + 1,
                    blue0,
                    blue1,
                    red0,
                    red1,
                    flip ^ 1,
                    -Infinity,
                    Infinity
                  );
                }
              }
            }
          }
        }
      }
    }
  }
});

// node_modules/box-intersect/index.js
var require_box_intersect = __commonJS({
  "node_modules/box-intersect/index.js"(exports2, module2) {
    "use strict";
    module2.exports = boxIntersectWrapper;
    var pool = require_pool();
    var sweep = require_sweep();
    var boxIntersectIter = require_intersect();
    function boxEmpty(d, box) {
      for (var j = 0; j < d; ++j) {
        if (!(box[j] <= box[j + d])) {
          return true;
        }
      }
      return false;
    }
    function convertBoxes(boxes, d, data, ids) {
      var ptr = 0;
      var count = 0;
      for (var i = 0, n = boxes.length; i < n; ++i) {
        var b = boxes[i];
        if (boxEmpty(d, b)) {
          continue;
        }
        for (var j = 0; j < 2 * d; ++j) {
          data[ptr++] = b[j];
        }
        ids[count++] = i;
      }
      return count;
    }
    function boxIntersect(red, blue, visit, full) {
      var n = red.length;
      var m = blue.length;
      if (n <= 0 || m <= 0) {
        return;
      }
      var d = red[0].length >>> 1;
      if (d <= 0) {
        return;
      }
      var retval;
      var redList = pool.mallocDouble(2 * d * n);
      var redIds = pool.mallocInt32(n);
      n = convertBoxes(red, d, redList, redIds);
      if (n > 0) {
        if (d === 1 && full) {
          sweep.init(n);
          retval = sweep.sweepComplete(
            d,
            visit,
            0,
            n,
            redList,
            redIds,
            0,
            n,
            redList,
            redIds
          );
        } else {
          var blueList = pool.mallocDouble(2 * d * m);
          var blueIds = pool.mallocInt32(m);
          m = convertBoxes(blue, d, blueList, blueIds);
          if (m > 0) {
            sweep.init(n + m);
            if (d === 1) {
              retval = sweep.sweepBipartite(
                d,
                visit,
                0,
                n,
                redList,
                redIds,
                0,
                m,
                blueList,
                blueIds
              );
            } else {
              retval = boxIntersectIter(
                d,
                visit,
                full,
                n,
                redList,
                redIds,
                m,
                blueList,
                blueIds
              );
            }
            pool.free(blueList);
            pool.free(blueIds);
          }
        }
        pool.free(redList);
        pool.free(redIds);
      }
      return retval;
    }
    var RESULT;
    function appendItem(i, j) {
      RESULT.push([i, j]);
    }
    function intersectFullArray(x) {
      RESULT = [];
      boxIntersect(x, x, appendItem, true);
      return RESULT;
    }
    function intersectBipartiteArray(x, y) {
      RESULT = [];
      boxIntersect(x, y, appendItem, false);
      return RESULT;
    }
    function boxIntersectWrapper(arg0, arg1, arg2) {
      switch (arguments.length) {
        case 1:
          return intersectFullArray(arg0);
        case 2:
          if (typeof arg1 === "function") {
            return boxIntersect(arg0, arg0, arg1, true);
          } else {
            return intersectBipartiteArray(arg0, arg1);
          }
        case 3:
          return boxIntersect(arg0, arg1, arg2, false);
        default:
          throw new Error("box-intersect: Invalid arguments");
      }
    }
  }
});

// node_modules/robust-segment-intersect/segseg.js
var require_segseg = __commonJS({
  "node_modules/robust-segment-intersect/segseg.js"(exports2, module2) {
    "use strict";
    module2.exports = segmentsIntersect;
    var orient = require_orientation()[3];
    function checkCollinear(a0, a1, b0, b1) {
      for (var d = 0; d < 2; ++d) {
        var x0 = a0[d];
        var y0 = a1[d];
        var l0 = Math.min(x0, y0);
        var h0 = Math.max(x0, y0);
        var x1 = b0[d];
        var y1 = b1[d];
        var l1 = Math.min(x1, y1);
        var h1 = Math.max(x1, y1);
        if (h1 < l0 || h0 < l1) {
          return false;
        }
      }
      return true;
    }
    function segmentsIntersect(a0, a1, b0, b1) {
      var x0 = orient(a0, b0, b1);
      var y0 = orient(a1, b0, b1);
      if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {
        return false;
      }
      var x1 = orient(b0, a0, a1);
      var y1 = orient(b1, a0, a1);
      if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {
        return false;
      }
      if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
        return checkCollinear(a0, a1, b0, b1);
      }
      return true;
    }
  }
});

// (disabled):node_modules/buffer/index.js
var require_buffer3 = __commonJS({
  "(disabled):node_modules/buffer/index.js"() {
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer3().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p) {
        this.name = name2;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name2) {
        if (primes[name2]) return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/big-rat/lib/is-bn.js
var require_is_bn = __commonJS({
  "node_modules/big-rat/lib/is-bn.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    module2.exports = isBN;
    function isBN(x) {
      return x && typeof x === "object" && Boolean(x.words);
    }
  }
});

// node_modules/big-rat/is-rat.js
var require_is_rat = __commonJS({
  "node_modules/big-rat/is-rat.js"(exports2, module2) {
    "use strict";
    var isBN = require_is_bn();
    module2.exports = isRat;
    function isRat(x) {
      return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1]);
    }
  }
});

// node_modules/double-bits/double.js
var require_double = __commonJS({
  "node_modules/double-bits/double.js"(exports2, module2) {
    var hasTypedArrays = false;
    if (typeof Float64Array !== "undefined") {
      DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
      DOUBLE_VIEW[0] = 1;
      hasTypedArrays = true;
      if (UINT_VIEW[1] === 1072693248) {
        let toDoubleLE2 = function(lo, hi) {
          UINT_VIEW[0] = lo;
          UINT_VIEW[1] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        }, highUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        };
        toDoubleLE = toDoubleLE2, lowUintLE = lowUintLE2, highUintLE = highUintLE2;
        module2.exports = function doubleBitsLE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[0], UINT_VIEW[1]];
        };
        module2.exports.pack = toDoubleLE2;
        module2.exports.lo = lowUintLE2;
        module2.exports.hi = highUintLE2;
      } else if (UINT_VIEW[0] === 1072693248) {
        let toDoubleBE2 = function(lo, hi) {
          UINT_VIEW[1] = lo;
          UINT_VIEW[0] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        }, highUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        };
        toDoubleBE = toDoubleBE2, lowUintBE = lowUintBE2, highUintBE = highUintBE2;
        module2.exports = function doubleBitsBE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[1], UINT_VIEW[0]];
        };
        module2.exports.pack = toDoubleBE2;
        module2.exports.lo = lowUintBE2;
        module2.exports.hi = highUintBE2;
      } else {
        hasTypedArrays = false;
      }
    }
    var DOUBLE_VIEW;
    var UINT_VIEW;
    var toDoubleLE;
    var lowUintLE;
    var highUintLE;
    var toDoubleBE;
    var lowUintBE;
    var highUintBE;
    if (!hasTypedArrays) {
      let toDouble2 = function(lo, hi) {
        buffer.writeUInt32LE(lo, 0, true);
        buffer.writeUInt32LE(hi, 4, true);
        return buffer.readDoubleLE(0, true);
      }, lowUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(0, true);
      }, highUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(4, true);
      };
      toDouble = toDouble2, lowUint = lowUint2, highUint = highUint2;
      buffer = new Buffer(8);
      module2.exports = function doubleBits(n) {
        buffer.writeDoubleLE(n, 0, true);
        return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
      };
      module2.exports.pack = toDouble2;
      module2.exports.lo = lowUint2;
      module2.exports.hi = highUint2;
    }
    var buffer;
    var toDouble;
    var lowUint;
    var highUint;
    module2.exports.sign = function(n) {
      return module2.exports.hi(n) >>> 31;
    };
    module2.exports.exponent = function(n) {
      var b = module2.exports.hi(n);
      return (b << 1 >>> 21) - 1023;
    };
    module2.exports.fraction = function(n) {
      var lo = module2.exports.lo(n);
      var hi = module2.exports.hi(n);
      var b = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b += 1 << 20;
      }
      return [lo, b];
    };
    module2.exports.denormalized = function(n) {
      var hi = module2.exports.hi(n);
      return !(hi & 2146435072);
    };
  }
});

// node_modules/big-rat/lib/num-to-bn.js
var require_num_to_bn = __commonJS({
  "node_modules/big-rat/lib/num-to-bn.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var db = require_double();
    module2.exports = num2bn;
    function num2bn(x) {
      var e = db.exponent(x);
      if (e < 52) {
        return new BN(x);
      } else {
        return new BN(x * Math.pow(2, 52 - e)).ushln(e - 52);
      }
    }
  }
});

// node_modules/big-rat/lib/str-to-bn.js
var require_str_to_bn = __commonJS({
  "node_modules/big-rat/lib/str-to-bn.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    module2.exports = str2BN;
    function str2BN(x) {
      return new BN(x);
    }
  }
});

// node_modules/big-rat/lib/bn-sign.js
var require_bn_sign = __commonJS({
  "node_modules/big-rat/lib/bn-sign.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    module2.exports = sign;
    function sign(x) {
      return x.cmp(new BN(0));
    }
  }
});

// node_modules/big-rat/lib/rationalize.js
var require_rationalize = __commonJS({
  "node_modules/big-rat/lib/rationalize.js"(exports2, module2) {
    "use strict";
    var num2bn = require_num_to_bn();
    var sign = require_bn_sign();
    module2.exports = rationalize;
    function rationalize(numer, denom) {
      var snumer = sign(numer);
      var sdenom = sign(denom);
      if (snumer === 0) {
        return [num2bn(0), num2bn(1)];
      }
      if (sdenom === 0) {
        return [num2bn(0), num2bn(0)];
      }
      if (sdenom < 0) {
        numer = numer.neg();
        denom = denom.neg();
      }
      var d = numer.gcd(denom);
      if (d.cmpn(1)) {
        return [numer.div(d), denom.div(d)];
      }
      return [numer, denom];
    }
  }
});

// node_modules/big-rat/div.js
var require_div2 = __commonJS({
  "node_modules/big-rat/div.js"(exports2, module2) {
    "use strict";
    var rationalize = require_rationalize();
    module2.exports = div;
    function div(a, b) {
      return rationalize(a[0].mul(b[1]), a[1].mul(b[0]));
    }
  }
});

// node_modules/big-rat/index.js
var require_big_rat = __commonJS({
  "node_modules/big-rat/index.js"(exports2, module2) {
    "use strict";
    var isRat = require_is_rat();
    var isBN = require_is_bn();
    var num2bn = require_num_to_bn();
    var str2bn = require_str_to_bn();
    var rationalize = require_rationalize();
    var div = require_div2();
    module2.exports = makeRational;
    function makeRational(numer, denom) {
      if (isRat(numer)) {
        if (denom) {
          return div(numer, makeRational(denom));
        }
        return [numer[0].clone(), numer[1].clone()];
      }
      var shift = 0;
      var a, b;
      if (isBN(numer)) {
        a = numer.clone();
      } else if (typeof numer === "string") {
        a = str2bn(numer);
      } else if (numer === 0) {
        return [num2bn(0), num2bn(1)];
      } else if (numer === Math.floor(numer)) {
        a = num2bn(numer);
      } else {
        while (numer !== Math.floor(numer)) {
          numer = numer * Math.pow(2, 256);
          shift -= 256;
        }
        a = num2bn(numer);
      }
      if (isRat(denom)) {
        a.mul(denom[1]);
        b = denom[0].clone();
      } else if (isBN(denom)) {
        b = denom.clone();
      } else if (typeof denom === "string") {
        b = str2bn(denom);
      } else if (!denom) {
        b = num2bn(1);
      } else if (denom === Math.floor(denom)) {
        b = num2bn(denom);
      } else {
        while (denom !== Math.floor(denom)) {
          denom = denom * Math.pow(2, 256);
          shift += 256;
        }
        b = num2bn(denom);
      }
      if (shift > 0) {
        a = a.ushln(shift);
      } else if (shift < 0) {
        b = b.ushln(-shift);
      }
      return rationalize(a, b);
    }
  }
});

// node_modules/big-rat/cmp.js
var require_cmp = __commonJS({
  "node_modules/big-rat/cmp.js"(exports2, module2) {
    "use strict";
    module2.exports = cmp;
    function cmp(a, b) {
      return a[0].mul(b[1]).cmp(b[0].mul(a[1]));
    }
  }
});

// node_modules/big-rat/lib/bn-to-num.js
var require_bn_to_num = __commonJS({
  "node_modules/big-rat/lib/bn-to-num.js"(exports2, module2) {
    "use strict";
    var sign = require_bn_sign();
    module2.exports = bn2num;
    function bn2num(b) {
      var l = b.length;
      var words = b.words;
      var out = 0;
      if (l === 1) {
        out = words[0];
      } else if (l === 2) {
        out = words[0] + words[1] * 67108864;
      } else {
        for (var i = 0; i < l; i++) {
          var w = words[i];
          out += w * Math.pow(67108864, i);
        }
      }
      return sign(b) * out;
    }
  }
});

// node_modules/big-rat/lib/ctz.js
var require_ctz = __commonJS({
  "node_modules/big-rat/lib/ctz.js"(exports2, module2) {
    "use strict";
    var db = require_double();
    var ctz = require_twiddle().countTrailingZeros;
    module2.exports = ctzNumber;
    function ctzNumber(x) {
      var l = ctz(db.lo(x));
      if (l < 32) {
        return l;
      }
      var h = ctz(db.hi(x));
      if (h > 20) {
        return 52;
      }
      return h + 32;
    }
  }
});

// node_modules/big-rat/to-float.js
var require_to_float = __commonJS({
  "node_modules/big-rat/to-float.js"(exports2, module2) {
    "use strict";
    var bn2num = require_bn_to_num();
    var ctz = require_ctz();
    module2.exports = roundRat;
    function roundRat(f) {
      var a = f[0];
      var b = f[1];
      if (a.cmpn(0) === 0) {
        return 0;
      }
      var h = a.abs().divmod(b.abs());
      var iv = h.div;
      var x = bn2num(iv);
      var ir = h.mod;
      var sgn = a.negative !== b.negative ? -1 : 1;
      if (ir.cmpn(0) === 0) {
        return sgn * x;
      }
      if (x) {
        var s = ctz(x) + 4;
        var y = bn2num(ir.ushln(s).divRound(b));
        return sgn * (x + y * Math.pow(2, -s));
      } else {
        var ybits = b.bitLength() - ir.bitLength() + 53;
        var y = bn2num(ir.ushln(ybits).divRound(b));
        if (ybits < 1023) {
          return sgn * y * Math.pow(2, -ybits);
        }
        y *= Math.pow(2, -1023);
        return sgn * y * Math.pow(2, 1023 - ybits);
      }
    }
  }
});

// node_modules/rat-vec/index.js
var require_rat_vec = __commonJS({
  "node_modules/rat-vec/index.js"(exports2, module2) {
    "use strict";
    module2.exports = float2rat;
    var rat = require_big_rat();
    function float2rat(v) {
      var result = new Array(v.length);
      for (var i = 0; i < v.length; ++i) {
        result[i] = rat(v[i]);
      }
      return result;
    }
  }
});

// node_modules/nextafter/nextafter.js
var require_nextafter = __commonJS({
  "node_modules/nextafter/nextafter.js"(exports2, module2) {
    "use strict";
    var doubleBits = require_double();
    var SMALLEST_DENORM = Math.pow(2, -1074);
    var UINT_MAX = -1 >>> 0;
    module2.exports = nextafter;
    function nextafter(x, y) {
      if (isNaN(x) || isNaN(y)) {
        return NaN;
      }
      if (x === y) {
        return x;
      }
      if (x === 0) {
        if (y < 0) {
          return -SMALLEST_DENORM;
        } else {
          return SMALLEST_DENORM;
        }
      }
      var hi = doubleBits.hi(x);
      var lo = doubleBits.lo(x);
      if (y > x === x > 0) {
        if (lo === UINT_MAX) {
          hi += 1;
          lo = 0;
        } else {
          lo += 1;
        }
      } else {
        if (lo === 0) {
          lo = UINT_MAX;
          hi -= 1;
        } else {
          lo -= 1;
        }
      }
      return doubleBits.pack(lo, hi);
    }
  }
});

// node_modules/big-rat/mul.js
var require_mul2 = __commonJS({
  "node_modules/big-rat/mul.js"(exports2, module2) {
    "use strict";
    var rationalize = require_rationalize();
    module2.exports = mul;
    function mul(a, b) {
      return rationalize(a[0].mul(b[0]), a[1].mul(b[1]));
    }
  }
});

// node_modules/big-rat/sub.js
var require_sub2 = __commonJS({
  "node_modules/big-rat/sub.js"(exports2, module2) {
    "use strict";
    var rationalize = require_rationalize();
    module2.exports = sub;
    function sub(a, b) {
      return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]));
    }
  }
});

// node_modules/big-rat/sign.js
var require_sign = __commonJS({
  "node_modules/big-rat/sign.js"(exports2, module2) {
    "use strict";
    var bnsign = require_bn_sign();
    module2.exports = sign;
    function sign(x) {
      return bnsign(x[0]) * bnsign(x[1]);
    }
  }
});

// node_modules/rat-vec/sub.js
var require_sub3 = __commonJS({
  "node_modules/rat-vec/sub.js"(exports2, module2) {
    "use strict";
    var bnsub = require_sub2();
    module2.exports = sub;
    function sub(a, b) {
      var n = a.length;
      var r = new Array(n);
      for (var i = 0; i < n; ++i) {
        r[i] = bnsub(a[i], b[i]);
      }
      return r;
    }
  }
});

// node_modules/big-rat/add.js
var require_add2 = __commonJS({
  "node_modules/big-rat/add.js"(exports2, module2) {
    "use strict";
    var rationalize = require_rationalize();
    module2.exports = add;
    function add(a, b) {
      return rationalize(
        a[0].mul(b[1]).add(b[0].mul(a[1])),
        a[1].mul(b[1])
      );
    }
  }
});

// node_modules/rat-vec/add.js
var require_add3 = __commonJS({
  "node_modules/rat-vec/add.js"(exports2, module2) {
    "use strict";
    var bnadd = require_add2();
    module2.exports = add;
    function add(a, b) {
      var n = a.length;
      var r = new Array(n);
      for (var i = 0; i < n; ++i) {
        r[i] = bnadd(a[i], b[i]);
      }
      return r;
    }
  }
});

// node_modules/rat-vec/muls.js
var require_muls = __commonJS({
  "node_modules/rat-vec/muls.js"(exports2, module2) {
    "use strict";
    var rat = require_big_rat();
    var mul = require_mul2();
    module2.exports = muls;
    function muls(a, x) {
      var s = rat(x);
      var n = a.length;
      var r = new Array(n);
      for (var i = 0; i < n; ++i) {
        r[i] = mul(a[i], s);
      }
      return r;
    }
  }
});

// node_modules/clean-pslg/lib/rat-seg-intersect.js
var require_rat_seg_intersect = __commonJS({
  "node_modules/clean-pslg/lib/rat-seg-intersect.js"(exports2, module2) {
    "use strict";
    module2.exports = solveIntersection;
    var ratMul = require_mul2();
    var ratDiv = require_div2();
    var ratSub = require_sub2();
    var ratSign = require_sign();
    var rvSub = require_sub3();
    var rvAdd = require_add3();
    var rvMuls = require_muls();
    function ratPerp(a, b) {
      return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]));
    }
    function solveIntersection(a, b, c, d) {
      var ba = rvSub(b, a);
      var dc = rvSub(d, c);
      var baXdc = ratPerp(ba, dc);
      if (ratSign(baXdc) === 0) {
        return null;
      }
      var ac = rvSub(a, c);
      var dcXac = ratPerp(dc, ac);
      var t = ratDiv(dcXac, baXdc);
      var s = rvMuls(ba, t);
      var r = rvAdd(a, s);
      return r;
    }
  }
});

// node_modules/clean-pslg/clean-pslg.js
var require_clean_pslg = __commonJS({
  "node_modules/clean-pslg/clean-pslg.js"(exports2, module2) {
    "use strict";
    module2.exports = cleanPSLG;
    var UnionFind = require_union_find();
    var boxIntersect = require_box_intersect();
    var segseg = require_segseg();
    var rat = require_big_rat();
    var ratCmp = require_cmp();
    var ratToFloat = require_to_float();
    var ratVec = require_rat_vec();
    var nextafter = require_nextafter();
    var solveIntersection = require_rat_seg_intersect();
    function boundRat(r) {
      var f = ratToFloat(r);
      return [
        nextafter(f, -Infinity),
        nextafter(f, Infinity)
      ];
    }
    function boundEdges(points, edges) {
      var bounds = new Array(edges.length);
      for (var i = 0; i < edges.length; ++i) {
        var e = edges[i];
        var a = points[e[0]];
        var b = points[e[1]];
        bounds[i] = [
          nextafter(Math.min(a[0], b[0]), -Infinity),
          nextafter(Math.min(a[1], b[1]), -Infinity),
          nextafter(Math.max(a[0], b[0]), Infinity),
          nextafter(Math.max(a[1], b[1]), Infinity)
        ];
      }
      return bounds;
    }
    function boundPoints(points) {
      var bounds = new Array(points.length);
      for (var i = 0; i < points.length; ++i) {
        var p = points[i];
        bounds[i] = [
          nextafter(p[0], -Infinity),
          nextafter(p[1], -Infinity),
          nextafter(p[0], Infinity),
          nextafter(p[1], Infinity)
        ];
      }
      return bounds;
    }
    function getCrossings(points, edges, edgeBounds) {
      var result = [];
      boxIntersect(edgeBounds, function(i, j) {
        var e = edges[i];
        var f = edges[j];
        if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {
          return;
        }
        var a = points[e[0]];
        var b = points[e[1]];
        var c = points[f[0]];
        var d = points[f[1]];
        if (segseg(a, b, c, d)) {
          result.push([i, j]);
        }
      });
      return result;
    }
    function getTJunctions(points, edges, edgeBounds, vertBounds) {
      var result = [];
      boxIntersect(edgeBounds, vertBounds, function(i, v) {
        var e = edges[i];
        if (e[0] === v || e[1] === v) {
          return;
        }
        var p = points[v];
        var a = points[e[0]];
        var b = points[e[1]];
        if (segseg(a, b, p, p)) {
          result.push([i, v]);
        }
      });
      return result;
    }
    function cutEdges(floatPoints, edges, crossings, junctions, useColor) {
      var i, e;
      var ratPoints = floatPoints.map(function(p) {
        return [
          rat(p[0]),
          rat(p[1])
        ];
      });
      for (i = 0; i < crossings.length; ++i) {
        var crossing = crossings[i];
        e = crossing[0];
        var f = crossing[1];
        var ee = edges[e];
        var ef = edges[f];
        var x = solveIntersection(
          ratVec(floatPoints[ee[0]]),
          ratVec(floatPoints[ee[1]]),
          ratVec(floatPoints[ef[0]]),
          ratVec(floatPoints[ef[1]])
        );
        if (!x) {
          continue;
        }
        var idx = floatPoints.length;
        floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);
        ratPoints.push(x);
        junctions.push([e, idx], [f, idx]);
      }
      junctions.sort(function(a2, b2) {
        if (a2[0] !== b2[0]) {
          return a2[0] - b2[0];
        }
        var u = ratPoints[a2[1]];
        var v = ratPoints[b2[1]];
        return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);
      });
      for (i = junctions.length - 1; i >= 0; --i) {
        var junction = junctions[i];
        e = junction[0];
        var edge = edges[e];
        var s = edge[0];
        var t = edge[1];
        var a = floatPoints[s];
        var b = floatPoints[t];
        if ((a[0] - b[0] || a[1] - b[1]) < 0) {
          var tmp = s;
          s = t;
          t = tmp;
        }
        edge[0] = s;
        var last = edge[1] = junction[1];
        var color;
        if (useColor) {
          color = edge[2];
        }
        while (i > 0 && junctions[i - 1][0] === e) {
          var junction = junctions[--i];
          var next = junction[1];
          if (useColor) {
            edges.push([last, next, color]);
          } else {
            edges.push([last, next]);
          }
          last = next;
        }
        if (useColor) {
          edges.push([last, t, color]);
        } else {
          edges.push([last, t]);
        }
      }
      return ratPoints;
    }
    function dedupPoints(floatPoints, ratPoints, floatBounds) {
      var numPoints = ratPoints.length;
      var uf = new UnionFind(numPoints);
      var bounds = [];
      for (var i = 0; i < ratPoints.length; ++i) {
        var p = ratPoints[i];
        var xb = boundRat(p[0]);
        var yb = boundRat(p[1]);
        bounds.push([
          nextafter(xb[0], -Infinity),
          nextafter(yb[0], -Infinity),
          nextafter(xb[1], Infinity),
          nextafter(yb[1], Infinity)
        ]);
      }
      boxIntersect(bounds, function(i2, j2) {
        uf.link(i2, j2);
      });
      var noDupes = true;
      var labels = new Array(numPoints);
      for (var i = 0; i < numPoints; ++i) {
        var j = uf.find(i);
        if (j !== i) {
          noDupes = false;
          floatPoints[j] = [
            Math.min(floatPoints[i][0], floatPoints[j][0]),
            Math.min(floatPoints[i][1], floatPoints[j][1])
          ];
        }
      }
      if (noDupes) {
        return null;
      }
      var ptr = 0;
      for (var i = 0; i < numPoints; ++i) {
        var j = uf.find(i);
        if (j === i) {
          labels[i] = ptr;
          floatPoints[ptr++] = floatPoints[i];
        } else {
          labels[i] = -1;
        }
      }
      floatPoints.length = ptr;
      for (var i = 0; i < numPoints; ++i) {
        if (labels[i] < 0) {
          labels[i] = labels[uf.find(i)];
        }
      }
      return labels;
    }
    function compareLex2(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }
    function compareLex3(a, b) {
      var d = a[0] - b[0] || a[1] - b[1];
      if (d) {
        return d;
      }
      if (a[2] < b[2]) {
        return -1;
      } else if (a[2] > b[2]) {
        return 1;
      }
      return 0;
    }
    function dedupEdges(edges, labels, useColor) {
      if (edges.length === 0) {
        return;
      }
      if (labels) {
        for (var i = 0; i < edges.length; ++i) {
          var e = edges[i];
          var a = labels[e[0]];
          var b = labels[e[1]];
          e[0] = Math.min(a, b);
          e[1] = Math.max(a, b);
        }
      } else {
        for (var i = 0; i < edges.length; ++i) {
          var e = edges[i];
          var a = e[0];
          var b = e[1];
          e[0] = Math.min(a, b);
          e[1] = Math.max(a, b);
        }
      }
      if (useColor) {
        edges.sort(compareLex3);
      } else {
        edges.sort(compareLex2);
      }
      var ptr = 1;
      for (var i = 1; i < edges.length; ++i) {
        var prev = edges[i - 1];
        var next = edges[i];
        if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {
          continue;
        }
        edges[ptr++] = next;
      }
      edges.length = ptr;
    }
    function preRound(points, edges, useColor) {
      var labels = dedupPoints(points, [], boundPoints(points));
      dedupEdges(edges, labels, useColor);
      return !!labels;
    }
    function snapRound(points, edges, useColor) {
      var edgeBounds = boundEdges(points, edges);
      var crossings = getCrossings(points, edges, edgeBounds);
      var vertBounds = boundPoints(points);
      var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds);
      var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor);
      var labels = dedupPoints(points, ratPoints, vertBounds);
      dedupEdges(edges, labels, useColor);
      if (!labels) {
        return crossings.length > 0 || tjunctions.length > 0;
      }
      return true;
    }
    function cleanPSLG(points, edges, colors) {
      var prevEdges;
      if (colors) {
        prevEdges = edges;
        var augEdges = new Array(edges.length);
        for (var i = 0; i < edges.length; ++i) {
          var e = edges[i];
          augEdges[i] = [e[0], e[1], colors[i]];
        }
        edges = augEdges;
      }
      var modified = preRound(points, edges, !!colors);
      while (snapRound(points, edges, !!colors)) {
        modified = true;
      }
      if (!!colors && modified) {
        prevEdges.length = 0;
        colors.length = 0;
        for (var i = 0; i < edges.length; ++i) {
          var e = edges[i];
          prevEdges.push([e[0], e[1]]);
          colors.push(e[2]);
        }
      }
      return modified;
    }
  }
});

// node_modules/cdt2d/lib/monotone.js
var require_monotone = __commonJS({
  "node_modules/cdt2d/lib/monotone.js"(exports2, module2) {
    "use strict";
    var bsearch = require_search_bounds();
    var orient = require_orientation()[3];
    var EVENT_POINT = 0;
    var EVENT_END = 1;
    var EVENT_START = 2;
    module2.exports = monotoneTriangulate;
    function PartialHull(a, b, idx, lowerIds, upperIds) {
      this.a = a;
      this.b = b;
      this.idx = idx;
      this.lowerIds = lowerIds;
      this.upperIds = upperIds;
    }
    function Event(a, b, type, idx) {
      this.a = a;
      this.b = b;
      this.type = type;
      this.idx = idx;
    }
    function compareEvent(a, b) {
      var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;
      if (d) {
        return d;
      }
      if (a.type !== EVENT_POINT) {
        d = orient(a.a, a.b, b.b);
        if (d) {
          return d;
        }
      }
      return a.idx - b.idx;
    }
    function testPoint(hull, p) {
      return orient(hull.a, hull.b, p);
    }
    function addPoint(cells, hulls, points, p, idx) {
      var lo = bsearch.lt(hulls, p, testPoint);
      var hi = bsearch.gt(hulls, p, testPoint);
      for (var i = lo; i < hi; ++i) {
        var hull = hulls[i];
        var lowerIds = hull.lowerIds;
        var m = lowerIds.length;
        while (m > 1 && orient(
          points[lowerIds[m - 2]],
          points[lowerIds[m - 1]],
          p
        ) > 0) {
          cells.push(
            [
              lowerIds[m - 1],
              lowerIds[m - 2],
              idx
            ]
          );
          m -= 1;
        }
        lowerIds.length = m;
        lowerIds.push(idx);
        var upperIds = hull.upperIds;
        var m = upperIds.length;
        while (m > 1 && orient(
          points[upperIds[m - 2]],
          points[upperIds[m - 1]],
          p
        ) < 0) {
          cells.push(
            [
              upperIds[m - 2],
              upperIds[m - 1],
              idx
            ]
          );
          m -= 1;
        }
        upperIds.length = m;
        upperIds.push(idx);
      }
    }
    function findSplit(hull, edge) {
      var d;
      if (hull.a[0] < edge.a[0]) {
        d = orient(hull.a, hull.b, edge.a);
      } else {
        d = orient(edge.b, edge.a, hull.a);
      }
      if (d) {
        return d;
      }
      if (edge.b[0] < hull.b[0]) {
        d = orient(hull.a, hull.b, edge.b);
      } else {
        d = orient(edge.b, edge.a, hull.b);
      }
      return d || hull.idx - edge.idx;
    }
    function splitHulls(hulls, points, event) {
      var splitIdx = bsearch.le(hulls, event, findSplit);
      var hull = hulls[splitIdx];
      var upperIds = hull.upperIds;
      var x = upperIds[upperIds.length - 1];
      hull.upperIds = [x];
      hulls.splice(
        splitIdx + 1,
        0,
        new PartialHull(event.a, event.b, event.idx, [x], upperIds)
      );
    }
    function mergeHulls(hulls, points, event) {
      var tmp = event.a;
      event.a = event.b;
      event.b = tmp;
      var mergeIdx = bsearch.eq(hulls, event, findSplit);
      var upper = hulls[mergeIdx];
      var lower = hulls[mergeIdx - 1];
      lower.upperIds = upper.upperIds;
      hulls.splice(mergeIdx, 1);
    }
    function monotoneTriangulate(points, edges) {
      var numPoints = points.length;
      var numEdges = edges.length;
      var events = [];
      for (var i = 0; i < numPoints; ++i) {
        events.push(new Event(
          points[i],
          null,
          EVENT_POINT,
          i
        ));
      }
      for (var i = 0; i < numEdges; ++i) {
        var e = edges[i];
        var a = points[e[0]];
        var b = points[e[1]];
        if (a[0] < b[0]) {
          events.push(
            new Event(a, b, EVENT_START, i),
            new Event(b, a, EVENT_END, i)
          );
        } else if (a[0] > b[0]) {
          events.push(
            new Event(b, a, EVENT_START, i),
            new Event(a, b, EVENT_END, i)
          );
        }
      }
      events.sort(compareEvent);
      var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);
      var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])];
      var cells = [];
      for (var i = 0, numEvents = events.length; i < numEvents; ++i) {
        var event = events[i];
        var type = event.type;
        if (type === EVENT_POINT) {
          addPoint(cells, hull, points, event.a, event.idx);
        } else if (type === EVENT_START) {
          splitHulls(hull, points, event);
        } else {
          mergeHulls(hull, points, event);
        }
      }
      return cells;
    }
  }
});

// node_modules/cdt2d/lib/triangulation.js
var require_triangulation = __commonJS({
  "node_modules/cdt2d/lib/triangulation.js"(exports2, module2) {
    "use strict";
    var bsearch = require_search_bounds();
    module2.exports = createTriangulation;
    function Triangulation(stars, edges) {
      this.stars = stars;
      this.edges = edges;
    }
    var proto = Triangulation.prototype;
    function removePair(list, j, k) {
      for (var i = 1, n = list.length; i < n; i += 2) {
        if (list[i - 1] === j && list[i] === k) {
          list[i - 1] = list[n - 2];
          list[i] = list[n - 1];
          list.length = n - 2;
          return;
        }
      }
    }
    proto.isConstraint = /* @__PURE__ */ function() {
      var e = [0, 0];
      function compareLex(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      return function(i, j) {
        e[0] = Math.min(i, j);
        e[1] = Math.max(i, j);
        return bsearch.eq(this.edges, e, compareLex) >= 0;
      };
    }();
    proto.removeTriangle = function(i, j, k) {
      var stars = this.stars;
      removePair(stars[i], j, k);
      removePair(stars[j], k, i);
      removePair(stars[k], i, j);
    };
    proto.addTriangle = function(i, j, k) {
      var stars = this.stars;
      stars[i].push(j, k);
      stars[j].push(k, i);
      stars[k].push(i, j);
    };
    proto.opposite = function(j, i) {
      var list = this.stars[i];
      for (var k = 1, n = list.length; k < n; k += 2) {
        if (list[k] === j) {
          return list[k - 1];
        }
      }
      return -1;
    };
    proto.flip = function(i, j) {
      var a = this.opposite(i, j);
      var b = this.opposite(j, i);
      this.removeTriangle(i, j, a);
      this.removeTriangle(j, i, b);
      this.addTriangle(i, b, a);
      this.addTriangle(j, a, b);
    };
    proto.edges = function() {
      var stars = this.stars;
      var result = [];
      for (var i = 0, n = stars.length; i < n; ++i) {
        var list = stars[i];
        for (var j = 0, m = list.length; j < m; j += 2) {
          result.push([list[j], list[j + 1]]);
        }
      }
      return result;
    };
    proto.cells = function() {
      var stars = this.stars;
      var result = [];
      for (var i = 0, n = stars.length; i < n; ++i) {
        var list = stars[i];
        for (var j = 0, m = list.length; j < m; j += 2) {
          var s = list[j];
          var t = list[j + 1];
          if (i < Math.min(s, t)) {
            result.push([i, s, t]);
          }
        }
      }
      return result;
    };
    function createTriangulation(numVerts, edges) {
      var stars = new Array(numVerts);
      for (var i = 0; i < numVerts; ++i) {
        stars[i] = [];
      }
      return new Triangulation(stars, edges);
    }
  }
});

// node_modules/robust-in-sphere/in-sphere.js
var require_in_sphere = __commonJS({
  "node_modules/robust-in-sphere/in-sphere.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustDiff = require_robust_diff();
    var robustScale = require_robust_scale();
    var NUM_EXPAND = 6;
    function orientation(n) {
      var fn = n === 3 ? inSphere3 : n === 4 ? inSphere4 : n === 5 ? inSphere5 : inSphere6;
      return fn(robustSum, robustDiff, twoProduct, robustScale);
    }
    function inSphere0() {
      return 0;
    }
    function inSphere1() {
      return 0;
    }
    function inSphere2() {
      return 0;
    }
    function inSphere3(sum, diff, prod, scale) {
      function exactInSphere3(m0, m1, m2) {
        var w0 = prod(m0[0], m0[0]);
        var w0m1 = scale(w0, m1[0]);
        var w0m2 = scale(w0, m2[0]);
        var w1 = prod(m1[0], m1[0]);
        var w1m0 = scale(w1, m0[0]);
        var w1m2 = scale(w1, m2[0]);
        var w2 = prod(m2[0], m2[0]);
        var w2m0 = scale(w2, m0[0]);
        var w2m1 = scale(w2, m1[0]);
        var p = sum(diff(w2m1, w1m2), diff(w1m0, w0m1));
        var n = diff(w2m0, w0m2);
        var d = diff(p, n);
        return d[d.length - 1];
      }
      return exactInSphere3;
    }
    function inSphere4(sum, diff, prod, scale) {
      function exactInSphere4(m0, m1, m2, m3) {
        var w0 = sum(prod(m0[0], m0[0]), prod(m0[1], m0[1]));
        var w0m1 = scale(w0, m1[0]);
        var w0m2 = scale(w0, m2[0]);
        var w0m3 = scale(w0, m3[0]);
        var w1 = sum(prod(m1[0], m1[0]), prod(m1[1], m1[1]));
        var w1m0 = scale(w1, m0[0]);
        var w1m2 = scale(w1, m2[0]);
        var w1m3 = scale(w1, m3[0]);
        var w2 = sum(prod(m2[0], m2[0]), prod(m2[1], m2[1]));
        var w2m0 = scale(w2, m0[0]);
        var w2m1 = scale(w2, m1[0]);
        var w2m3 = scale(w2, m3[0]);
        var w3 = sum(prod(m3[0], m3[0]), prod(m3[1], m3[1]));
        var w3m0 = scale(w3, m0[0]);
        var w3m1 = scale(w3, m1[0]);
        var w3m2 = scale(w3, m2[0]);
        var p = sum(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))));
        var n = sum(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))));
        var d = diff(p, n);
        return d[d.length - 1];
      }
      return exactInSphere4;
    }
    function inSphere5(sum, diff, prod, scale) {
      function exactInSphere5(m0, m1, m2, m3, m4) {
        var w0 = sum(prod(m0[0], m0[0]), sum(prod(m0[1], m0[1]), prod(m0[2], m0[2])));
        var w0m1 = scale(w0, m1[0]);
        var w0m2 = scale(w0, m2[0]);
        var w0m3 = scale(w0, m3[0]);
        var w0m4 = scale(w0, m4[0]);
        var w1 = sum(prod(m1[0], m1[0]), sum(prod(m1[1], m1[1]), prod(m1[2], m1[2])));
        var w1m0 = scale(w1, m0[0]);
        var w1m2 = scale(w1, m2[0]);
        var w1m3 = scale(w1, m3[0]);
        var w1m4 = scale(w1, m4[0]);
        var w2 = sum(prod(m2[0], m2[0]), sum(prod(m2[1], m2[1]), prod(m2[2], m2[2])));
        var w2m0 = scale(w2, m0[0]);
        var w2m1 = scale(w2, m1[0]);
        var w2m3 = scale(w2, m3[0]);
        var w2m4 = scale(w2, m4[0]);
        var w3 = sum(prod(m3[0], m3[0]), sum(prod(m3[1], m3[1]), prod(m3[2], m3[2])));
        var w3m0 = scale(w3, m0[0]);
        var w3m1 = scale(w3, m1[0]);
        var w3m2 = scale(w3, m2[0]);
        var w3m4 = scale(w3, m4[0]);
        var w4 = sum(prod(m4[0], m4[0]), sum(prod(m4[1], m4[1]), prod(m4[2], m4[2])));
        var w4m0 = scale(w4, m0[0]);
        var w4m1 = scale(w4, m1[0]);
        var w4m2 = scale(w4, m2[0]);
        var w4m3 = scale(w4, m3[0]);
        var p = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])))), sum(sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2])))));
        var n = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))));
        var d = diff(p, n);
        return d[d.length - 1];
      }
      return exactInSphere5;
    }
    function inSphere6(sum, diff, prod, scale) {
      function exactInSphere6(m0, m1, m2, m3, m4, m5) {
        var w0 = sum(sum(prod(m0[0], m0[0]), prod(m0[1], m0[1])), sum(prod(m0[2], m0[2]), prod(m0[3], m0[3])));
        var w0m1 = scale(w0, m1[0]);
        var w0m2 = scale(w0, m2[0]);
        var w0m3 = scale(w0, m3[0]);
        var w0m4 = scale(w0, m4[0]);
        var w0m5 = scale(w0, m5[0]);
        var w1 = sum(sum(prod(m1[0], m1[0]), prod(m1[1], m1[1])), sum(prod(m1[2], m1[2]), prod(m1[3], m1[3])));
        var w1m0 = scale(w1, m0[0]);
        var w1m2 = scale(w1, m2[0]);
        var w1m3 = scale(w1, m3[0]);
        var w1m4 = scale(w1, m4[0]);
        var w1m5 = scale(w1, m5[0]);
        var w2 = sum(sum(prod(m2[0], m2[0]), prod(m2[1], m2[1])), sum(prod(m2[2], m2[2]), prod(m2[3], m2[3])));
        var w2m0 = scale(w2, m0[0]);
        var w2m1 = scale(w2, m1[0]);
        var w2m3 = scale(w2, m3[0]);
        var w2m4 = scale(w2, m4[0]);
        var w2m5 = scale(w2, m5[0]);
        var w3 = sum(sum(prod(m3[0], m3[0]), prod(m3[1], m3[1])), sum(prod(m3[2], m3[2]), prod(m3[3], m3[3])));
        var w3m0 = scale(w3, m0[0]);
        var w3m1 = scale(w3, m1[0]);
        var w3m2 = scale(w3, m2[0]);
        var w3m4 = scale(w3, m4[0]);
        var w3m5 = scale(w3, m5[0]);
        var w4 = sum(sum(prod(m4[0], m4[0]), prod(m4[1], m4[1])), sum(prod(m4[2], m4[2]), prod(m4[3], m4[3])));
        var w4m0 = scale(w4, m0[0]);
        var w4m1 = scale(w4, m1[0]);
        var w4m2 = scale(w4, m2[0]);
        var w4m3 = scale(w4, m3[0]);
        var w4m5 = scale(w4, m5[0]);
        var w5 = sum(sum(prod(m5[0], m5[0]), prod(m5[1], m5[1])), sum(prod(m5[2], m5[2]), prod(m5[3], m5[3])));
        var w5m0 = scale(w5, m0[0]);
        var w5m1 = scale(w5, m1[0]);
        var w5m2 = scale(w5, m2[0]);
        var w5m3 = scale(w5, m3[0]);
        var w5m4 = scale(w5, m4[0]);
        var p = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m1[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m3[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m5[3])))));
        var n = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m0[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m4[3])))));
        var d = diff(p, n);
        return d[d.length - 1];
      }
      return exactInSphere6;
    }
    var CACHED = [
      inSphere0,
      inSphere1,
      inSphere2
    ];
    function slowInSphere(args) {
      var proc2 = CACHED[args.length];
      if (!proc2) {
        proc2 = CACHED[args.length] = orientation(args.length);
      }
      return proc2.apply(void 0, args);
    }
    function proc(slow, o0, o1, o2, o3, o4, o5, o6) {
      function testInSphere(a0, a1, a2, a3, a4, a5) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return o2(a0, a1);
          case 3:
            return o3(a0, a1, a2);
          case 4:
            return o4(a0, a1, a2, a3);
          case 5:
            return o5(a0, a1, a2, a3, a4);
          case 6:
            return o6(a0, a1, a2, a3, a4, a5);
        }
        var s = new Array(arguments.length);
        for (var i = 0; i < arguments.length; ++i) {
          s[i] = arguments[i];
        }
        return slow(s);
      }
      return testInSphere;
    }
    function generateInSphereTest() {
      while (CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      module2.exports = proc.apply(void 0, [slowInSphere].concat(CACHED));
      for (var i = 0; i <= NUM_EXPAND; ++i) {
        module2.exports[i] = CACHED[i];
      }
    }
    generateInSphereTest();
  }
});

// node_modules/cdt2d/lib/delaunay.js
var require_delaunay = __commonJS({
  "node_modules/cdt2d/lib/delaunay.js"(exports2, module2) {
    "use strict";
    var inCircle = require_in_sphere()[4];
    var bsearch = require_search_bounds();
    module2.exports = delaunayRefine;
    function testFlip(points, triangulation, stack, a, b, x) {
      var y = triangulation.opposite(a, b);
      if (y < 0) {
        return;
      }
      if (b < a) {
        var tmp = a;
        a = b;
        b = tmp;
        tmp = x;
        x = y;
        y = tmp;
      }
      if (triangulation.isConstraint(a, b)) {
        return;
      }
      if (inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b);
      }
    }
    function delaunayRefine(points, triangulation) {
      var stack = [];
      var numPoints = points.length;
      var stars = triangulation.stars;
      for (var a = 0; a < numPoints; ++a) {
        var star = stars[a];
        for (var j = 1; j < star.length; j += 2) {
          var b = star[j];
          if (b < a) {
            continue;
          }
          if (triangulation.isConstraint(a, b)) {
            continue;
          }
          var x = star[j - 1], y = -1;
          for (var k = 1; k < star.length; k += 2) {
            if (star[k - 1] === b) {
              y = star[k];
              break;
            }
          }
          if (y < 0) {
            continue;
          }
          if (inCircle(points[a], points[b], points[x], points[y]) < 0) {
            stack.push(a, b);
          }
        }
      }
      while (stack.length > 0) {
        var b = stack.pop();
        var a = stack.pop();
        var x = -1, y = -1;
        var star = stars[a];
        for (var i = 1; i < star.length; i += 2) {
          var s = star[i - 1];
          var t = star[i];
          if (s === b) {
            y = t;
          } else if (t === b) {
            x = s;
          }
        }
        if (x < 0 || y < 0) {
          continue;
        }
        if (inCircle(points[a], points[b], points[x], points[y]) >= 0) {
          continue;
        }
        triangulation.flip(a, b);
        testFlip(points, triangulation, stack, x, a, y);
        testFlip(points, triangulation, stack, a, y, x);
        testFlip(points, triangulation, stack, y, b, x);
        testFlip(points, triangulation, stack, b, x, y);
      }
    }
  }
});

// node_modules/cdt2d/lib/filter.js
var require_filter = __commonJS({
  "node_modules/cdt2d/lib/filter.js"(exports2, module2) {
    "use strict";
    var bsearch = require_search_bounds();
    module2.exports = classifyFaces;
    function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
      this.cells = cells;
      this.neighbor = neighbor;
      this.flags = flags;
      this.constraint = constraint;
      this.active = active;
      this.next = next;
      this.boundary = boundary;
    }
    var proto = FaceIndex.prototype;
    function compareCell(a, b) {
      return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];
    }
    proto.locate = /* @__PURE__ */ function() {
      var key = [0, 0, 0];
      return function(a, b, c) {
        var x = a, y = b, z = c;
        if (b < c) {
          if (b < a) {
            x = b;
            y = c;
            z = a;
          }
        } else if (c < a) {
          x = c;
          y = a;
          z = b;
        }
        if (x < 0) {
          return -1;
        }
        key[0] = x;
        key[1] = y;
        key[2] = z;
        return bsearch.eq(this.cells, key, compareCell);
      };
    }();
    function indexCells(triangulation, infinity) {
      var cells = triangulation.cells();
      var nc = cells.length;
      for (var i = 0; i < nc; ++i) {
        var c = cells[i];
        var x = c[0], y = c[1], z = c[2];
        if (y < z) {
          if (y < x) {
            c[0] = y;
            c[1] = z;
            c[2] = x;
          }
        } else if (z < x) {
          c[0] = z;
          c[1] = x;
          c[2] = y;
        }
      }
      cells.sort(compareCell);
      var flags = new Array(nc);
      for (var i = 0; i < flags.length; ++i) {
        flags[i] = 0;
      }
      var active = [];
      var next = [];
      var neighbor = new Array(3 * nc);
      var constraint = new Array(3 * nc);
      var boundary = null;
      if (infinity) {
        boundary = [];
      }
      var index = new FaceIndex(
        cells,
        neighbor,
        constraint,
        flags,
        active,
        next,
        boundary
      );
      for (var i = 0; i < nc; ++i) {
        var c = cells[i];
        for (var j = 0; j < 3; ++j) {
          var x = c[j], y = c[(j + 1) % 3];
          var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));
          var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);
          if (a < 0) {
            if (b) {
              next.push(i);
            } else {
              active.push(i);
              flags[i] = 1;
            }
            if (infinity) {
              boundary.push([y, x, -1]);
            }
          }
        }
      }
      return index;
    }
    function filterCells(cells, flags, target) {
      var ptr = 0;
      for (var i = 0; i < cells.length; ++i) {
        if (flags[i] === target) {
          cells[ptr++] = cells[i];
        }
      }
      cells.length = ptr;
      return cells;
    }
    function classifyFaces(triangulation, target, infinity) {
      var index = indexCells(triangulation, infinity);
      if (target === 0) {
        if (infinity) {
          return index.cells.concat(index.boundary);
        } else {
          return index.cells;
        }
      }
      var side = 1;
      var active = index.active;
      var next = index.next;
      var flags = index.flags;
      var cells = index.cells;
      var constraint = index.constraint;
      var neighbor = index.neighbor;
      while (active.length > 0 || next.length > 0) {
        while (active.length > 0) {
          var t = active.pop();
          if (flags[t] === -side) {
            continue;
          }
          flags[t] = side;
          var c = cells[t];
          for (var j = 0; j < 3; ++j) {
            var f = neighbor[3 * t + j];
            if (f >= 0 && flags[f] === 0) {
              if (constraint[3 * t + j]) {
                next.push(f);
              } else {
                active.push(f);
                flags[f] = side;
              }
            }
          }
        }
        var tmp = next;
        next = active;
        active = tmp;
        next.length = 0;
        side = -side;
      }
      var result = filterCells(cells, flags, target);
      if (infinity) {
        return result.concat(index.boundary);
      }
      return result;
    }
  }
});

// node_modules/cdt2d/cdt2d.js
var require_cdt2d = __commonJS({
  "node_modules/cdt2d/cdt2d.js"(exports2, module2) {
    "use strict";
    var monotoneTriangulate = require_monotone();
    var makeIndex = require_triangulation();
    var delaunayFlip = require_delaunay();
    var filterTriangulation = require_filter();
    module2.exports = cdt2d;
    function canonicalizeEdge(e) {
      return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];
    }
    function compareEdge(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }
    function canonicalizeEdges(edges) {
      return edges.map(canonicalizeEdge).sort(compareEdge);
    }
    function getDefault(options, property, dflt) {
      if (property in options) {
        return options[property];
      }
      return dflt;
    }
    function cdt2d(points, edges, options) {
      if (!Array.isArray(edges)) {
        options = edges || {};
        edges = [];
      } else {
        options = options || {};
        edges = edges || [];
      }
      var delaunay = !!getDefault(options, "delaunay", true);
      var interior = !!getDefault(options, "interior", true);
      var exterior = !!getDefault(options, "exterior", true);
      var infinity = !!getDefault(options, "infinity", false);
      if (!interior && !exterior || points.length === 0) {
        return [];
      }
      var cells = monotoneTriangulate(points, edges);
      if (delaunay || interior !== exterior || infinity) {
        var triangulation = makeIndex(points.length, canonicalizeEdges(edges));
        for (var i = 0; i < cells.length; ++i) {
          var f = cells[i];
          triangulation.addTriangle(f[0], f[1], f[2]);
        }
        if (delaunay) {
          delaunayFlip(points, triangulation);
        }
        if (!exterior) {
          return filterTriangulation(triangulation, -1);
        } else if (!interior) {
          return filterTriangulation(triangulation, 1, infinity);
        } else if (infinity) {
          return filterTriangulation(triangulation, 0, infinity);
        } else {
          return triangulation.cells();
        }
      } else {
        return cells;
      }
    }
  }
});

// node_modules/edges-to-adjacency-list/e2a.js
var require_e2a = __commonJS({
  "node_modules/edges-to-adjacency-list/e2a.js"(exports2, module2) {
    "use strict";
    module2.exports = edgeToAdjacency;
    var uniq = require_uniq();
    function edgeToAdjacency(edges, numVertices) {
      var numEdges = edges.length;
      if (typeof numVertices !== "number") {
        numVertices = 0;
        for (var i = 0; i < numEdges; ++i) {
          var e = edges[i];
          numVertices = Math.max(numVertices, e[0], e[1]);
        }
        numVertices = (numVertices | 0) + 1;
      }
      numVertices = numVertices | 0;
      var adj = new Array(numVertices);
      for (var i = 0; i < numVertices; ++i) {
        adj[i] = [];
      }
      for (var i = 0; i < numEdges; ++i) {
        var e = edges[i];
        adj[e[0]].push(e[1]);
        adj[e[1]].push(e[0]);
      }
      for (var j = 0; j < numVertices; ++j) {
        uniq(adj[j], function(a, b) {
          return a - b;
        });
      }
      return adj;
    }
  }
});

// node_modules/compare-angle/node_modules/signum/sgn.js
var require_sgn = __commonJS({
  "node_modules/compare-angle/node_modules/signum/sgn.js"(exports2, module2) {
    "use strict";
    module2.exports = function signum(x) {
      if (x < 0) {
        return -1;
      }
      if (x > 0) {
        return 1;
      }
      return 0;
    };
  }
});

// node_modules/robust-product/product.js
var require_product = __commonJS({
  "node_modules/robust-product/product.js"(exports2, module2) {
    "use strict";
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    module2.exports = robustProduct;
    function robustProduct(a, b) {
      if (a.length === 1) {
        return robustScale(b, a[0]);
      }
      if (b.length === 1) {
        return robustScale(a, b[0]);
      }
      if (a.length === 0 || b.length === 0) {
        return [0];
      }
      var r = [0];
      if (a.length < b.length) {
        for (var i = 0; i < a.length; ++i) {
          r = robustSum(r, robustScale(b, a[i]));
        }
      } else {
        for (var i = 0; i < b.length; ++i) {
          r = robustSum(r, robustScale(a, b[i]));
        }
      }
      return r;
    }
  }
});

// node_modules/compare-angle/cmpangle.js
var require_cmpangle = __commonJS({
  "node_modules/compare-angle/cmpangle.js"(exports2, module2) {
    "use strict";
    module2.exports = compareAngle;
    var orient = require_orientation();
    var sgn = require_sgn();
    var twoSum = require_two_sum();
    var robustProduct = require_product();
    var robustSum = require_robust_sum();
    function testInterior(a, b, c) {
      var x0 = twoSum(a[0], -b[0]);
      var y0 = twoSum(a[1], -b[1]);
      var x1 = twoSum(c[0], -b[0]);
      var y1 = twoSum(c[1], -b[1]);
      var d = robustSum(
        robustProduct(x0, x1),
        robustProduct(y0, y1)
      );
      return d[d.length - 1] >= 0;
    }
    function compareAngle(a, b, c, d) {
      var bcd = orient(b, c, d);
      if (bcd === 0) {
        var sabc = sgn(orient(a, b, c));
        var sabd = sgn(orient(a, b, d));
        if (sabc === sabd) {
          if (sabc === 0) {
            var ic = testInterior(a, b, c);
            var id = testInterior(a, b, d);
            if (ic === id) {
              return 0;
            } else if (ic) {
              return 1;
            } else {
              return -1;
            }
          }
          return 0;
        } else if (sabd === 0) {
          if (sabc > 0) {
            return -1;
          } else if (testInterior(a, b, d)) {
            return -1;
          } else {
            return 1;
          }
        } else if (sabc === 0) {
          if (sabd > 0) {
            return 1;
          } else if (testInterior(a, b, c)) {
            return 1;
          } else {
            return -1;
          }
        }
        return sgn(sabd - sabc);
      }
      var abc = orient(a, b, c);
      if (abc > 0) {
        if (bcd > 0 && orient(a, b, d) > 0) {
          return 1;
        }
        return -1;
      } else if (abc < 0) {
        if (bcd > 0 || orient(a, b, d) > 0) {
          return 1;
        }
        return -1;
      } else {
        var abd = orient(a, b, d);
        if (abd > 0) {
          return 1;
        } else {
          if (testInterior(a, b, c)) {
            return 1;
          } else {
            return -1;
          }
        }
      }
    }
  }
});

// node_modules/planar-dual/loops.js
var require_loops = __commonJS({
  "node_modules/planar-dual/loops.js"(exports2, module2) {
    "use strict";
    module2.exports = planarDual;
    var compareAngle = require_cmpangle();
    function planarDual(cells, positions) {
      var numVertices = positions.length | 0;
      var numEdges = cells.length;
      var adj = [new Array(numVertices), new Array(numVertices)];
      for (var i = 0; i < numVertices; ++i) {
        adj[0][i] = [];
        adj[1][i] = [];
      }
      for (var i = 0; i < numEdges; ++i) {
        var c = cells[i];
        adj[0][c[0]].push(c);
        adj[1][c[1]].push(c);
      }
      var cycles = [];
      for (var i = 0; i < numVertices; ++i) {
        if (adj[0][i].length + adj[1][i].length === 0) {
          cycles.push([i]);
        }
      }
      function cut(c2, i2) {
        var a = adj[i2][c2[i2]];
        a.splice(a.indexOf(c2), 1);
      }
      function next(a, b, noCut) {
        var nextCell, nextVertex, nextDir;
        for (var i2 = 0; i2 < 2; ++i2) {
          if (adj[i2][b].length > 0) {
            nextCell = adj[i2][b][0];
            nextDir = i2;
            break;
          }
        }
        nextVertex = nextCell[nextDir ^ 1];
        for (var dir = 0; dir < 2; ++dir) {
          var nbhd = adj[dir][b];
          for (var k = 0; k < nbhd.length; ++k) {
            var e = nbhd[k];
            var p = e[dir ^ 1];
            var cmp = compareAngle(
              positions[a],
              positions[b],
              positions[nextVertex],
              positions[p]
            );
            if (cmp > 0) {
              nextCell = e;
              nextVertex = p;
              nextDir = dir;
            }
          }
        }
        if (noCut) {
          return nextVertex;
        }
        if (nextCell) {
          cut(nextCell, nextDir);
        }
        return nextVertex;
      }
      function extractCycle(v, dir) {
        var e0 = adj[dir][v][0];
        var cycle = [v];
        cut(e0, dir);
        var u = e0[dir ^ 1];
        var d0 = dir;
        while (true) {
          while (u !== v) {
            cycle.push(u);
            u = next(cycle[cycle.length - 2], u, false);
          }
          if (adj[0][v].length + adj[1][v].length === 0) {
            break;
          }
          var a = cycle[cycle.length - 1];
          var b = v;
          var c2 = cycle[1];
          var d = next(a, b, true);
          if (compareAngle(positions[a], positions[b], positions[c2], positions[d]) < 0) {
            break;
          }
          cycle.push(v);
          u = next(a, b);
        }
        return cycle;
      }
      function shouldGlue(pcycle2, ncycle2) {
        return ncycle2[1] === ncycle2[ncycle2.length - 1];
      }
      for (var i = 0; i < numVertices; ++i) {
        for (var j = 0; j < 2; ++j) {
          var pcycle = [];
          while (adj[j][i].length > 0) {
            var ni = adj[0][i].length;
            var ncycle = extractCycle(i, j);
            if (shouldGlue(pcycle, ncycle)) {
              pcycle.push.apply(pcycle, ncycle);
            } else {
              if (pcycle.length > 0) {
                cycles.push(pcycle);
              }
              pcycle = ncycle;
            }
          }
          if (pcycle.length > 0) {
            cycles.push(pcycle);
          }
        }
      }
      return cycles;
    }
  }
});

// node_modules/functional-red-black-tree/rbtree.js
var require_rbtree = __commonJS({
  "node_modules/functional-red-black-tree/rbtree.js"(exports2, module2) {
    "use strict";
    module2.exports = createRBTree;
    var RED = 0;
    var BLACK = 1;
    function RBNode(color, key, value, left, right, count) {
      this._color = color;
      this.key = key;
      this.value = value;
      this.left = left;
      this.right = right;
      this._count = count;
    }
    function cloneNode(node) {
      return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
    }
    function repaint(color, node) {
      return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
    }
    function recount(node) {
      node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
    }
    function RedBlackTree(compare, root) {
      this._compare = compare;
      this.root = root;
    }
    var proto = RedBlackTree.prototype;
    Object.defineProperty(proto, "keys", {
      get: function() {
        var result = [];
        this.forEach(function(k, v) {
          result.push(k);
        });
        return result;
      }
    });
    Object.defineProperty(proto, "values", {
      get: function() {
        var result = [];
        this.forEach(function(k, v) {
          result.push(v);
        });
        return result;
      }
    });
    Object.defineProperty(proto, "length", {
      get: function() {
        if (this.root) {
          return this.root._count;
        }
        return 0;
      }
    });
    proto.insert = function(key, value) {
      var cmp = this._compare;
      var n = this.root;
      var n_stack = [];
      var d_stack = [];
      while (n) {
        var d = cmp(key, n.key);
        n_stack.push(n);
        d_stack.push(d);
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      n_stack.push(new RBNode(RED, key, value, null, null, 1));
      for (var s = n_stack.length - 2; s >= 0; --s) {
        var n = n_stack[s];
        if (d_stack[s] <= 0) {
          n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
        } else {
          n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
        }
      }
      for (var s = n_stack.length - 1; s > 1; --s) {
        var p = n_stack[s - 1];
        var n = n_stack[s];
        if (p._color === BLACK || n._color === BLACK) {
          break;
        }
        var pp = n_stack[s - 2];
        if (pp.left === p) {
          if (p.left === n) {
            var y = pp.right;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.right = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              pp._color = RED;
              pp.left = p.right;
              p._color = BLACK;
              p.right = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n;
              recount(pp);
              recount(p);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = p;
                } else {
                  ppp.right = p;
                }
              }
              break;
            }
          } else {
            var y = pp.right;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.right = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              p.right = n.left;
              pp._color = RED;
              pp.left = n.right;
              n._color = BLACK;
              n.left = p;
              n.right = pp;
              n_stack[s - 2] = n;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = n;
                } else {
                  ppp.right = n;
                }
              }
              break;
            }
          }
        } else {
          if (p.right === n) {
            var y = pp.left;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.left = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              pp._color = RED;
              pp.right = p.left;
              p._color = BLACK;
              p.left = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n;
              recount(pp);
              recount(p);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = p;
                } else {
                  ppp.left = p;
                }
              }
              break;
            }
          } else {
            var y = pp.left;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.left = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              p.left = n.right;
              pp._color = RED;
              pp.right = n.left;
              n._color = BLACK;
              n.right = p;
              n.left = pp;
              n_stack[s - 2] = n;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = n;
                } else {
                  ppp.left = n;
                }
              }
              break;
            }
          }
        }
      }
      n_stack[0]._color = BLACK;
      return new RedBlackTree(cmp, n_stack[0]);
    };
    function doVisitFull(visit, node) {
      if (node.left) {
        var v = doVisitFull(visit, node.left);
        if (v) {
          return v;
        }
      }
      var v = visit(node.key, node.value);
      if (v) {
        return v;
      }
      if (node.right) {
        return doVisitFull(visit, node.right);
      }
    }
    function doVisitHalf(lo, compare, visit, node) {
      var l = compare(lo, node.key);
      if (l <= 0) {
        if (node.left) {
          var v = doVisitHalf(lo, compare, visit, node.left);
          if (v) {
            return v;
          }
        }
        var v = visit(node.key, node.value);
        if (v) {
          return v;
        }
      }
      if (node.right) {
        return doVisitHalf(lo, compare, visit, node.right);
      }
    }
    function doVisit(lo, hi, compare, visit, node) {
      var l = compare(lo, node.key);
      var h = compare(hi, node.key);
      var v;
      if (l <= 0) {
        if (node.left) {
          v = doVisit(lo, hi, compare, visit, node.left);
          if (v) {
            return v;
          }
        }
        if (h > 0) {
          v = visit(node.key, node.value);
          if (v) {
            return v;
          }
        }
      }
      if (h > 0 && node.right) {
        return doVisit(lo, hi, compare, visit, node.right);
      }
    }
    proto.forEach = function rbTreeForEach(visit, lo, hi) {
      if (!this.root) {
        return;
      }
      switch (arguments.length) {
        case 1:
          return doVisitFull(visit, this.root);
          break;
        case 2:
          return doVisitHalf(lo, this._compare, visit, this.root);
          break;
        case 3:
          if (this._compare(lo, hi) >= 0) {
            return;
          }
          return doVisit(lo, hi, this._compare, visit, this.root);
          break;
      }
    };
    Object.defineProperty(proto, "begin", {
      get: function() {
        var stack = [];
        var n = this.root;
        while (n) {
          stack.push(n);
          n = n.left;
        }
        return new RedBlackTreeIterator(this, stack);
      }
    });
    Object.defineProperty(proto, "end", {
      get: function() {
        var stack = [];
        var n = this.root;
        while (n) {
          stack.push(n);
          n = n.right;
        }
        return new RedBlackTreeIterator(this, stack);
      }
    });
    proto.at = function(idx) {
      if (idx < 0) {
        return new RedBlackTreeIterator(this, []);
      }
      var n = this.root;
      var stack = [];
      while (true) {
        stack.push(n);
        if (n.left) {
          if (idx < n.left._count) {
            n = n.left;
            continue;
          }
          idx -= n.left._count;
        }
        if (!idx) {
          return new RedBlackTreeIterator(this, stack);
        }
        idx -= 1;
        if (n.right) {
          if (idx >= n.right._count) {
            break;
          }
          n = n.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(this, []);
    };
    proto.ge = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.gt = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.lt = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.le = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.find = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d === 0) {
          return new RedBlackTreeIterator(this, stack);
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      return new RedBlackTreeIterator(this, []);
    };
    proto.remove = function(key) {
      var iter = this.find(key);
      if (iter) {
        return iter.remove();
      }
      return this;
    };
    proto.get = function(key) {
      var cmp = this._compare;
      var n = this.root;
      while (n) {
        var d = cmp(key, n.key);
        if (d === 0) {
          return n.value;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      return;
    };
    function RedBlackTreeIterator(tree, stack) {
      this.tree = tree;
      this._stack = stack;
    }
    var iproto = RedBlackTreeIterator.prototype;
    Object.defineProperty(iproto, "valid", {
      get: function() {
        return this._stack.length > 0;
      }
    });
    Object.defineProperty(iproto, "node", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1];
        }
        return null;
      },
      enumerable: true
    });
    iproto.clone = function() {
      return new RedBlackTreeIterator(this.tree, this._stack.slice());
    };
    function swapNode(n, v) {
      n.key = v.key;
      n.value = v.value;
      n.left = v.left;
      n.right = v.right;
      n._color = v._color;
      n._count = v._count;
    }
    function fixDoubleBlack(stack) {
      var n, p, s, z;
      for (var i = stack.length - 1; i >= 0; --i) {
        n = stack[i];
        if (i === 0) {
          n._color = BLACK;
          return;
        }
        p = stack[i - 1];
        if (p.left === n) {
          s = p.right;
          if (s.right && s.right._color === RED) {
            s = p.right = cloneNode(s);
            z = s.right = cloneNode(s.right);
            p.right = s.left;
            s.left = p;
            s.right = z;
            s._color = p._color;
            n._color = BLACK;
            p._color = BLACK;
            z._color = BLACK;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s.left && s.left._color === RED) {
            s = p.right = cloneNode(s);
            z = s.left = cloneNode(s.left);
            p.right = z.left;
            s.left = z.right;
            z.left = p;
            z.right = s;
            z._color = p._color;
            p._color = BLACK;
            s._color = BLACK;
            n._color = BLACK;
            recount(p);
            recount(s);
            recount(z);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = z;
              } else {
                pp.right = z;
              }
            }
            stack[i - 1] = z;
            return;
          }
          if (s._color === BLACK) {
            if (p._color === RED) {
              p._color = BLACK;
              p.right = repaint(RED, s);
              return;
            } else {
              p.right = repaint(RED, s);
              continue;
            }
          } else {
            s = cloneNode(s);
            p.right = s.left;
            s.left = p;
            s._color = p._color;
            p._color = RED;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        } else {
          s = p.left;
          if (s.left && s.left._color === RED) {
            s = p.left = cloneNode(s);
            z = s.left = cloneNode(s.left);
            p.left = s.right;
            s.right = p;
            s.left = z;
            s._color = p._color;
            n._color = BLACK;
            p._color = BLACK;
            z._color = BLACK;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s.right && s.right._color === RED) {
            s = p.left = cloneNode(s);
            z = s.right = cloneNode(s.right);
            p.left = z.right;
            s.right = z.left;
            z.right = p;
            z.left = s;
            z._color = p._color;
            p._color = BLACK;
            s._color = BLACK;
            n._color = BLACK;
            recount(p);
            recount(s);
            recount(z);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = z;
              } else {
                pp.left = z;
              }
            }
            stack[i - 1] = z;
            return;
          }
          if (s._color === BLACK) {
            if (p._color === RED) {
              p._color = BLACK;
              p.left = repaint(RED, s);
              return;
            } else {
              p.left = repaint(RED, s);
              continue;
            }
          } else {
            s = cloneNode(s);
            p.left = s.right;
            s.right = p;
            s._color = p._color;
            p._color = RED;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        }
      }
    }
    iproto.remove = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return this.tree;
      }
      var cstack = new Array(stack.length);
      var n = stack[stack.length - 1];
      cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
      for (var i = stack.length - 2; i >= 0; --i) {
        var n = stack[i];
        if (n.left === stack[i + 1]) {
          cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
        } else {
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
      }
      n = cstack[cstack.length - 1];
      if (n.left && n.right) {
        var split = cstack.length;
        n = n.left;
        while (n.right) {
          cstack.push(n);
          n = n.right;
        }
        var v = cstack[split - 1];
        cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
        cstack[split - 1].key = n.key;
        cstack[split - 1].value = n.value;
        for (var i = cstack.length - 2; i >= split; --i) {
          n = cstack[i];
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
        cstack[split - 1].left = cstack[split];
      }
      n = cstack[cstack.length - 1];
      if (n._color === RED) {
        var p = cstack[cstack.length - 2];
        if (p.left === n) {
          p.left = null;
        } else if (p.right === n) {
          p.right = null;
        }
        cstack.pop();
        for (var i = 0; i < cstack.length; ++i) {
          cstack[i]._count--;
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      } else {
        if (n.left || n.right) {
          if (n.left) {
            swapNode(n, n.left);
          } else if (n.right) {
            swapNode(n, n.right);
          }
          n._color = BLACK;
          for (var i = 0; i < cstack.length - 1; ++i) {
            cstack[i]._count--;
          }
          return new RedBlackTree(this.tree._compare, cstack[0]);
        } else if (cstack.length === 1) {
          return new RedBlackTree(this.tree._compare, null);
        } else {
          for (var i = 0; i < cstack.length; ++i) {
            cstack[i]._count--;
          }
          var parent = cstack[cstack.length - 2];
          fixDoubleBlack(cstack);
          if (parent.left === n) {
            parent.left = null;
          } else {
            parent.right = null;
          }
        }
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    };
    Object.defineProperty(iproto, "key", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1].key;
        }
        return;
      },
      enumerable: true
    });
    Object.defineProperty(iproto, "value", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1].value;
        }
        return;
      },
      enumerable: true
    });
    Object.defineProperty(iproto, "index", {
      get: function() {
        var idx = 0;
        var stack = this._stack;
        if (stack.length === 0) {
          var r = this.tree.root;
          if (r) {
            return r._count;
          }
          return 0;
        } else if (stack[stack.length - 1].left) {
          idx = stack[stack.length - 1].left._count;
        }
        for (var s = stack.length - 2; s >= 0; --s) {
          if (stack[s + 1] === stack[s].right) {
            ++idx;
            if (stack[s].left) {
              idx += stack[s].left._count;
            }
          }
        }
        return idx;
      },
      enumerable: true
    });
    iproto.next = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return;
      }
      var n = stack[stack.length - 1];
      if (n.right) {
        n = n.right;
        while (n) {
          stack.push(n);
          n = n.left;
        }
      } else {
        stack.pop();
        while (stack.length > 0 && stack[stack.length - 1].right === n) {
          n = stack[stack.length - 1];
          stack.pop();
        }
      }
    };
    Object.defineProperty(iproto, "hasNext", {
      get: function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].right) {
          return true;
        }
        for (var s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].left === stack[s]) {
            return true;
          }
        }
        return false;
      }
    });
    iproto.update = function(value) {
      var stack = this._stack;
      if (stack.length === 0) {
        throw new Error("Can't update empty node!");
      }
      var cstack = new Array(stack.length);
      var n = stack[stack.length - 1];
      cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
      for (var i = stack.length - 2; i >= 0; --i) {
        n = stack[i];
        if (n.left === stack[i + 1]) {
          cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
        } else {
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    };
    iproto.prev = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return;
      }
      var n = stack[stack.length - 1];
      if (n.left) {
        n = n.left;
        while (n) {
          stack.push(n);
          n = n.right;
        }
      } else {
        stack.pop();
        while (stack.length > 0 && stack[stack.length - 1].left === n) {
          n = stack[stack.length - 1];
          stack.pop();
        }
      }
    };
    Object.defineProperty(iproto, "hasPrev", {
      get: function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].left) {
          return true;
        }
        for (var s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].right === stack[s]) {
            return true;
          }
        }
        return false;
      }
    });
    function defaultCompare(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function createRBTree(compare) {
      return new RedBlackTree(compare || defaultCompare, null);
    }
  }
});

// node_modules/slab-decomposition/lib/order-segments.js
var require_order_segments = __commonJS({
  "node_modules/slab-decomposition/lib/order-segments.js"(exports2, module2) {
    "use strict";
    module2.exports = orderSegments;
    var orient = require_orientation();
    function horizontalOrder(a, b) {
      var bl, br;
      if (b[0][0] < b[1][0]) {
        bl = b[0];
        br = b[1];
      } else if (b[0][0] > b[1][0]) {
        bl = b[1];
        br = b[0];
      } else {
        var alo = Math.min(a[0][1], a[1][1]);
        var ahi = Math.max(a[0][1], a[1][1]);
        var blo = Math.min(b[0][1], b[1][1]);
        var bhi = Math.max(b[0][1], b[1][1]);
        if (ahi < blo) {
          return ahi - blo;
        }
        if (alo > bhi) {
          return alo - bhi;
        }
        return ahi - bhi;
      }
      var al, ar;
      if (a[0][1] < a[1][1]) {
        al = a[0];
        ar = a[1];
      } else {
        al = a[1];
        ar = a[0];
      }
      var d = orient(br, bl, al);
      if (d) {
        return d;
      }
      d = orient(br, bl, ar);
      if (d) {
        return d;
      }
      return ar - br;
    }
    function orderSegments(b, a) {
      var al, ar;
      if (a[0][0] < a[1][0]) {
        al = a[0];
        ar = a[1];
      } else if (a[0][0] > a[1][0]) {
        al = a[1];
        ar = a[0];
      } else {
        return horizontalOrder(a, b);
      }
      var bl, br;
      if (b[0][0] < b[1][0]) {
        bl = b[0];
        br = b[1];
      } else if (b[0][0] > b[1][0]) {
        bl = b[1];
        br = b[0];
      } else {
        return -horizontalOrder(b, a);
      }
      var d1 = orient(al, ar, br);
      var d2 = orient(al, ar, bl);
      if (d1 < 0) {
        if (d2 <= 0) {
          return d1;
        }
      } else if (d1 > 0) {
        if (d2 >= 0) {
          return d1;
        }
      } else if (d2) {
        return d2;
      }
      d1 = orient(br, bl, ar);
      d2 = orient(br, bl, al);
      if (d1 < 0) {
        if (d2 <= 0) {
          return d1;
        }
      } else if (d1 > 0) {
        if (d2 >= 0) {
          return d1;
        }
      } else if (d2) {
        return d2;
      }
      return ar[0] - br[0];
    }
  }
});

// node_modules/slab-decomposition/slabs.js
var require_slabs = __commonJS({
  "node_modules/slab-decomposition/slabs.js"(exports2, module2) {
    "use strict";
    module2.exports = createSlabDecomposition;
    var bounds = require_search_bounds();
    var createRBTree = require_rbtree();
    var orient = require_orientation();
    var orderSegments = require_order_segments();
    function SlabDecomposition(slabs, coordinates, horizontal) {
      this.slabs = slabs;
      this.coordinates = coordinates;
      this.horizontal = horizontal;
    }
    var proto = SlabDecomposition.prototype;
    function compareHorizontal(e, y) {
      return e.y - y;
    }
    function searchBucket(root, p) {
      var lastNode = null;
      while (root) {
        var seg = root.key;
        var l, r;
        if (seg[0][0] < seg[1][0]) {
          l = seg[0];
          r = seg[1];
        } else {
          l = seg[1];
          r = seg[0];
        }
        var o = orient(l, r, p);
        if (o < 0) {
          root = root.left;
        } else if (o > 0) {
          if (p[0] !== seg[1][0]) {
            lastNode = root;
            root = root.right;
          } else {
            var val = searchBucket(root.right, p);
            if (val) {
              return val;
            }
            root = root.left;
          }
        } else {
          if (p[0] !== seg[1][0]) {
            return root;
          } else {
            var val = searchBucket(root.right, p);
            if (val) {
              return val;
            }
            root = root.left;
          }
        }
      }
      return lastNode;
    }
    proto.castUp = function(p) {
      var bucket = bounds.le(this.coordinates, p[0]);
      if (bucket < 0) {
        return -1;
      }
      var root = this.slabs[bucket];
      var hitNode = searchBucket(this.slabs[bucket], p);
      var lastHit = -1;
      if (hitNode) {
        lastHit = hitNode.value;
      }
      if (this.coordinates[bucket] === p[0]) {
        var lastSegment = null;
        if (hitNode) {
          lastSegment = hitNode.key;
        }
        if (bucket > 0) {
          var otherHitNode = searchBucket(this.slabs[bucket - 1], p);
          if (otherHitNode) {
            if (lastSegment) {
              if (orderSegments(otherHitNode.key, lastSegment) > 0) {
                lastSegment = otherHitNode.key;
                lastHit = otherHitNode.value;
              }
            } else {
              lastHit = otherHitNode.value;
              lastSegment = otherHitNode.key;
            }
          }
        }
        var horiz = this.horizontal[bucket];
        if (horiz.length > 0) {
          var hbucket = bounds.ge(horiz, p[1], compareHorizontal);
          if (hbucket < horiz.length) {
            var e = horiz[hbucket];
            if (p[1] === e.y) {
              if (e.closed) {
                return e.index;
              } else {
                while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {
                  hbucket = hbucket + 1;
                  e = horiz[hbucket];
                  if (e.closed) {
                    return e.index;
                  }
                }
                if (e.y === p[1] && !e.start) {
                  hbucket = hbucket + 1;
                  if (hbucket >= horiz.length) {
                    return lastHit;
                  }
                  e = horiz[hbucket];
                }
              }
            }
            if (e.start) {
              if (lastSegment) {
                var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);
                if (lastSegment[0][0] > lastSegment[1][0]) {
                  o = -o;
                }
                if (o > 0) {
                  lastHit = e.index;
                }
              } else {
                lastHit = e.index;
              }
            } else if (e.y !== p[1]) {
              lastHit = e.index;
            }
          }
        }
      }
      return lastHit;
    };
    function IntervalSegment(y, index, start, closed) {
      this.y = y;
      this.index = index;
      this.start = start;
      this.closed = closed;
    }
    function Event(x, segment, create, index) {
      this.x = x;
      this.segment = segment;
      this.create = create;
      this.index = index;
    }
    function createSlabDecomposition(segments) {
      var numSegments = segments.length;
      var numEvents = 2 * numSegments;
      var events = new Array(numEvents);
      for (var i = 0; i < numSegments; ++i) {
        var s = segments[i];
        var f = s[0][0] < s[1][0];
        events[2 * i] = new Event(s[0][0], s, f, i);
        events[2 * i + 1] = new Event(s[1][0], s, !f, i);
      }
      events.sort(function(a, b) {
        var d = a.x - b.x;
        if (d) {
          return d;
        }
        d = a.create - b.create;
        if (d) {
          return d;
        }
        return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);
      });
      var tree = createRBTree(orderSegments);
      var slabs = [];
      var lines = [];
      var horizontal = [];
      var lastX = -Infinity;
      for (var i = 0; i < numEvents; ) {
        var x = events[i].x;
        var horiz = [];
        while (i < numEvents) {
          var e = events[i];
          if (e.x !== x) {
            break;
          }
          i += 1;
          if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
            if (e.create) {
              if (e.segment[0][1] < e.segment[1][1]) {
                horiz.push(new IntervalSegment(
                  e.segment[0][1],
                  e.index,
                  true,
                  true
                ));
                horiz.push(new IntervalSegment(
                  e.segment[1][1],
                  e.index,
                  false,
                  false
                ));
              } else {
                horiz.push(new IntervalSegment(
                  e.segment[1][1],
                  e.index,
                  true,
                  false
                ));
                horiz.push(new IntervalSegment(
                  e.segment[0][1],
                  e.index,
                  false,
                  true
                ));
              }
            }
          } else {
            if (e.create) {
              tree = tree.insert(e.segment, e.index);
            } else {
              tree = tree.remove(e.segment);
            }
          }
        }
        slabs.push(tree.root);
        lines.push(x);
        horizontal.push(horiz);
      }
      return new SlabDecomposition(slabs, lines, horizontal);
    }
  }
});

// node_modules/interval-tree-1d/interval-tree.js
var require_interval_tree = __commonJS({
  "node_modules/interval-tree-1d/interval-tree.js"(exports2, module2) {
    "use strict";
    var bounds = require_search_bounds();
    var NOT_FOUND = 0;
    var SUCCESS = 1;
    var EMPTY = 2;
    module2.exports = createWrapper;
    function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
      this.mid = mid;
      this.left = left;
      this.right = right;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
    }
    var proto = IntervalTreeNode.prototype;
    function copy(a, b) {
      a.mid = b.mid;
      a.left = b.left;
      a.right = b.right;
      a.leftPoints = b.leftPoints;
      a.rightPoints = b.rightPoints;
      a.count = b.count;
    }
    function rebuild(node, intervals) {
      var ntree = createIntervalTree(intervals);
      node.mid = ntree.mid;
      node.left = ntree.left;
      node.right = ntree.right;
      node.leftPoints = ntree.leftPoints;
      node.rightPoints = ntree.rightPoints;
      node.count = ntree.count;
    }
    function rebuildWithInterval(node, interval) {
      var intervals = node.intervals([]);
      intervals.push(interval);
      rebuild(node, intervals);
    }
    function rebuildWithoutInterval(node, interval) {
      var intervals = node.intervals([]);
      var idx = intervals.indexOf(interval);
      if (idx < 0) {
        return NOT_FOUND;
      }
      intervals.splice(idx, 1);
      rebuild(node, intervals);
      return SUCCESS;
    }
    proto.intervals = function(result) {
      result.push.apply(result, this.leftPoints);
      if (this.left) {
        this.left.intervals(result);
      }
      if (this.right) {
        this.right.intervals(result);
      }
      return result;
    };
    proto.insert = function(interval) {
      var weight = this.count - this.leftPoints.length;
      this.count += 1;
      if (interval[1] < this.mid) {
        if (this.left) {
          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval);
          } else {
            this.left.insert(interval);
          }
        } else {
          this.left = createIntervalTree([interval]);
        }
      } else if (interval[0] > this.mid) {
        if (this.right) {
          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval);
          } else {
            this.right.insert(interval);
          }
        } else {
          this.right = createIntervalTree([interval]);
        }
      } else {
        var l = bounds.ge(this.leftPoints, interval, compareBegin);
        var r = bounds.ge(this.rightPoints, interval, compareEnd);
        this.leftPoints.splice(l, 0, interval);
        this.rightPoints.splice(r, 0, interval);
      }
    };
    proto.remove = function(interval) {
      var weight = this.count - this.leftPoints;
      if (interval[1] < this.mid) {
        if (!this.left) {
          return NOT_FOUND;
        }
        var rw = this.right ? this.right.count : 0;
        if (4 * rw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval);
        }
        var r = this.left.remove(interval);
        if (r === EMPTY) {
          this.left = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else if (interval[0] > this.mid) {
        if (!this.right) {
          return NOT_FOUND;
        }
        var lw = this.left ? this.left.count : 0;
        if (4 * lw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval);
        }
        var r = this.right.remove(interval);
        if (r === EMPTY) {
          this.right = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else {
        if (this.count === 1) {
          if (this.leftPoints[0] === interval) {
            return EMPTY;
          } else {
            return NOT_FOUND;
          }
        }
        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
          if (this.left && this.right) {
            var p = this;
            var n = this.left;
            while (n.right) {
              p = n;
              n = n.right;
            }
            if (p === this) {
              n.right = this.right;
            } else {
              var l = this.left;
              var r = this.right;
              p.count -= n.count;
              p.right = n.left;
              n.left = l;
              n.right = r;
            }
            copy(this, n);
            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
          } else if (this.left) {
            copy(this, this.left);
          } else {
            copy(this, this.right);
          }
          return SUCCESS;
        }
        for (var l = bounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
          if (this.leftPoints[l][0] !== interval[0]) {
            break;
          }
          if (this.leftPoints[l] === interval) {
            this.count -= 1;
            this.leftPoints.splice(l, 1);
            for (var r = bounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
              if (this.rightPoints[r][1] !== interval[1]) {
                break;
              } else if (this.rightPoints[r] === interval) {
                this.rightPoints.splice(r, 1);
                return SUCCESS;
              }
            }
          }
        }
        return NOT_FOUND;
      }
    };
    function reportLeftRange(arr, hi, cb) {
      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRightRange(arr, lo, cb) {
      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRange(arr, cb) {
      for (var i = 0; i < arr.length; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    proto.queryPoint = function(x, cb) {
      if (x < this.mid) {
        if (this.left) {
          var r = this.left.queryPoint(x, cb);
          if (r) {
            return r;
          }
        }
        return reportLeftRange(this.leftPoints, x, cb);
      } else if (x > this.mid) {
        if (this.right) {
          var r = this.right.queryPoint(x, cb);
          if (r) {
            return r;
          }
        }
        return reportRightRange(this.rightPoints, x, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    proto.queryInterval = function(lo, hi, cb) {
      if (lo < this.mid && this.left) {
        var r = this.left.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi > this.mid && this.right) {
        var r = this.right.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi < this.mid) {
        return reportLeftRange(this.leftPoints, hi, cb);
      } else if (lo > this.mid) {
        return reportRightRange(this.rightPoints, lo, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    function compareNumbers(a, b) {
      return a - b;
    }
    function compareBegin(a, b) {
      var d = a[0] - b[0];
      if (d) {
        return d;
      }
      return a[1] - b[1];
    }
    function compareEnd(a, b) {
      var d = a[1] - b[1];
      if (d) {
        return d;
      }
      return a[0] - b[0];
    }
    function createIntervalTree(intervals) {
      if (intervals.length === 0) {
        return null;
      }
      var pts = [];
      for (var i = 0; i < intervals.length; ++i) {
        pts.push(intervals[i][0], intervals[i][1]);
      }
      pts.sort(compareNumbers);
      var mid = pts[pts.length >> 1];
      var leftIntervals = [];
      var rightIntervals = [];
      var centerIntervals = [];
      for (var i = 0; i < intervals.length; ++i) {
        var s = intervals[i];
        if (s[1] < mid) {
          leftIntervals.push(s);
        } else if (mid < s[0]) {
          rightIntervals.push(s);
        } else {
          centerIntervals.push(s);
        }
      }
      var leftPoints = centerIntervals;
      var rightPoints = centerIntervals.slice();
      leftPoints.sort(compareBegin);
      rightPoints.sort(compareEnd);
      return new IntervalTreeNode(
        mid,
        createIntervalTree(leftIntervals),
        createIntervalTree(rightIntervals),
        leftPoints,
        rightPoints
      );
    }
    function IntervalTree(root) {
      this.root = root;
    }
    var tproto = IntervalTree.prototype;
    tproto.insert = function(interval) {
      if (this.root) {
        this.root.insert(interval);
      } else {
        this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
      }
    };
    tproto.remove = function(interval) {
      if (this.root) {
        var r = this.root.remove(interval);
        if (r === EMPTY) {
          this.root = null;
        }
        return r !== NOT_FOUND;
      }
      return false;
    };
    tproto.queryPoint = function(p, cb) {
      if (this.root) {
        return this.root.queryPoint(p, cb);
      }
    };
    tproto.queryInterval = function(lo, hi, cb) {
      if (lo <= hi && this.root) {
        return this.root.queryInterval(lo, hi, cb);
      }
    };
    Object.defineProperty(tproto, "count", {
      get: function() {
        if (this.root) {
          return this.root.count;
        }
        return 0;
      }
    });
    Object.defineProperty(tproto, "intervals", {
      get: function() {
        if (this.root) {
          return this.root.intervals([]);
        }
        return [];
      }
    });
    function createWrapper(intervals) {
      if (!intervals || intervals.length === 0) {
        return new IntervalTree(null);
      }
      return new IntervalTree(createIntervalTree(intervals));
    }
  }
});

// node_modules/point-in-big-polygon/pnp-big.js
var require_pnp_big = __commonJS({
  "node_modules/point-in-big-polygon/pnp-big.js"(exports2, module2) {
    module2.exports = preprocessPolygon;
    var orient = require_orientation()[3];
    var makeSlabs = require_slabs();
    var makeIntervalTree = require_interval_tree();
    var bsearch = require_search_bounds();
    function visitInterval() {
      return true;
    }
    function intervalSearch(table) {
      return function(x, y) {
        var tree = table[x];
        if (tree) {
          return !!tree.queryPoint(y, visitInterval);
        }
        return false;
      };
    }
    function buildVerticalIndex(segments) {
      var table = {};
      for (var i = 0; i < segments.length; ++i) {
        var s = segments[i];
        var x = s[0][0];
        var y0 = s[0][1];
        var y1 = s[1][1];
        var p = [Math.min(y0, y1), Math.max(y0, y1)];
        if (x in table) {
          table[x].push(p);
        } else {
          table[x] = [p];
        }
      }
      var intervalTable = {};
      var keys = Object.keys(table);
      for (var i = 0; i < keys.length; ++i) {
        var segs = table[keys[i]];
        intervalTable[keys[i]] = makeIntervalTree(segs);
      }
      return intervalSearch(intervalTable);
    }
    function buildSlabSearch(slabs, coordinates) {
      return function(p) {
        var bucket = bsearch.le(coordinates, p[0]);
        if (bucket < 0) {
          return 1;
        }
        var root = slabs[bucket];
        if (!root) {
          if (bucket > 0 && coordinates[bucket] === p[0]) {
            root = slabs[bucket - 1];
          } else {
            return 1;
          }
        }
        var lastOrientation = 1;
        while (root) {
          var s = root.key;
          var o = orient(p, s[0], s[1]);
          if (s[0][0] < s[1][0]) {
            if (o < 0) {
              root = root.left;
            } else if (o > 0) {
              lastOrientation = -1;
              root = root.right;
            } else {
              return 0;
            }
          } else {
            if (o > 0) {
              root = root.left;
            } else if (o < 0) {
              lastOrientation = 1;
              root = root.right;
            } else {
              return 0;
            }
          }
        }
        return lastOrientation;
      };
    }
    function classifyEmpty(p) {
      return 1;
    }
    function createClassifyVertical(testVertical) {
      return function classify(p) {
        if (testVertical(p[0], p[1])) {
          return 0;
        }
        return 1;
      };
    }
    function createClassifyPointDegen(testVertical, testNormal) {
      return function classify(p) {
        if (testVertical(p[0], p[1])) {
          return 0;
        }
        return testNormal(p);
      };
    }
    function preprocessPolygon(loops) {
      var numLoops = loops.length;
      var segments = [];
      var vsegments = [];
      var ptr = 0;
      for (var i = 0; i < numLoops; ++i) {
        var loop = loops[i];
        var numVertices = loop.length;
        for (var s = numVertices - 1, t = 0; t < numVertices; s = t++) {
          var a = loop[s];
          var b = loop[t];
          if (a[0] === b[0]) {
            vsegments.push([a, b]);
          } else {
            segments.push([a, b]);
          }
        }
      }
      if (segments.length === 0) {
        if (vsegments.length === 0) {
          return classifyEmpty;
        } else {
          return createClassifyVertical(buildVerticalIndex(vsegments));
        }
      }
      var slabs = makeSlabs(segments);
      var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);
      if (vsegments.length === 0) {
        return testSlab;
      } else {
        return createClassifyPointDegen(
          buildVerticalIndex(vsegments),
          testSlab
        );
      }
    }
  }
});

// node_modules/planar-graph-to-polyline/lib/trim-leaves.js
var require_trim_leaves = __commonJS({
  "node_modules/planar-graph-to-polyline/lib/trim-leaves.js"(exports2, module2) {
    "use strict";
    module2.exports = trimLeaves;
    var e2a = require_e2a();
    function trimLeaves(edges, positions) {
      var adj = e2a(edges, positions.length);
      var live = new Array(positions.length);
      var nbhd = new Array(positions.length);
      var dead = [];
      for (var i = 0; i < positions.length; ++i) {
        var count = adj[i].length;
        nbhd[i] = count;
        live[i] = true;
        if (count <= 1) {
          dead.push(i);
        }
      }
      while (dead.length > 0) {
        var v = dead.pop();
        live[v] = false;
        var n = adj[v];
        for (var i = 0; i < n.length; ++i) {
          var u = n[i];
          if (--nbhd[u] === 0) {
            dead.push(u);
          }
        }
      }
      var newIndex = new Array(positions.length);
      var npositions = [];
      for (var i = 0; i < positions.length; ++i) {
        if (live[i]) {
          var v = npositions.length;
          newIndex[i] = v;
          npositions.push(positions[i]);
        } else {
          newIndex[i] = -1;
        }
      }
      var nedges = [];
      for (var i = 0; i < edges.length; ++i) {
        var e = edges[i];
        if (live[e[0]] && live[e[1]]) {
          nedges.push([newIndex[e[0]], newIndex[e[1]]]);
        }
      }
      return [nedges, npositions];
    }
  }
});

// node_modules/planar-graph-to-polyline/pg2pl.js
var require_pg2pl = __commonJS({
  "node_modules/planar-graph-to-polyline/pg2pl.js"(exports2, module2) {
    "use strict";
    module2.exports = planarGraphToPolyline;
    var e2a = require_e2a();
    var planarDual = require_loops();
    var preprocessPolygon = require_pnp_big();
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var uniq = require_uniq();
    var trimLeaves = require_trim_leaves();
    function makeArray(length, fill) {
      var result = new Array(length);
      for (var i = 0; i < length; ++i) {
        result[i] = fill;
      }
      return result;
    }
    function makeArrayOfArrays(length) {
      var result = new Array(length);
      for (var i = 0; i < length; ++i) {
        result[i] = [];
      }
      return result;
    }
    function planarGraphToPolyline(edges, positions) {
      var result = trimLeaves(edges, positions);
      edges = result[0];
      positions = result[1];
      var numVertices = positions.length;
      var numEdges = edges.length;
      var adj = e2a(edges, positions.length);
      for (var i = 0; i < numVertices; ++i) {
        if (adj[i].length % 2 === 1) {
          throw new Error("planar-graph-to-polyline: graph must be manifold");
        }
      }
      var faces = planarDual(edges, positions);
      function ccw(c2) {
        var n2 = c2.length;
        var area = [0];
        for (var j2 = 0; j2 < n2; ++j2) {
          var a2 = positions[c2[j2]];
          var b2 = positions[c2[(j2 + 1) % n2]];
          var t00 = twoProduct(-a2[0], a2[1]);
          var t01 = twoProduct(-a2[0], b2[1]);
          var t10 = twoProduct(b2[0], a2[1]);
          var t11 = twoProduct(b2[0], b2[1]);
          area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));
        }
        return area[area.length - 1] > 0;
      }
      faces = faces.filter(ccw);
      var numFaces = faces.length;
      var parent = new Array(numFaces);
      var containment = new Array(numFaces);
      for (var i = 0; i < numFaces; ++i) {
        parent[i] = i;
        var row = new Array(numFaces);
        var loopVertices = faces[i].map(function(v) {
          return positions[v];
        });
        var pmc = preprocessPolygon([loopVertices]);
        var count = 0;
        outer:
          for (var j = 0; j < numFaces; ++j) {
            row[j] = 0;
            if (i === j) {
              continue;
            }
            var c = faces[j];
            var n = c.length;
            for (var k = 0; k < n; ++k) {
              var d = pmc(positions[c[k]]);
              if (d !== 0) {
                if (d < 0) {
                  row[j] = 1;
                  count += 1;
                }
                continue outer;
              }
            }
            row[j] = 1;
            count += 1;
          }
        containment[i] = [count, i, row];
      }
      containment.sort(function(a2, b2) {
        return b2[0] - a2[0];
      });
      for (var i = 0; i < numFaces; ++i) {
        var row = containment[i];
        var idx = row[1];
        var children = row[2];
        for (var j = 0; j < numFaces; ++j) {
          if (children[j]) {
            parent[j] = idx;
          }
        }
      }
      var fadj = makeArrayOfArrays(numFaces);
      for (var i = 0; i < numFaces; ++i) {
        fadj[i].push(parent[i]);
        fadj[parent[i]].push(i);
      }
      var edgeAdjacency = {};
      var internalVertices = makeArray(numVertices, false);
      for (var i = 0; i < numFaces; ++i) {
        var c = faces[i];
        var n = c.length;
        for (var j = 0; j < n; ++j) {
          var a = c[j];
          var b = c[(j + 1) % n];
          var key = Math.min(a, b) + ":" + Math.max(a, b);
          if (key in edgeAdjacency) {
            var neighbor = edgeAdjacency[key];
            fadj[neighbor].push(i);
            fadj[i].push(neighbor);
            internalVertices[a] = internalVertices[b] = true;
          } else {
            edgeAdjacency[key] = i;
          }
        }
      }
      function sharedBoundary(c2) {
        var n2 = c2.length;
        for (var i2 = 0; i2 < n2; ++i2) {
          if (!internalVertices[c2[i2]]) {
            return false;
          }
        }
        return true;
      }
      var toVisit = [];
      var parity = makeArray(numFaces, -1);
      for (var i = 0; i < numFaces; ++i) {
        if (parent[i] === i && !sharedBoundary(faces[i])) {
          toVisit.push(i);
          parity[i] = 0;
        } else {
          parity[i] = -1;
        }
      }
      var result = [];
      while (toVisit.length > 0) {
        var top = toVisit.pop();
        var nbhd = fadj[top];
        uniq(nbhd, function(a2, b2) {
          return a2 - b2;
        });
        var nnbhr = nbhd.length;
        var p = parity[top];
        var polyline;
        if (p === 0) {
          var c = faces[top];
          polyline = [c];
        }
        for (var i = 0; i < nnbhr; ++i) {
          var f = nbhd[i];
          if (parity[f] >= 0) {
            continue;
          }
          parity[f] = p ^ 1;
          toVisit.push(f);
          if (p === 0) {
            var c = faces[f];
            if (!sharedBoundary(c)) {
              c.reverse();
              polyline.push(c);
            }
          }
        }
        if (p === 0) {
          result.push(polyline);
        }
      }
      return result;
    }
  }
});

// node_modules/vectorize-text/lib/vtext.js
var require_vtext = __commonJS({
  "node_modules/vectorize-text/lib/vtext.js"(exports2, module2) {
    module2.exports = vectorizeText;
    module2.exports.processPixels = processPixels;
    var surfaceNets = require_surfacenets();
    var ndarray = require_ndarray();
    var simplify = require_simplify();
    var cleanPSLG = require_clean_pslg();
    var cdt2d = require_cdt2d();
    var toPolygonCrappy = require_pg2pl();
    var TAG_bold = "b";
    var CHR_bold = "b|";
    var TAG_italic = "i";
    var CHR_italic = "i|";
    var TAG_super = "sup";
    var CHR_super0 = "+";
    var CHR_super = "+1";
    var TAG_sub = "sub";
    var CHR_sub0 = "-";
    var CHR_sub = "-1";
    function parseTag(tag, TAG_CHR, str, map) {
      var opnTag = "<" + tag + ">";
      var clsTag = "</" + tag + ">";
      var nOPN = opnTag.length;
      var nCLS = clsTag.length;
      var isRecursive = TAG_CHR[0] === CHR_super0 || TAG_CHR[0] === CHR_sub0;
      var a = 0;
      var b = -nCLS;
      while (a > -1) {
        a = str.indexOf(opnTag, a);
        if (a === -1) break;
        b = str.indexOf(clsTag, a + nOPN);
        if (b === -1) break;
        if (b <= a) break;
        for (var i = a; i < b + nCLS; ++i) {
          if (i < a + nOPN || i >= b) {
            map[i] = null;
            str = str.substr(0, i) + " " + str.substr(i + 1);
          } else {
            if (map[i] !== null) {
              var pos = map[i].indexOf(TAG_CHR[0]);
              if (pos === -1) {
                map[i] += TAG_CHR;
              } else {
                if (isRecursive) {
                  map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2);
                }
              }
            }
          }
        }
        var start = a + nOPN;
        var remainingStr = str.substr(start, b - start);
        var c = remainingStr.indexOf(opnTag);
        if (c !== -1) a = c;
        else a = b + nCLS;
      }
      return map;
    }
    function transformPositions(positions, options, size) {
      var align = options.textAlign || "start";
      var baseline = options.textBaseline || "alphabetic";
      var lo = [1 << 30, 1 << 30];
      var hi = [0, 0];
      var n = positions.length;
      for (var i = 0; i < n; ++i) {
        var p = positions[i];
        for (var j = 0; j < 2; ++j) {
          lo[j] = Math.min(lo[j], p[j]) | 0;
          hi[j] = Math.max(hi[j], p[j]) | 0;
        }
      }
      var xShift = 0;
      switch (align) {
        case "center":
          xShift = -0.5 * (lo[0] + hi[0]);
          break;
        case "right":
        case "end":
          xShift = -hi[0];
          break;
        case "left":
        case "start":
          xShift = -lo[0];
          break;
        default:
          throw new Error("vectorize-text: Unrecognized textAlign: '" + align + "'");
      }
      var yShift = 0;
      switch (baseline) {
        case "hanging":
        case "top":
          yShift = -lo[1];
          break;
        case "middle":
          yShift = -0.5 * (lo[1] + hi[1]);
          break;
        case "alphabetic":
        case "ideographic":
          yShift = -3 * size;
          break;
        case "bottom":
          yShift = -hi[1];
          break;
        default:
          throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'");
      }
      var scale = 1 / size;
      if ("lineHeight" in options) {
        scale *= +options.lineHeight;
      } else if ("width" in options) {
        scale = options.width / (hi[0] - lo[0]);
      } else if ("height" in options) {
        scale = options.height / (hi[1] - lo[1]);
      }
      return positions.map(function(p2) {
        return [scale * (p2[0] + xShift), scale * (p2[1] + yShift)];
      });
    }
    function getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {
      rawString = rawString.replace(/\n/g, "");
      if (styletags.breaklines === true) {
        rawString = rawString.replace(/\<br\>/g, "\n");
      } else {
        rawString = rawString.replace(/\<br\>/g, " ");
      }
      var activeStyle = "";
      var map = [];
      for (j = 0; j < rawString.length; ++j) {
        map[j] = activeStyle;
      }
      if (styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map);
      if (styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map);
      if (styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map);
      if (styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map);
      var allStyles = [];
      var plainText = "";
      for (j = 0; j < rawString.length; ++j) {
        if (map[j] !== null) {
          plainText += rawString[j];
          allStyles.push(map[j]);
        }
      }
      var allTexts = plainText.split("\n");
      var numberOfLines = allTexts.length;
      var lineHeight = Math.round(lineSpacing * fontSize);
      var offsetX = fontSize;
      var offsetY = fontSize * 2;
      var maxWidth = 0;
      var minHeight = numberOfLines * lineHeight + offsetY;
      if (canvas.height < minHeight) {
        canvas.height = minHeight;
      }
      context.fillStyle = "#000";
      context.fillRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = "#fff";
      var i, j, xPos, yPos, zPos;
      var nDone = 0;
      var buffer = "";
      function writeBuffer() {
        if (buffer !== "") {
          var delta = context.measureText(buffer).width;
          context.fillText(buffer, offsetX + xPos, offsetY + yPos);
          xPos += delta;
        }
      }
      function getTextFontSize() {
        return "" + Math.round(zPos) + "px ";
      }
      function changeStyle(oldStyle, newStyle) {
        var ctxFont = "" + context.font;
        if (styletags.subscripts === true) {
          var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);
          var newIndex_Sub = newStyle.indexOf(CHR_sub0);
          var oldSub = oldIndex_Sub > -1 ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;
          var newSub = newIndex_Sub > -1 ? parseInt(newStyle[1 + newIndex_Sub]) : 0;
          if (oldSub !== newSub) {
            ctxFont = ctxFont.replace(getTextFontSize(), "?px ");
            zPos *= Math.pow(0.75, newSub - oldSub);
            ctxFont = ctxFont.replace("?px ", getTextFontSize());
          }
          yPos += 0.25 * lineHeight * (newSub - oldSub);
        }
        if (styletags.superscripts === true) {
          var oldIndex_Super = oldStyle.indexOf(CHR_super0);
          var newIndex_Super = newStyle.indexOf(CHR_super0);
          var oldSuper = oldIndex_Super > -1 ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;
          var newSuper = newIndex_Super > -1 ? parseInt(newStyle[1 + newIndex_Super]) : 0;
          if (oldSuper !== newSuper) {
            ctxFont = ctxFont.replace(getTextFontSize(), "?px ");
            zPos *= Math.pow(0.75, newSuper - oldSuper);
            ctxFont = ctxFont.replace("?px ", getTextFontSize());
          }
          yPos -= 0.25 * lineHeight * (newSuper - oldSuper);
        }
        if (styletags.bolds === true) {
          var wasBold = oldStyle.indexOf(CHR_bold) > -1;
          var is_Bold = newStyle.indexOf(CHR_bold) > -1;
          if (!wasBold && is_Bold) {
            if (wasItalic) {
              ctxFont = ctxFont.replace("italic ", "italic bold ");
            } else {
              ctxFont = "bold " + ctxFont;
            }
          }
          if (wasBold && !is_Bold) {
            ctxFont = ctxFont.replace("bold ", "");
          }
        }
        if (styletags.italics === true) {
          var wasItalic = oldStyle.indexOf(CHR_italic) > -1;
          var is_Italic = newStyle.indexOf(CHR_italic) > -1;
          if (!wasItalic && is_Italic) {
            ctxFont = "italic " + ctxFont;
          }
          if (wasItalic && !is_Italic) {
            ctxFont = ctxFont.replace("italic ", "");
          }
        }
        context.font = ctxFont;
      }
      for (i = 0; i < numberOfLines; ++i) {
        var txt = allTexts[i] + "\n";
        xPos = 0;
        yPos = i * lineHeight;
        zPos = fontSize;
        buffer = "";
        for (j = 0; j < txt.length; ++j) {
          var style = j + nDone < allStyles.length ? allStyles[j + nDone] : allStyles[allStyles.length - 1];
          if (activeStyle === style) {
            buffer += txt[j];
          } else {
            writeBuffer();
            buffer = txt[j];
            if (style !== void 0) {
              changeStyle(activeStyle, style);
              activeStyle = style;
            }
          }
        }
        writeBuffer();
        nDone += txt.length;
        var width = Math.round(xPos + 2 * offsetX) | 0;
        if (maxWidth < width) maxWidth = width;
      }
      var xCut = maxWidth;
      var yCut = offsetY + lineHeight * numberOfLines;
      var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4]);
      return pixels.pick(-1, -1, 0).transpose(1, 0);
    }
    function getContour(pixels, doSimplify) {
      var contour = surfaceNets(pixels, 128);
      if (doSimplify) {
        return simplify(contour.cells, contour.positions, 0.25);
      }
      return {
        edges: contour.cells,
        positions: contour.positions
      };
    }
    function processPixelsImpl(pixels, options, size, simplify2) {
      var contour = getContour(pixels, simplify2);
      var positions = transformPositions(contour.positions, options, size);
      var edges = contour.edges;
      var flip = "ccw" === options.orientation;
      cleanPSLG(positions, edges);
      if (options.polygons || options.polygon || options.polyline) {
        var result = toPolygonCrappy(edges, positions);
        var nresult = new Array(result.length);
        for (var i = 0; i < result.length; ++i) {
          var loops = result[i];
          var nloops = new Array(loops.length);
          for (var j = 0; j < loops.length; ++j) {
            var loop = loops[j];
            var nloop = new Array(loop.length);
            for (var k = 0; k < loop.length; ++k) {
              nloop[k] = positions[loop[k]].slice();
            }
            if (flip) {
              nloop.reverse();
            }
            nloops[j] = nloop;
          }
          nresult[i] = nloops;
        }
        return nresult;
      } else if (options.triangles || options.triangulate || options.triangle) {
        return {
          cells: cdt2d(positions, edges, {
            delaunay: false,
            exterior: false,
            interior: true
          }),
          positions
        };
      } else {
        return {
          edges,
          positions
        };
      }
    }
    function processPixels(pixels, options, size) {
      try {
        return processPixelsImpl(pixels, options, size, true);
      } catch (e) {
      }
      try {
        return processPixelsImpl(pixels, options, size, false);
      } catch (e) {
      }
      if (options.polygons || options.polyline || options.polygon) {
        return [];
      }
      if (options.triangles || options.triangulate || options.triangle) {
        return {
          cells: [],
          positions: []
        };
      }
      return {
        edges: [],
        positions: []
      };
    }
    function vectorizeText(str, canvas, context, options) {
      var size = 64;
      var lineSpacing = 1.25;
      var styletags = {
        breaklines: false,
        bolds: false,
        italics: false,
        subscripts: false,
        superscripts: false
      };
      if (options) {
        if (options.size && options.size > 0) size = options.size;
        if (options.lineSpacing && options.lineSpacing > 0) lineSpacing = options.lineSpacing;
        if (options.styletags && options.styletags.breaklines) styletags.breaklines = options.styletags.breaklines ? true : false;
        if (options.styletags && options.styletags.bolds) styletags.bolds = options.styletags.bolds ? true : false;
        if (options.styletags && options.styletags.italics) styletags.italics = options.styletags.italics ? true : false;
        if (options.styletags && options.styletags.subscripts) styletags.subscripts = options.styletags.subscripts ? true : false;
        if (options.styletags && options.styletags.superscripts) styletags.superscripts = options.styletags.superscripts ? true : false;
      }
      context.font = [
        options.fontStyle,
        options.fontVariant,
        options.fontWeight,
        size + "px",
        options.font
      ].filter(function(d) {
        return d;
      }).join(" ");
      context.textAlign = "start";
      context.textBaseline = "alphabetic";
      context.direction = "ltr";
      var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags);
      return processPixels(pixels, options, size);
    }
  }
});

// node_modules/vectorize-text/index.js
var require_vectorize_text = __commonJS({
  "node_modules/vectorize-text/index.js"(exports2, module2) {
    "use strict";
    module2.exports = createText;
    var vectorizeText = require_vtext();
    var defaultCanvas = null;
    var defaultContext = null;
    if (typeof document !== "undefined") {
      defaultCanvas = document.createElement("canvas");
      defaultCanvas.width = 8192;
      defaultCanvas.height = 1024;
      defaultContext = defaultCanvas.getContext("2d");
    }
    function createText(str, options) {
      if (typeof options !== "object" || options === null) {
        options = {};
      }
      return vectorizeText(
        str,
        options.canvas || defaultCanvas,
        options.context || defaultContext,
        options
      );
    }
  }
});

// node_modules/text-cache/textcache.js
var require_textcache = __commonJS({
  "node_modules/text-cache/textcache.js"(exports2, module2) {
    "use strict";
    module2.exports = textGet;
    var vectorizeText = require_vectorize_text();
    var globals = window || process.global || {};
    var __TEXT_CACHE = globals.__TEXT_CACHE || {};
    globals.__TEXT_CACHE = {};
    function unwrap(mesh) {
      var cells = mesh.cells;
      var positions = mesh.positions;
      var data = new Float32Array(cells.length * 6);
      var ptr = 0;
      var shapeX = 0;
      for (var i = 0; i < cells.length; ++i) {
        var tri = cells[i];
        for (var j = 0; j < 3; ++j) {
          var point = positions[tri[j]];
          data[ptr++] = point[0];
          data[ptr++] = point[1] + 1.4;
          shapeX = Math.max(point[0], shapeX);
        }
      }
      return {
        data,
        shape: shapeX
      };
    }
    function textGet(font, text, opts) {
      var opts = opts || {};
      var fontStyle = opts.fontStyle || "normal";
      var fontWeight = opts.fontWeight || "normal";
      var fontVariant = opts.fontVariant || "normal";
      var fontKey = [
        fontStyle,
        fontWeight,
        fontVariant,
        font
      ].join("_");
      var fontcache = __TEXT_CACHE[fontKey];
      if (!fontcache) {
        fontcache = __TEXT_CACHE[fontKey] = {
          " ": {
            data: new Float32Array(0),
            shape: 0.2
          }
        };
      }
      var mesh = fontcache[text];
      if (!mesh) {
        if (text.length <= 1 || !/\d/.test(text)) {
          mesh = fontcache[text] = unwrap(vectorizeText(text, {
            triangles: true,
            font,
            fontStyle,
            fontWeight,
            fontVariant,
            textAlign: opts.textAlign || "left",
            textBaseline: "alphabetic",
            styletags: {
              breaklines: true,
              bolds: true,
              italics: true,
              subscripts: true,
              superscripts: true
            }
          }));
        } else {
          var parts = text.split(/(\d|\s)/);
          var buffer = new Array(parts.length);
          var bufferSize = 0;
          var shapeX = 0;
          for (var i = 0; i < parts.length; ++i) {
            buffer[i] = textGet(font, parts[i]);
            bufferSize += buffer[i].data.length;
            shapeX += buffer[i].shape;
            if (i > 0) {
              shapeX += 0.02;
            }
          }
          var data = new Float32Array(bufferSize);
          var ptr = 0;
          var xOffset = -0.5 * shapeX;
          for (var i = 0; i < buffer.length; ++i) {
            var bdata = buffer[i].data;
            for (var j = 0; j < bdata.length; j += 2) {
              data[ptr++] = bdata[j] + xOffset;
              data[ptr++] = bdata[j + 1];
            }
            xOffset += buffer[i].shape + 0.02;
          }
          mesh = fontcache[text] = {
            data,
            shape: shapeX
          };
        }
      }
      return mesh;
    }
  }
});

// node_modules/gl-plot2d/lib/text.js
var require_text = __commonJS({
  "node_modules/gl-plot2d/lib/text.js"(exports2, module2) {
    "use strict";
    module2.exports = createTextElements;
    var createBuffer = require_buffer2();
    var createShader = require_gl_shader();
    var getText = require_textcache();
    var bsearch = require_search_bounds();
    var shaders = require_shaders6();
    function TextElements(plot, vbo, shader) {
      this.plot = plot;
      this.vbo = vbo;
      this.shader = shader;
      this.tickOffset = [[], []];
      this.tickX = [[], []];
      this.labelOffset = [0, 0];
      this.labelCount = [0, 0];
    }
    var proto = TextElements.prototype;
    proto.drawTicks = /* @__PURE__ */ function() {
      var DATA_AXIS = [0, 0];
      var SCREEN_OFFSET = [0, 0];
      var ZERO_2 = [0, 0];
      return function(axis) {
        var plot = this.plot;
        var shader = this.shader;
        var tickX = this.tickX[axis];
        var tickOffset = this.tickOffset[axis];
        var gl2 = plot.gl;
        var viewBox = plot.viewBox;
        var dataBox = plot.dataBox;
        var screenBox = plot.screenBox;
        var pixelRatio = plot.pixelRatio;
        var tickEnable = plot.tickEnable;
        var tickPad = plot.tickPad;
        var textColor = plot.tickColor;
        var textAngle = plot.tickAngle;
        var labelEnable = plot.labelEnable;
        var labelPad = plot.labelPad;
        var labelColor = plot.labelColor;
        var labelAngle = plot.labelAngle;
        var labelOffset = this.labelOffset[axis];
        var labelCount = this.labelCount[axis];
        var start = bsearch.lt(tickX, dataBox[axis]);
        var end = bsearch.le(tickX, dataBox[axis + 2]);
        DATA_AXIS[0] = DATA_AXIS[1] = 0;
        DATA_AXIS[axis] = 1;
        SCREEN_OFFSET[axis] = (viewBox[2 + axis] + viewBox[axis]) / (screenBox[2 + axis] - screenBox[axis]) - 1;
        var screenScale = 2 / screenBox[2 + (axis ^ 1)] - screenBox[axis ^ 1];
        SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[axis ^ 1] - 1;
        if (tickEnable[axis]) {
          SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * tickPad[axis];
          if (start < end && tickOffset[end] > tickOffset[start]) {
            shader.uniforms.dataAxis = DATA_AXIS;
            shader.uniforms.screenOffset = SCREEN_OFFSET;
            shader.uniforms.color = textColor[axis];
            shader.uniforms.angle = textAngle[axis];
            gl2.drawArrays(
              gl2.TRIANGLES,
              tickOffset[start],
              tickOffset[end] - tickOffset[start]
            );
          }
        }
        if (labelEnable[axis] && labelCount) {
          SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * labelPad[axis];
          shader.uniforms.dataAxis = ZERO_2;
          shader.uniforms.screenOffset = SCREEN_OFFSET;
          shader.uniforms.color = labelColor[axis];
          shader.uniforms.angle = labelAngle[axis];
          gl2.drawArrays(
            gl2.TRIANGLES,
            labelOffset,
            labelCount
          );
        }
        SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[2 + (axis ^ 1)] - 1;
        if (tickEnable[axis + 2]) {
          SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * tickPad[axis + 2];
          if (start < end && tickOffset[end] > tickOffset[start]) {
            shader.uniforms.dataAxis = DATA_AXIS;
            shader.uniforms.screenOffset = SCREEN_OFFSET;
            shader.uniforms.color = textColor[axis + 2];
            shader.uniforms.angle = textAngle[axis + 2];
            gl2.drawArrays(
              gl2.TRIANGLES,
              tickOffset[start],
              tickOffset[end] - tickOffset[start]
            );
          }
        }
        if (labelEnable[axis + 2] && labelCount) {
          SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * labelPad[axis + 2];
          shader.uniforms.dataAxis = ZERO_2;
          shader.uniforms.screenOffset = SCREEN_OFFSET;
          shader.uniforms.color = labelColor[axis + 2];
          shader.uniforms.angle = labelAngle[axis + 2];
          gl2.drawArrays(
            gl2.TRIANGLES,
            labelOffset,
            labelCount
          );
        }
      };
    }();
    proto.drawTitle = /* @__PURE__ */ function() {
      var DATA_AXIS = [0, 0];
      var SCREEN_OFFSET = [0, 0];
      return function() {
        var plot = this.plot;
        var shader = this.shader;
        var gl2 = plot.gl;
        var screenBox = plot.screenBox;
        var titleCenter = plot.titleCenter;
        var titleAngle = plot.titleAngle;
        var titleColor = plot.titleColor;
        var pixelRatio = plot.pixelRatio;
        if (!this.titleCount) {
          return;
        }
        for (var i = 0; i < 2; ++i) {
          SCREEN_OFFSET[i] = 2 * (titleCenter[i] * pixelRatio - screenBox[i]) / (screenBox[2 + i] - screenBox[i]) - 1;
        }
        shader.bind();
        shader.uniforms.dataAxis = DATA_AXIS;
        shader.uniforms.screenOffset = SCREEN_OFFSET;
        shader.uniforms.angle = titleAngle;
        shader.uniforms.color = titleColor;
        gl2.drawArrays(gl2.TRIANGLES, this.titleOffset, this.titleCount);
      };
    }();
    proto.bind = /* @__PURE__ */ function() {
      var DATA_SHIFT = [0, 0];
      var DATA_SCALE = [0, 0];
      var TEXT_SCALE = [0, 0];
      return function() {
        var plot = this.plot;
        var shader = this.shader;
        var bounds = plot._tickBounds;
        var dataBox = plot.dataBox;
        var screenBox = plot.screenBox;
        var viewBox = plot.viewBox;
        shader.bind();
        for (var i = 0; i < 2; ++i) {
          var lo = bounds[i];
          var hi = bounds[i + 2];
          var boundScale = hi - lo;
          var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);
          var dataWidth = dataBox[i + 2] - dataBox[i];
          var viewLo = viewBox[i];
          var viewHi = viewBox[i + 2];
          var viewScale = viewHi - viewLo;
          var screenLo = screenBox[i];
          var screenHi = screenBox[i + 2];
          var screenScale = screenHi - screenLo;
          DATA_SCALE[i] = 2 * boundScale / dataWidth * viewScale / screenScale;
          DATA_SHIFT[i] = 2 * (lo - dataCenter) / dataWidth * viewScale / screenScale;
        }
        TEXT_SCALE[1] = 2 * plot.pixelRatio / (screenBox[3] - screenBox[1]);
        TEXT_SCALE[0] = TEXT_SCALE[1] * (screenBox[3] - screenBox[1]) / (screenBox[2] - screenBox[0]);
        shader.uniforms.dataScale = DATA_SCALE;
        shader.uniforms.dataShift = DATA_SHIFT;
        shader.uniforms.textScale = TEXT_SCALE;
        this.vbo.bind();
        shader.attributes.textCoordinate.pointer();
      };
    }();
    proto.update = function(options) {
      var vertices = [];
      var axesTicks = options.ticks;
      var bounds = options.bounds;
      var i, j, k, data, scale, dimension;
      for (dimension = 0; dimension < 2; ++dimension) {
        var offsets = [Math.floor(vertices.length / 3)], tickX = [-Infinity];
        var ticks = axesTicks[dimension];
        for (i = 0; i < ticks.length; ++i) {
          var tick = ticks[i];
          var x = tick.x;
          var text = tick.text;
          var font = tick.font || "sans-serif";
          var fontStyle = tick.fontStyle || "normal";
          var fontWeight = tick.fontWeight || "normal";
          var fontVariant = tick.fontVariant || "normal";
          scale = tick.fontSize || 12;
          var coordScale = 1 / (bounds[dimension + 2] - bounds[dimension]);
          var coordShift = bounds[dimension];
          var rows = text.split("\n");
          for (var r = 0; r < rows.length; r++) {
            data = getText(font, rows[r], {
              fontStyle,
              fontWeight,
              fontVariant
            }).data;
            for (j = 0; j < data.length; j += 2) {
              vertices.push(
                data[j] * scale,
                -data[j + 1] * scale - r * scale * 1.2,
                (x - coordShift) * coordScale
              );
            }
          }
          offsets.push(Math.floor(vertices.length / 3));
          tickX.push(x);
        }
        this.tickOffset[dimension] = offsets;
        this.tickX[dimension] = tickX;
      }
      for (dimension = 0; dimension < 2; ++dimension) {
        this.labelOffset[dimension] = Math.floor(vertices.length / 3);
        data = getText(options.labelFont[dimension], options.labels[dimension], {
          fontStyle: options.labelFontStyle[dimension],
          fontWeight: options.labelFontWeight[dimension],
          fontVariant: options.labelFontVariant[dimension],
          textAlign: "center"
        }).data;
        scale = options.labelSize[dimension];
        for (i = 0; i < data.length; i += 2) {
          vertices.push(data[i] * scale, -data[i + 1] * scale, 0);
        }
        this.labelCount[dimension] = Math.floor(vertices.length / 3) - this.labelOffset[dimension];
      }
      this.titleOffset = Math.floor(vertices.length / 3);
      data = getText(options.titleFont, options.title, {
        fontStyle: options.titleFontStyle,
        fontWeight: options.titleFontWeight,
        fontVariant: options.titleFontVariant
      }).data;
      scale = options.titleSize;
      for (i = 0; i < data.length; i += 2) {
        vertices.push(data[i] * scale, -data[i + 1] * scale, 0);
      }
      this.titleCount = Math.floor(vertices.length / 3) - this.titleOffset;
      this.vbo.update(vertices);
    };
    proto.dispose = function() {
      this.vbo.dispose();
      this.shader.dispose();
    };
    function createTextElements(plot) {
      var gl2 = plot.gl;
      var vbo = createBuffer(gl2);
      var shader = createShader(gl2, shaders.textVert, shaders.textFrag);
      var text = new TextElements(plot, vbo, shader);
      return text;
    }
  }
});

// node_modules/gl-plot2d/lib/line.js
var require_line = __commonJS({
  "node_modules/gl-plot2d/lib/line.js"(exports2, module2) {
    "use strict";
    module2.exports = createLines;
    var createBuffer = require_buffer2();
    var createShader = require_gl_shader();
    var shaders = require_shaders6();
    function Lines(plot, vbo, shader) {
      this.plot = plot;
      this.vbo = vbo;
      this.shader = shader;
    }
    var proto = Lines.prototype;
    proto.bind = function() {
      var shader = this.shader;
      this.vbo.bind();
      this.shader.bind();
      shader.attributes.coord.pointer();
      shader.uniforms.screenBox = this.plot.screenBox;
    };
    proto.drawLine = /* @__PURE__ */ function() {
      var start = [0, 0];
      var end = [0, 0];
      return function(startX, startY, endX, endY, width, color) {
        var plot = this.plot;
        var shader = this.shader;
        var gl2 = plot.gl;
        start[0] = startX;
        start[1] = startY;
        end[0] = endX;
        end[1] = endY;
        shader.uniforms.start = start;
        shader.uniforms.end = end;
        shader.uniforms.width = width * plot.pixelRatio;
        shader.uniforms.color = color;
        gl2.drawArrays(gl2.TRIANGLE_STRIP, 0, 4);
      };
    }();
    proto.dispose = function() {
      this.vbo.dispose();
      this.shader.dispose();
    };
    function createLines(plot) {
      var gl2 = plot.gl;
      var vbo = createBuffer(gl2, [
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1
      ]);
      var shader = createShader(gl2, shaders.lineVert, shaders.lineFrag);
      var lines = new Lines(plot, vbo, shader);
      return lines;
    }
  }
});

// node_modules/gl-plot2d/lib/box.js
var require_box = __commonJS({
  "node_modules/gl-plot2d/lib/box.js"(exports2, module2) {
    "use strict";
    module2.exports = createBoxes;
    var createBuffer = require_buffer2();
    var createShader = require_gl_shader();
    var shaders = require_shaders6();
    function Boxes(plot, vbo, shader) {
      this.plot = plot;
      this.vbo = vbo;
      this.shader = shader;
    }
    var proto = Boxes.prototype;
    proto.bind = function() {
      var shader = this.shader;
      this.vbo.bind();
      this.shader.bind();
      shader.attributes.coord.pointer();
      shader.uniforms.screenBox = this.plot.screenBox;
    };
    proto.drawBox = /* @__PURE__ */ function() {
      var lo = [0, 0];
      var hi = [0, 0];
      return function(loX, loY, hiX, hiY, color) {
        var plot = this.plot;
        var shader = this.shader;
        var gl2 = plot.gl;
        lo[0] = loX;
        lo[1] = loY;
        hi[0] = hiX;
        hi[1] = hiY;
        shader.uniforms.lo = lo;
        shader.uniforms.hi = hi;
        shader.uniforms.color = color;
        gl2.drawArrays(gl2.TRIANGLE_STRIP, 0, 4);
      };
    }();
    proto.dispose = function() {
      this.vbo.dispose();
      this.shader.dispose();
    };
    function createBoxes(plot) {
      var gl2 = plot.gl;
      var vbo = createBuffer(gl2, [
        0,
        0,
        0,
        1,
        1,
        0,
        1,
        1
      ]);
      var shader = createShader(gl2, shaders.boxVert, shaders.lineFrag);
      return new Boxes(plot, vbo, shader);
    }
  }
});

// node_modules/gl-plot2d/plot.js
var require_plot = __commonJS({
  "node_modules/gl-plot2d/plot.js"(exports2, module2) {
    "use strict";
    module2.exports = createGLPlot2D;
    var createPick = require_select();
    var createGrid = require_grid();
    var createText = require_text();
    var createLine = require_line();
    var createBox = require_box();
    function GLPlot2D(gl2, pickBuffer) {
      this.gl = gl2;
      this.pickBuffer = pickBuffer;
      this.screenBox = [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight];
      this.viewBox = [0, 0, 0, 0];
      this.dataBox = [-10, -10, 10, 10];
      this.gridLineEnable = [true, true];
      this.gridLineWidth = [1, 1];
      this.gridLineColor = [
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.pixelRatio = 1;
      this.tickMarkLength = [0, 0, 0, 0];
      this.tickMarkWidth = [0, 0, 0, 0];
      this.tickMarkColor = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.tickPad = [15, 15, 15, 15];
      this.tickAngle = [0, 0, 0, 0];
      this.tickEnable = [true, true, true, true];
      this.tickColor = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.labelPad = [15, 15, 15, 15];
      this.labelAngle = [0, Math.PI / 2, 0, 3 * Math.PI / 2];
      this.labelEnable = [true, true, true, true];
      this.labelColor = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.titleCenter = [0, 0];
      this.titleEnable = true;
      this.titleAngle = 0;
      this.titleColor = [0, 0, 0, 1];
      this.borderColor = [0, 0, 0, 0];
      this.backgroundColor = [0, 0, 0, 0];
      this.zeroLineEnable = [true, true];
      this.zeroLineWidth = [4, 4];
      this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];
      this.borderLineEnable = [true, true, true, true];
      this.borderLineWidth = [2, 2, 2, 2];
      this.borderLineColor = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.grid = null;
      this.text = null;
      this.line = null;
      this.box = null;
      this.objects = [];
      this.overlays = [];
      this._tickBounds = [Infinity, Infinity, -Infinity, -Infinity];
      this.static = false;
      this.dirty = false;
      this.pickDirty = false;
      this.pickDelay = 120;
      this.pickRadius = 10;
      this._pickTimeout = null;
      this._drawPick = this.drawPick.bind(this);
      this._depthCounter = 0;
    }
    var proto = GLPlot2D.prototype;
    proto.setDirty = function() {
      this.dirty = this.pickDirty = true;
    };
    proto.setOverlayDirty = function() {
      this.dirty = true;
    };
    proto.nextDepthValue = function() {
      return this._depthCounter++ / 65536;
    };
    proto.draw = /* @__PURE__ */ function() {
      var TICK_MARK_BOX = [0, 0, 0, 0];
      return function() {
        var gl2 = this.gl;
        var screenBox = this.screenBox;
        var viewPixels = this.viewBox;
        var dataBox = this.dataBox;
        var pixelRatio = this.pixelRatio;
        var grid = this.grid;
        var line = this.line;
        var text = this.text;
        var objects = this.objects;
        this._depthCounter = 0;
        if (this.pickDirty) {
          if (this._pickTimeout) {
            clearTimeout(this._pickTimeout);
          }
          this.pickDirty = false;
          this._pickTimeout = setTimeout(this._drawPick, this.pickDelay);
        }
        if (!this.dirty) {
          return;
        }
        this.dirty = false;
        gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
        gl2.enable(gl2.SCISSOR_TEST);
        gl2.disable(gl2.DEPTH_TEST);
        gl2.depthFunc(gl2.LESS);
        gl2.depthMask(false);
        gl2.enable(gl2.BLEND);
        gl2.blendEquation(gl2.FUNC_ADD, gl2.FUNC_ADD);
        gl2.blendFunc(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
        if (this.borderColor) {
          gl2.scissor(
            screenBox[0],
            screenBox[1],
            screenBox[2] - screenBox[0],
            screenBox[3] - screenBox[1]
          );
          var borderColor = this.borderColor;
          gl2.clearColor(
            borderColor[0] * borderColor[3],
            borderColor[1] * borderColor[3],
            borderColor[2] * borderColor[3],
            borderColor[3]
          );
          gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT);
        }
        gl2.scissor(
          viewPixels[0],
          viewPixels[1],
          viewPixels[2] - viewPixels[0],
          viewPixels[3] - viewPixels[1]
        );
        gl2.viewport(
          viewPixels[0],
          viewPixels[1],
          viewPixels[2] - viewPixels[0],
          viewPixels[3] - viewPixels[1]
        );
        var backgroundColor = this.backgroundColor;
        gl2.clearColor(
          backgroundColor[0] * backgroundColor[3],
          backgroundColor[1] * backgroundColor[3],
          backgroundColor[2] * backgroundColor[3],
          backgroundColor[3]
        );
        gl2.clear(gl2.COLOR_BUFFER_BIT);
        grid.draw();
        var zeroLineEnable = this.zeroLineEnable;
        var zeroLineColor = this.zeroLineColor;
        var zeroLineWidth = this.zeroLineWidth;
        if (zeroLineEnable[0] || zeroLineEnable[1]) {
          line.bind();
          for (var i = 0; i < 2; ++i) {
            if (!zeroLineEnable[i] || !(dataBox[i] <= 0 && dataBox[i + 2] >= 0)) {
              continue;
            }
            var zeroIntercept = screenBox[i] - dataBox[i] * (screenBox[i + 2] - screenBox[i]) / (dataBox[i + 2] - dataBox[i]);
            if (i === 0) {
              line.drawLine(
                zeroIntercept,
                screenBox[1],
                zeroIntercept,
                screenBox[3],
                zeroLineWidth[i],
                zeroLineColor[i]
              );
            } else {
              line.drawLine(
                screenBox[0],
                zeroIntercept,
                screenBox[2],
                zeroIntercept,
                zeroLineWidth[i],
                zeroLineColor[i]
              );
            }
          }
        }
        for (var i = 0; i < objects.length; ++i) {
          objects[i].draw();
        }
        gl2.viewport(
          screenBox[0],
          screenBox[1],
          screenBox[2] - screenBox[0],
          screenBox[3] - screenBox[1]
        );
        gl2.scissor(
          screenBox[0],
          screenBox[1],
          screenBox[2] - screenBox[0],
          screenBox[3] - screenBox[1]
        );
        this.grid.drawTickMarks();
        line.bind();
        var borderLineEnable = this.borderLineEnable;
        var borderLineWidth = this.borderLineWidth;
        var borderLineColor = this.borderLineColor;
        if (borderLineEnable[1]) {
          line.drawLine(
            viewPixels[0],
            viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio,
            viewPixels[0],
            viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio,
            borderLineWidth[1],
            borderLineColor[1]
          );
        }
        if (borderLineEnable[0]) {
          line.drawLine(
            viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio,
            viewPixels[1],
            viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio,
            viewPixels[1],
            borderLineWidth[0],
            borderLineColor[0]
          );
        }
        if (borderLineEnable[3]) {
          line.drawLine(
            viewPixels[2],
            viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio,
            viewPixels[2],
            viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio,
            borderLineWidth[3],
            borderLineColor[3]
          );
        }
        if (borderLineEnable[2]) {
          line.drawLine(
            viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio,
            viewPixels[3],
            viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio,
            viewPixels[3],
            borderLineWidth[2],
            borderLineColor[2]
          );
        }
        text.bind();
        for (var i = 0; i < 2; ++i) {
          text.drawTicks(i);
        }
        if (this.titleEnable) {
          text.drawTitle();
        }
        var overlays = this.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          overlays[i].draw();
        }
        gl2.disable(gl2.SCISSOR_TEST);
        gl2.disable(gl2.BLEND);
        gl2.depthMask(true);
      };
    }();
    proto.drawPick = /* @__PURE__ */ function() {
      return function() {
        if (this.static) return;
        var pickBuffer = this.pickBuffer;
        var gl2 = this.gl;
        this._pickTimeout = null;
        pickBuffer.begin();
        var pickOffset = 1;
        var objects = this.objects;
        for (var i = 0; i < objects.length; ++i) {
          pickOffset = objects[i].drawPick(pickOffset);
        }
        pickBuffer.end();
      };
    }();
    proto.pick = /* @__PURE__ */ function() {
      return function(x, y) {
        if (this.static) return;
        var pixelRatio = this.pixelRatio;
        var pickPixelRatio = this.pickPixelRatio;
        var viewBox = this.viewBox;
        var scrX = Math.round((x - viewBox[0] / pixelRatio) * pickPixelRatio) | 0;
        var scrY = Math.round((y - viewBox[1] / pixelRatio) * pickPixelRatio) | 0;
        var pickResult = this.pickBuffer.query(scrX, scrY, this.pickRadius);
        if (!pickResult) {
          return null;
        }
        var pickValue = pickResult.id + (pickResult.value[0] << 8) + (pickResult.value[1] << 16) + (pickResult.value[2] << 24);
        var objects = this.objects;
        for (var i = 0; i < objects.length; ++i) {
          var result = objects[i].pick(scrX, scrY, pickValue);
          if (result) {
            return result;
          }
        }
        return null;
      };
    }();
    function deepClone(array) {
      var result = array.slice();
      for (var i = 0; i < result.length; ++i) {
        result[i] = result[i].slice();
      }
      return result;
    }
    function compareTicks(a, b) {
      return a.x - b.x;
    }
    proto.setScreenBox = function(nbox) {
      var screenBox = this.screenBox;
      var pixelRatio = this.pixelRatio;
      screenBox[0] = Math.round(nbox[0] * pixelRatio) | 0;
      screenBox[1] = Math.round(nbox[1] * pixelRatio) | 0;
      screenBox[2] = Math.round(nbox[2] * pixelRatio) | 0;
      screenBox[3] = Math.round(nbox[3] * pixelRatio) | 0;
      this.setDirty();
    };
    proto.setDataBox = function(nbox) {
      var dataBox = this.dataBox;
      var different = dataBox[0] !== nbox[0] || dataBox[1] !== nbox[1] || dataBox[2] !== nbox[2] || dataBox[3] !== nbox[3];
      if (different) {
        dataBox[0] = nbox[0];
        dataBox[1] = nbox[1];
        dataBox[2] = nbox[2];
        dataBox[3] = nbox[3];
        this.setDirty();
      }
    };
    proto.setViewBox = function(nbox) {
      var pixelRatio = this.pixelRatio;
      var viewBox = this.viewBox;
      viewBox[0] = Math.round(nbox[0] * pixelRatio) | 0;
      viewBox[1] = Math.round(nbox[1] * pixelRatio) | 0;
      viewBox[2] = Math.round(nbox[2] * pixelRatio) | 0;
      viewBox[3] = Math.round(nbox[3] * pixelRatio) | 0;
      var pickPixelRatio = this.pickPixelRatio;
      this.pickBuffer.shape = [
        Math.round((nbox[2] - nbox[0]) * pickPixelRatio) | 0,
        Math.round((nbox[3] - nbox[1]) * pickPixelRatio) | 0
      ];
      this.setDirty();
    };
    proto.update = function(options) {
      options = options || {};
      var gl2 = this.gl;
      this.pixelRatio = options.pixelRatio || 1;
      var pixelRatio = this.pixelRatio;
      this.pickPixelRatio = Math.max(pixelRatio, 1);
      this.setScreenBox(options.screenBox || [0, 0, gl2.drawingBufferWidth / pixelRatio, gl2.drawingBufferHeight / pixelRatio]);
      var screenBox = this.screenBox;
      this.setViewBox(options.viewBox || [
        0.125 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio,
        0.125 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio,
        0.875 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio,
        0.875 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio
      ]);
      var viewBox = this.viewBox;
      var aspectRatio = (viewBox[2] - viewBox[0]) / (viewBox[3] - viewBox[1]);
      this.setDataBox(options.dataBox || [-10, -10 / aspectRatio, 10, 10 / aspectRatio]);
      this.borderColor = options.borderColor !== false ? (options.borderColor || [0, 0, 0, 0]).slice() : false;
      this.backgroundColor = (options.backgroundColor || [0, 0, 0, 0]).slice();
      this.gridLineEnable = (options.gridLineEnable || [true, true]).slice();
      this.gridLineWidth = (options.gridLineWidth || [1, 1]).slice();
      this.gridLineColor = deepClone(options.gridLineColor || [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]);
      this.zeroLineEnable = (options.zeroLineEnable || [true, true]).slice();
      this.zeroLineWidth = (options.zeroLineWidth || [4, 4]).slice();
      this.zeroLineColor = deepClone(options.zeroLineColor || [[0, 0, 0, 1], [0, 0, 0, 1]]);
      this.tickMarkLength = (options.tickMarkLength || [0, 0, 0, 0]).slice();
      this.tickMarkWidth = (options.tickMarkWidth || [0, 0, 0, 0]).slice();
      this.tickMarkColor = deepClone(options.tickMarkColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
      this.titleCenter = (options.titleCenter || [
        0.5 * (viewBox[0] + viewBox[2]) / pixelRatio,
        (viewBox[3] + 120) / pixelRatio
      ]).slice();
      this.titleEnable = !("titleEnable" in options) || !!options.titleEnable;
      this.titleAngle = options.titleAngle || 0;
      this.titleColor = (options.titleColor || [0, 0, 0, 1]).slice();
      this.labelPad = (options.labelPad || [15, 15, 15, 15]).slice();
      this.labelAngle = (options.labelAngle || [0, Math.PI / 2, 0, 3 * Math.PI / 2]).slice();
      this.labelEnable = (options.labelEnable || [true, true, true, true]).slice();
      this.labelColor = deepClone(options.labelColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
      this.tickPad = (options.tickPad || [15, 15, 15, 15]).slice();
      this.tickAngle = (options.tickAngle || [0, 0, 0, 0]).slice();
      this.tickEnable = (options.tickEnable || [true, true, true, true]).slice();
      this.tickColor = deepClone(options.tickColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);
      this.borderLineEnable = (options.borderLineEnable || [true, true, true, true]).slice();
      this.borderLineWidth = (options.borderLineWidth || [2, 2, 2, 2]).slice();
      this.borderLineColor = deepClone(options.borderLineColor || [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ]);
      var ticks = options.ticks || [[], []];
      var bounds = this._tickBounds;
      bounds[0] = bounds[1] = Infinity;
      bounds[2] = bounds[3] = -Infinity;
      for (var i = 0; i < 2; ++i) {
        var axisTicks = ticks[i].slice(0);
        if (axisTicks.length === 0) {
          continue;
        }
        axisTicks.sort(compareTicks);
        bounds[i] = Math.min(bounds[i], axisTicks[0].x);
        bounds[i + 2] = Math.max(bounds[i + 2], axisTicks[axisTicks.length - 1].x);
      }
      this.grid.update({
        bounds,
        ticks
      });
      this.text.update({
        bounds,
        ticks,
        labels: options.labels || ["x", "y"],
        labelSize: options.labelSize || [12, 12],
        labelFont: options.labelFont || ["sans-serif", "sans-serif"],
        labelFontStyle: options.labelFontStyle || ["normal", "normal"],
        labelFontWeight: options.labelFontWeight || ["normal", "normal"],
        labelFontVariant: options.labelFontVariant || ["normal", "normal"],
        title: options.title || "",
        titleSize: options.titleSize || 18,
        titleFont: options.titleFont || "sans-serif",
        titleFontStyle: options.titleFontStyle || "normal",
        titleFontWeight: options.titleFontWeight || "normal",
        titleFontVariant: options.titleFontVariant || "normal"
      });
      this.static = !!options.static;
      this.setDirty();
    };
    proto.dispose = function() {
      this.box.dispose();
      this.grid.dispose();
      this.text.dispose();
      this.line.dispose();
      for (var i = this.objects.length - 1; i >= 0; --i) {
        this.objects[i].dispose();
      }
      this.objects.length = 0;
      for (var i = this.overlays.length - 1; i >= 0; --i) {
        this.overlays[i].dispose();
      }
      this.overlays.length = 0;
      this.gl = null;
    };
    proto.addObject = function(object) {
      if (this.objects.indexOf(object) < 0) {
        this.objects.push(object);
        this.setDirty();
      }
    };
    proto.removeObject = function(object) {
      var objects = this.objects;
      for (var i = 0; i < objects.length; ++i) {
        if (objects[i] === object) {
          objects.splice(i, 1);
          this.setDirty();
          break;
        }
      }
    };
    proto.addOverlay = function(object) {
      if (this.overlays.indexOf(object) < 0) {
        this.overlays.push(object);
        this.setOverlayDirty();
      }
    };
    proto.removeOverlay = function(object) {
      var objects = this.overlays;
      for (var i = 0; i < objects.length; ++i) {
        if (objects[i] === object) {
          objects.splice(i, 1);
          this.setOverlayDirty();
          break;
        }
      }
    };
    function createGLPlot2D(options) {
      var gl2 = options.gl;
      var pickBuffer = createPick(gl2, [
        gl2.drawingBufferWidth,
        gl2.drawingBufferHeight
      ]);
      var plot = new GLPlot2D(gl2, pickBuffer);
      plot.grid = createGrid(plot);
      plot.text = createText(plot);
      plot.line = createLine(plot);
      plot.box = createBox(plot);
      plot.update(options);
      return plot;
    }
  }
});

// node_modules/right-now/browser.js
var require_browser2 = __commonJS({
  "node_modules/right-now/browser.js"(exports2, module2) {
    module2.exports = window.performance && window.performance.now ? function now() {
      return performance.now();
    } : Date.now || function now() {
      return +/* @__PURE__ */ new Date();
    };
  }
});

// node_modules/cubic-hermite/hermite.js
var require_hermite = __commonJS({
  "node_modules/cubic-hermite/hermite.js"(exports2, module2) {
    "use strict";
    function dcubicHermite(p0, v0, p1, v1, t, f) {
      var dh00 = 6 * t * t - 6 * t, dh10 = 3 * t * t - 4 * t + 1, dh01 = -6 * t * t + 6 * t, dh11 = 3 * t * t - 2 * t;
      if (p0.length) {
        if (!f) {
          f = new Array(p0.length);
        }
        for (var i = p0.length - 1; i >= 0; --i) {
          f[i] = dh00 * p0[i] + dh10 * v0[i] + dh01 * p1[i] + dh11 * v1[i];
        }
        return f;
      }
      return dh00 * p0 + dh10 * v0 + dh01 * p1[i] + dh11 * v1;
    }
    function cubicHermite(p0, v0, p1, v1, t, f) {
      var ti = t - 1, t2 = t * t, ti2 = ti * ti, h00 = (1 + 2 * t) * ti2, h10 = t * ti2, h01 = t2 * (3 - 2 * t), h11 = t2 * ti;
      if (p0.length) {
        if (!f) {
          f = new Array(p0.length);
        }
        for (var i = p0.length - 1; i >= 0; --i) {
          f[i] = h00 * p0[i] + h10 * v0[i] + h01 * p1[i] + h11 * v1[i];
        }
        return f;
      }
      return h00 * p0 + h10 * v0 + h01 * p1 + h11 * v1;
    }
    module2.exports = cubicHermite;
    module2.exports.derivative = dcubicHermite;
  }
});

// node_modules/filtered-vector/fvec.js
var require_fvec = __commonJS({
  "node_modules/filtered-vector/fvec.js"(exports2, module2) {
    "use strict";
    module2.exports = createFilteredVector;
    var cubicHermite = require_hermite();
    var bsearch = require_search_bounds();
    function clamp(lo, hi, x) {
      return Math.min(hi, Math.max(lo, x));
    }
    function FilteredVector(state0, velocity0, t0) {
      this.dimension = state0.length;
      this.bounds = [new Array(this.dimension), new Array(this.dimension)];
      for (var i = 0; i < this.dimension; ++i) {
        this.bounds[0][i] = -Infinity;
        this.bounds[1][i] = Infinity;
      }
      this._state = state0.slice().reverse();
      this._velocity = velocity0.slice().reverse();
      this._time = [t0];
      this._scratch = [state0.slice(), state0.slice(), state0.slice(), state0.slice(), state0.slice()];
    }
    var proto = FilteredVector.prototype;
    proto.flush = function(t) {
      var idx = bsearch.gt(this._time, t) - 1;
      if (idx <= 0) {
        return;
      }
      this._time.splice(0, idx);
      this._state.splice(0, idx * this.dimension);
      this._velocity.splice(0, idx * this.dimension);
    };
    proto.curve = function(t) {
      var time = this._time;
      var n = time.length;
      var idx = bsearch.le(time, t);
      var result = this._scratch[0];
      var state = this._state;
      var velocity = this._velocity;
      var d = this.dimension;
      var bounds = this.bounds;
      if (idx < 0) {
        var ptr = d - 1;
        for (var i = 0; i < d; ++i, --ptr) {
          result[i] = state[ptr];
        }
      } else if (idx >= n - 1) {
        var ptr = state.length - 1;
        var tf = t - time[n - 1];
        for (var i = 0; i < d; ++i, --ptr) {
          result[i] = state[ptr] + tf * velocity[ptr];
        }
      } else {
        var ptr = d * (idx + 1) - 1;
        var t0 = time[idx];
        var t1 = time[idx + 1];
        var dt = t1 - t0 || 1;
        var x0 = this._scratch[1];
        var x1 = this._scratch[2];
        var v0 = this._scratch[3];
        var v1 = this._scratch[4];
        var steady = true;
        for (var i = 0; i < d; ++i, --ptr) {
          x0[i] = state[ptr];
          v0[i] = velocity[ptr] * dt;
          x1[i] = state[ptr + d];
          v1[i] = velocity[ptr + d] * dt;
          steady = steady && (x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0);
        }
        if (steady) {
          for (var i = 0; i < d; ++i) {
            result[i] = x0[i];
          }
        } else {
          cubicHermite(x0, v0, x1, v1, (t - t0) / dt, result);
        }
      }
      var lo = bounds[0];
      var hi = bounds[1];
      for (var i = 0; i < d; ++i) {
        result[i] = clamp(lo[i], hi[i], result[i]);
      }
      return result;
    };
    proto.dcurve = function(t) {
      var time = this._time;
      var n = time.length;
      var idx = bsearch.le(time, t);
      var result = this._scratch[0];
      var state = this._state;
      var velocity = this._velocity;
      var d = this.dimension;
      if (idx >= n - 1) {
        var ptr = state.length - 1;
        var tf = t - time[n - 1];
        for (var i = 0; i < d; ++i, --ptr) {
          result[i] = velocity[ptr];
        }
      } else {
        var ptr = d * (idx + 1) - 1;
        var t0 = time[idx];
        var t1 = time[idx + 1];
        var dt = t1 - t0 || 1;
        var x0 = this._scratch[1];
        var x1 = this._scratch[2];
        var v0 = this._scratch[3];
        var v1 = this._scratch[4];
        var steady = true;
        for (var i = 0; i < d; ++i, --ptr) {
          x0[i] = state[ptr];
          v0[i] = velocity[ptr] * dt;
          x1[i] = state[ptr + d];
          v1[i] = velocity[ptr + d] * dt;
          steady = steady && (x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0);
        }
        if (steady) {
          for (var i = 0; i < d; ++i) {
            result[i] = 0;
          }
        } else {
          cubicHermite.derivative(x0, v0, x1, v1, (t - t0) / dt, result);
          for (var i = 0; i < d; ++i) {
            result[i] /= dt;
          }
        }
      }
      return result;
    };
    proto.lastT = function() {
      var time = this._time;
      return time[time.length - 1];
    };
    proto.stable = function() {
      var velocity = this._velocity;
      var ptr = velocity.length;
      for (var i = this.dimension - 1; i >= 0; --i) {
        if (velocity[--ptr]) {
          return false;
        }
      }
      return true;
    };
    proto.jump = function(t) {
      var t0 = this.lastT();
      var d = this.dimension;
      if (t < t0 || arguments.length !== d + 1) {
        return;
      }
      var state = this._state;
      var velocity = this._velocity;
      var ptr = state.length - this.dimension;
      var bounds = this.bounds;
      var lo = bounds[0];
      var hi = bounds[1];
      this._time.push(t0, t);
      for (var j = 0; j < 2; ++j) {
        for (var i = 0; i < d; ++i) {
          state.push(state[ptr++]);
          velocity.push(0);
        }
      }
      this._time.push(t);
      for (var i = d; i > 0; --i) {
        state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));
        velocity.push(0);
      }
    };
    proto.push = function(t) {
      var t0 = this.lastT();
      var d = this.dimension;
      if (t < t0 || arguments.length !== d + 1) {
        return;
      }
      var state = this._state;
      var velocity = this._velocity;
      var ptr = state.length - this.dimension;
      var dt = t - t0;
      var bounds = this.bounds;
      var lo = bounds[0];
      var hi = bounds[1];
      var sf = dt > 1e-6 ? 1 / dt : 0;
      this._time.push(t);
      for (var i = d; i > 0; --i) {
        var xc = clamp(lo[i - 1], hi[i - 1], arguments[i]);
        state.push(xc);
        velocity.push((xc - state[ptr++]) * sf);
      }
    };
    proto.set = function(t) {
      var d = this.dimension;
      if (t < this.lastT() || arguments.length !== d + 1) {
        return;
      }
      var state = this._state;
      var velocity = this._velocity;
      var bounds = this.bounds;
      var lo = bounds[0];
      var hi = bounds[1];
      this._time.push(t);
      for (var i = d; i > 0; --i) {
        state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));
        velocity.push(0);
      }
    };
    proto.move = function(t) {
      var t0 = this.lastT();
      var d = this.dimension;
      if (t <= t0 || arguments.length !== d + 1) {
        return;
      }
      var state = this._state;
      var velocity = this._velocity;
      var statePtr = state.length - this.dimension;
      var bounds = this.bounds;
      var lo = bounds[0];
      var hi = bounds[1];
      var dt = t - t0;
      var sf = dt > 1e-6 ? 1 / dt : 0;
      this._time.push(t);
      for (var i = d; i > 0; --i) {
        var dx = arguments[i];
        state.push(clamp(lo[i - 1], hi[i - 1], state[statePtr++] + dx));
        velocity.push(dx * sf);
      }
    };
    proto.idle = function(t) {
      var t0 = this.lastT();
      if (t < t0) {
        return;
      }
      var d = this.dimension;
      var state = this._state;
      var velocity = this._velocity;
      var statePtr = state.length - d;
      var bounds = this.bounds;
      var lo = bounds[0];
      var hi = bounds[1];
      var dt = t - t0;
      this._time.push(t);
      for (var i = d - 1; i >= 0; --i) {
        state.push(clamp(lo[i], hi[i], state[statePtr] + dt * velocity[statePtr]));
        velocity.push(0);
        statePtr += 1;
      }
    };
    function getZero(d) {
      var result = new Array(d);
      for (var i = 0; i < d; ++i) {
        result[i] = 0;
      }
      return result;
    }
    function createFilteredVector(initState, initVelocity, initTime) {
      switch (arguments.length) {
        case 0:
          return new FilteredVector([0], [0], 0);
        case 1:
          if (typeof initState === "number") {
            var zero = getZero(initState);
            return new FilteredVector(zero, zero, 0);
          } else {
            return new FilteredVector(initState, getZero(initState.length), 0);
          }
        case 2:
          if (typeof initVelocity === "number") {
            var zero = getZero(initState.length);
            return new FilteredVector(initState, zero, +initVelocity);
          } else {
            initTime = 0;
          }
        case 3:
          if (initState.length !== initVelocity.length) {
            throw new Error("state and velocity lengths must match");
          }
          return new FilteredVector(initState, initVelocity, initTime);
      }
    }
  }
});

// node_modules/gl-mat4/rotate.js
var require_rotate = __commonJS({
  "node_modules/gl-mat4/rotate.js"(exports2, module2) {
    module2.exports = rotate;
    function rotate(out, a, rad, axis) {
      var x = axis[0], y = axis[1], z = axis[2], len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
      if (Math.abs(len) < 1e-6) {
        return null;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c;
      out[0] = a00 * b00 + a10 * b01 + a20 * b02;
      out[1] = a01 * b00 + a11 * b01 + a21 * b02;
      out[2] = a02 * b00 + a12 * b01 + a22 * b02;
      out[3] = a03 * b00 + a13 * b01 + a23 * b02;
      out[4] = a00 * b10 + a10 * b11 + a20 * b12;
      out[5] = a01 * b10 + a11 * b11 + a21 * b12;
      out[6] = a02 * b10 + a12 * b11 + a22 * b12;
      out[7] = a03 * b10 + a13 * b11 + a23 * b12;
      out[8] = a00 * b20 + a10 * b21 + a20 * b22;
      out[9] = a01 * b20 + a11 * b21 + a21 * b22;
      out[10] = a02 * b20 + a12 * b21 + a22 * b22;
      out[11] = a03 * b20 + a13 * b21 + a23 * b22;
      if (a !== out) {
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }
      return out;
    }
  }
});

// node_modules/turntable-camera-controller/turntable.js
var require_turntable = __commonJS({
  "node_modules/turntable-camera-controller/turntable.js"(exports2, module2) {
    "use strict";
    module2.exports = createTurntableController;
    var filterVector = require_fvec();
    var invert44 = require_invert();
    var rotateM = require_rotate();
    var cross = require_cross();
    var normalize3 = require_normalize();
    var dot3 = require_dot();
    function len3(x, y, z) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    }
    function clamp1(x) {
      return Math.min(1, Math.max(-1, x));
    }
    function findOrthoPair(v) {
      var vx = Math.abs(v[0]);
      var vy = Math.abs(v[1]);
      var vz = Math.abs(v[2]);
      var u = [0, 0, 0];
      if (vx > Math.max(vy, vz)) {
        u[2] = 1;
      } else if (vy > Math.max(vx, vz)) {
        u[0] = 1;
      } else {
        u[1] = 1;
      }
      var vv = 0;
      var uv = 0;
      for (var i = 0; i < 3; ++i) {
        vv += v[i] * v[i];
        uv += u[i] * v[i];
      }
      for (var i = 0; i < 3; ++i) {
        u[i] -= uv / vv * v[i];
      }
      normalize3(u, u);
      return u;
    }
    function TurntableController(zoomMin, zoomMax, center, up, right, radius, theta, phi) {
      this.center = filterVector(center);
      this.up = filterVector(up);
      this.right = filterVector(right);
      this.radius = filterVector([radius]);
      this.angle = filterVector([theta, phi]);
      this.angle.bounds = [[-Infinity, -Math.PI / 2], [Infinity, Math.PI / 2]];
      this.setDistanceLimits(zoomMin, zoomMax);
      this.computedCenter = this.center.curve(0);
      this.computedUp = this.up.curve(0);
      this.computedRight = this.right.curve(0);
      this.computedRadius = this.radius.curve(0);
      this.computedAngle = this.angle.curve(0);
      this.computedToward = [0, 0, 0];
      this.computedEye = [0, 0, 0];
      this.computedMatrix = new Array(16);
      for (var i = 0; i < 16; ++i) {
        this.computedMatrix[i] = 0.5;
      }
      this.recalcMatrix(0);
    }
    var proto = TurntableController.prototype;
    proto.setDistanceLimits = function(minDist, maxDist) {
      if (minDist > 0) {
        minDist = Math.log(minDist);
      } else {
        minDist = -Infinity;
      }
      if (maxDist > 0) {
        maxDist = Math.log(maxDist);
      } else {
        maxDist = Infinity;
      }
      maxDist = Math.max(maxDist, minDist);
      this.radius.bounds[0][0] = minDist;
      this.radius.bounds[1][0] = maxDist;
    };
    proto.getDistanceLimits = function(out) {
      var bounds = this.radius.bounds[0];
      if (out) {
        out[0] = Math.exp(bounds[0][0]);
        out[1] = Math.exp(bounds[1][0]);
        return out;
      }
      return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];
    };
    proto.recalcMatrix = function(t) {
      this.center.curve(t);
      this.up.curve(t);
      this.right.curve(t);
      this.radius.curve(t);
      this.angle.curve(t);
      var up = this.computedUp;
      var right = this.computedRight;
      var uu = 0;
      var ur = 0;
      for (var i = 0; i < 3; ++i) {
        ur += up[i] * right[i];
        uu += up[i] * up[i];
      }
      var ul = Math.sqrt(uu);
      var rr = 0;
      for (var i = 0; i < 3; ++i) {
        right[i] -= up[i] * ur / uu;
        rr += right[i] * right[i];
        up[i] /= ul;
      }
      var rl = Math.sqrt(rr);
      for (var i = 0; i < 3; ++i) {
        right[i] /= rl;
      }
      var toward = this.computedToward;
      cross(toward, up, right);
      normalize3(toward, toward);
      var radius = Math.exp(this.computedRadius[0]);
      var theta = this.computedAngle[0];
      var phi = this.computedAngle[1];
      var ctheta = Math.cos(theta);
      var stheta = Math.sin(theta);
      var cphi = Math.cos(phi);
      var sphi = Math.sin(phi);
      var center = this.computedCenter;
      var wx = ctheta * cphi;
      var wy = stheta * cphi;
      var wz = sphi;
      var sx = -ctheta * sphi;
      var sy = -stheta * sphi;
      var sz = cphi;
      var eye = this.computedEye;
      var mat = this.computedMatrix;
      for (var i = 0; i < 3; ++i) {
        var x = wx * right[i] + wy * toward[i] + wz * up[i];
        mat[4 * i + 1] = sx * right[i] + sy * toward[i] + sz * up[i];
        mat[4 * i + 2] = x;
        mat[4 * i + 3] = 0;
      }
      var ax = mat[1];
      var ay = mat[5];
      var az = mat[9];
      var bx = mat[2];
      var by = mat[6];
      var bz = mat[10];
      var cx = ay * bz - az * by;
      var cy = az * bx - ax * bz;
      var cz = ax * by - ay * bx;
      var cl = len3(cx, cy, cz);
      cx /= cl;
      cy /= cl;
      cz /= cl;
      mat[0] = cx;
      mat[4] = cy;
      mat[8] = cz;
      for (var i = 0; i < 3; ++i) {
        eye[i] = center[i] + mat[2 + 4 * i] * radius;
      }
      for (var i = 0; i < 3; ++i) {
        var rr = 0;
        for (var j = 0; j < 3; ++j) {
          rr += mat[i + 4 * j] * eye[j];
        }
        mat[12 + i] = -rr;
      }
      mat[15] = 1;
    };
    proto.getMatrix = function(t, result) {
      this.recalcMatrix(t);
      var mat = this.computedMatrix;
      if (result) {
        for (var i = 0; i < 16; ++i) {
          result[i] = mat[i];
        }
        return result;
      }
      return mat;
    };
    var zAxis = [0, 0, 0];
    proto.rotate = function(t, dtheta, dphi, droll) {
      this.angle.move(t, dtheta, dphi);
      if (droll) {
        this.recalcMatrix(t);
        var mat = this.computedMatrix;
        zAxis[0] = mat[2];
        zAxis[1] = mat[6];
        zAxis[2] = mat[10];
        var up = this.computedUp;
        var right = this.computedRight;
        var toward = this.computedToward;
        for (var i = 0; i < 3; ++i) {
          mat[4 * i] = up[i];
          mat[4 * i + 1] = right[i];
          mat[4 * i + 2] = toward[i];
        }
        rotateM(mat, mat, droll, zAxis);
        for (var i = 0; i < 3; ++i) {
          up[i] = mat[4 * i];
          right[i] = mat[4 * i + 1];
        }
        this.up.set(t, up[0], up[1], up[2]);
        this.right.set(t, right[0], right[1], right[2]);
      }
    };
    proto.pan = function(t, dx, dy, dz) {
      dx = dx || 0;
      dy = dy || 0;
      dz = dz || 0;
      this.recalcMatrix(t);
      var mat = this.computedMatrix;
      var dist = Math.exp(this.computedRadius[0]);
      var ux = mat[1];
      var uy = mat[5];
      var uz = mat[9];
      var ul = len3(ux, uy, uz);
      ux /= ul;
      uy /= ul;
      uz /= ul;
      var rx = mat[0];
      var ry = mat[4];
      var rz = mat[8];
      var ru = rx * ux + ry * uy + rz * uz;
      rx -= ux * ru;
      ry -= uy * ru;
      rz -= uz * ru;
      var rl = len3(rx, ry, rz);
      rx /= rl;
      ry /= rl;
      rz /= rl;
      var vx = rx * dx + ux * dy;
      var vy = ry * dx + uy * dy;
      var vz = rz * dx + uz * dy;
      this.center.move(t, vx, vy, vz);
      var radius = Math.exp(this.computedRadius[0]);
      radius = Math.max(1e-4, radius + dz);
      this.radius.set(t, Math.log(radius));
    };
    proto.translate = function(t, dx, dy, dz) {
      this.center.move(
        t,
        dx || 0,
        dy || 0,
        dz || 0
      );
    };
    proto.setMatrix = function(t, mat, axes, noSnap) {
      var ushift = 1;
      if (typeof axes === "number") {
        ushift = axes | 0;
      }
      if (ushift < 0 || ushift > 3) {
        ushift = 1;
      }
      var vshift = (ushift + 2) % 3;
      var fshift = (ushift + 1) % 3;
      if (!mat) {
        this.recalcMatrix(t);
        mat = this.computedMatrix;
      }
      var ux = mat[ushift];
      var uy = mat[ushift + 4];
      var uz = mat[ushift + 8];
      if (!noSnap) {
        var ul = len3(ux, uy, uz);
        ux /= ul;
        uy /= ul;
        uz /= ul;
      } else {
        var ax = Math.abs(ux);
        var ay = Math.abs(uy);
        var az = Math.abs(uz);
        var am = Math.max(ax, ay, az);
        if (ax === am) {
          ux = ux < 0 ? -1 : 1;
          uy = uz = 0;
        } else if (az === am) {
          uz = uz < 0 ? -1 : 1;
          ux = uy = 0;
        } else {
          uy = uy < 0 ? -1 : 1;
          ux = uz = 0;
        }
      }
      var rx = mat[vshift];
      var ry = mat[vshift + 4];
      var rz = mat[vshift + 8];
      var ru = rx * ux + ry * uy + rz * uz;
      rx -= ux * ru;
      ry -= uy * ru;
      rz -= uz * ru;
      var rl = len3(rx, ry, rz);
      rx /= rl;
      ry /= rl;
      rz /= rl;
      var fx = uy * rz - uz * ry;
      var fy = uz * rx - ux * rz;
      var fz = ux * ry - uy * rx;
      var fl = len3(fx, fy, fz);
      fx /= fl;
      fy /= fl;
      fz /= fl;
      this.center.jump(t, ex, ey, ez);
      this.radius.idle(t);
      this.up.jump(t, ux, uy, uz);
      this.right.jump(t, rx, ry, rz);
      var phi, theta;
      if (ushift === 2) {
        var cx = mat[1];
        var cy = mat[5];
        var cz = mat[9];
        var cr = cx * rx + cy * ry + cz * rz;
        var cf = cx * fx + cy * fy + cz * fz;
        if (tu < 0) {
          phi = -Math.PI / 2;
        } else {
          phi = Math.PI / 2;
        }
        theta = Math.atan2(cf, cr);
      } else {
        var tx = mat[2];
        var ty = mat[6];
        var tz = mat[10];
        var tu = tx * ux + ty * uy + tz * uz;
        var tr = tx * rx + ty * ry + tz * rz;
        var tf = tx * fx + ty * fy + tz * fz;
        phi = Math.asin(clamp1(tu));
        theta = Math.atan2(tf, tr);
      }
      this.angle.jump(t, theta, phi);
      this.recalcMatrix(t);
      var dx = mat[2];
      var dy = mat[6];
      var dz = mat[10];
      var imat = this.computedMatrix;
      invert44(imat, mat);
      var w = imat[15];
      var ex = imat[12] / w;
      var ey = imat[13] / w;
      var ez = imat[14] / w;
      var gs = Math.exp(this.computedRadius[0]);
      this.center.jump(t, ex - dx * gs, ey - dy * gs, ez - dz * gs);
    };
    proto.lastT = function() {
      return Math.max(
        this.center.lastT(),
        this.up.lastT(),
        this.right.lastT(),
        this.radius.lastT(),
        this.angle.lastT()
      );
    };
    proto.idle = function(t) {
      this.center.idle(t);
      this.up.idle(t);
      this.right.idle(t);
      this.radius.idle(t);
      this.angle.idle(t);
    };
    proto.flush = function(t) {
      this.center.flush(t);
      this.up.flush(t);
      this.right.flush(t);
      this.radius.flush(t);
      this.angle.flush(t);
    };
    proto.setDistance = function(t, d) {
      if (d > 0) {
        this.radius.set(t, Math.log(d));
      }
    };
    proto.lookAt = function(t, eye, center, up) {
      this.recalcMatrix(t);
      eye = eye || this.computedEye;
      center = center || this.computedCenter;
      up = up || this.computedUp;
      var ux = up[0];
      var uy = up[1];
      var uz = up[2];
      var ul = len3(ux, uy, uz);
      if (ul < 1e-6) {
        return;
      }
      ux /= ul;
      uy /= ul;
      uz /= ul;
      var tx = eye[0] - center[0];
      var ty = eye[1] - center[1];
      var tz = eye[2] - center[2];
      var tl = len3(tx, ty, tz);
      if (tl < 1e-6) {
        return;
      }
      tx /= tl;
      ty /= tl;
      tz /= tl;
      var right = this.computedRight;
      var rx = right[0];
      var ry = right[1];
      var rz = right[2];
      var ru = ux * rx + uy * ry + uz * rz;
      rx -= ru * ux;
      ry -= ru * uy;
      rz -= ru * uz;
      var rl = len3(rx, ry, rz);
      if (rl < 0.01) {
        rx = uy * tz - uz * ty;
        ry = uz * tx - ux * tz;
        rz = ux * ty - uy * tx;
        rl = len3(rx, ry, rz);
        if (rl < 1e-6) {
          return;
        }
      }
      rx /= rl;
      ry /= rl;
      rz /= rl;
      this.up.set(t, ux, uy, uz);
      this.right.set(t, rx, ry, rz);
      this.center.set(t, center[0], center[1], center[2]);
      this.radius.set(t, Math.log(tl));
      var fx = uy * rz - uz * ry;
      var fy = uz * rx - ux * rz;
      var fz = ux * ry - uy * rx;
      var fl = len3(fx, fy, fz);
      fx /= fl;
      fy /= fl;
      fz /= fl;
      var tu = ux * tx + uy * ty + uz * tz;
      var tr = rx * tx + ry * ty + rz * tz;
      var tf = fx * tx + fy * ty + fz * tz;
      var phi = Math.asin(clamp1(tu));
      var theta = Math.atan2(tf, tr);
      var angleState = this.angle._state;
      var lastTheta = angleState[angleState.length - 1];
      var lastPhi = angleState[angleState.length - 2];
      lastTheta = lastTheta % (2 * Math.PI);
      var dp = Math.abs(lastTheta + 2 * Math.PI - theta);
      var d0 = Math.abs(lastTheta - theta);
      var dn = Math.abs(lastTheta - 2 * Math.PI - theta);
      if (dp < d0) {
        lastTheta += 2 * Math.PI;
      }
      if (dn < d0) {
        lastTheta -= 2 * Math.PI;
      }
      this.angle.jump(this.angle.lastT(), lastTheta, lastPhi);
      this.angle.set(t, theta, phi);
    };
    function createTurntableController(options) {
      options = options || {};
      var center = options.center || [0, 0, 0];
      var up = options.up || [0, 1, 0];
      var right = options.right || findOrthoPair(up);
      var radius = options.radius || 1;
      var theta = options.theta || 0;
      var phi = options.phi || 0;
      center = [].slice.call(center, 0, 3);
      up = [].slice.call(up, 0, 3);
      normalize3(up, up);
      right = [].slice.call(right, 0, 3);
      normalize3(right, right);
      if ("eye" in options) {
        var eye = options.eye;
        var toward = [
          eye[0] - center[0],
          eye[1] - center[1],
          eye[2] - center[2]
        ];
        cross(right, toward, up);
        if (len3(right[0], right[1], right[2]) < 1e-6) {
          right = findOrthoPair(up);
        } else {
          normalize3(right, right);
        }
        radius = len3(toward[0], toward[1], toward[2]);
        var ut = dot3(up, toward) / radius;
        var rt = dot3(right, toward) / radius;
        phi = Math.acos(ut);
        theta = Math.acos(rt);
      }
      radius = Math.log(radius);
      return new TurntableController(
        options.zoomMin,
        options.zoomMax,
        center,
        up,
        right,
        radius,
        theta,
        phi
      );
    }
  }
});

// node_modules/gl-mat4/identity.js
var require_identity = __commonJS({
  "node_modules/gl-mat4/identity.js"(exports2, module2) {
    module2.exports = identity;
    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/gl-mat4/lookAt.js
var require_lookAt = __commonJS({
  "node_modules/gl-mat4/lookAt.js"(exports2, module2) {
    var identity = require_identity();
    module2.exports = lookAt;
    function lookAt(out, eye, center, up) {
      var x0, x1, x2, y0, y1, y2, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
      if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) {
        return identity(out);
      }
      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;
      len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
      if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      }
      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
      len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
      if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
      } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
      }
      out[0] = x0;
      out[1] = y0;
      out[2] = z0;
      out[3] = 0;
      out[4] = x1;
      out[5] = y1;
      out[6] = z1;
      out[7] = 0;
      out[8] = x2;
      out[9] = y2;
      out[10] = z2;
      out[11] = 0;
      out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
      out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
      out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/gl-mat4/fromQuat.js
var require_fromQuat = __commonJS({
  "node_modules/gl-mat4/fromQuat.js"(exports2, module2) {
    module2.exports = fromQuat;
    function fromQuat(out, q) {
      var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
      out[0] = 1 - yy - zz;
      out[1] = yx + wz;
      out[2] = zx - wy;
      out[3] = 0;
      out[4] = yx - wz;
      out[5] = 1 - xx - zz;
      out[6] = zy + wx;
      out[7] = 0;
      out[8] = zx + wy;
      out[9] = zy - wx;
      out[10] = 1 - xx - yy;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/orbit-camera-controller/lib/quatFromFrame.js
var require_quatFromFrame = __commonJS({
  "node_modules/orbit-camera-controller/lib/quatFromFrame.js"(exports2, module2) {
    "use strict";
    module2.exports = quatFromFrame;
    function quatFromFrame(out, rx, ry, rz, ux, uy, uz, fx, fy, fz) {
      var tr = rx + uy + fz;
      if (l > 0) {
        var l = Math.sqrt(tr + 1);
        out[0] = 0.5 * (uz - fy) / l;
        out[1] = 0.5 * (fx - rz) / l;
        out[2] = 0.5 * (ry - uy) / l;
        out[3] = 0.5 * l;
      } else {
        var tf = Math.max(rx, uy, fz);
        var l = Math.sqrt(2 * tf - tr + 1);
        if (rx >= tf) {
          out[0] = 0.5 * l;
          out[1] = 0.5 * (ux + ry) / l;
          out[2] = 0.5 * (fx + rz) / l;
          out[3] = 0.5 * (uz - fy) / l;
        } else if (uy >= tf) {
          out[0] = 0.5 * (ry + ux) / l;
          out[1] = 0.5 * l;
          out[2] = 0.5 * (fy + uz) / l;
          out[3] = 0.5 * (fx - rz) / l;
        } else {
          out[0] = 0.5 * (rz + fx) / l;
          out[1] = 0.5 * (uz + fy) / l;
          out[2] = 0.5 * l;
          out[3] = 0.5 * (ry - ux) / l;
        }
      }
      return out;
    }
  }
});

// node_modules/orbit-camera-controller/orbit.js
var require_orbit = __commonJS({
  "node_modules/orbit-camera-controller/orbit.js"(exports2, module2) {
    "use strict";
    module2.exports = createOrbitController;
    var filterVector = require_fvec();
    var lookAt = require_lookAt();
    var mat4FromQuat = require_fromQuat();
    var invert44 = require_invert();
    var quatFromFrame = require_quatFromFrame();
    function len3(x, y, z) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    }
    function len4(w, x, y, z) {
      return Math.sqrt(Math.pow(w, 2) + Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
    }
    function normalize4(out, a) {
      var ax = a[0];
      var ay = a[1];
      var az = a[2];
      var aw = a[3];
      var al = len4(ax, ay, az, aw);
      if (al > 1e-6) {
        out[0] = ax / al;
        out[1] = ay / al;
        out[2] = az / al;
        out[3] = aw / al;
      } else {
        out[0] = out[1] = out[2] = 0;
        out[3] = 1;
      }
    }
    function OrbitCameraController(initQuat, initCenter, initRadius) {
      this.radius = filterVector([initRadius]);
      this.center = filterVector(initCenter);
      this.rotation = filterVector(initQuat);
      this.computedRadius = this.radius.curve(0);
      this.computedCenter = this.center.curve(0);
      this.computedRotation = this.rotation.curve(0);
      this.computedUp = [0.1, 0, 0];
      this.computedEye = [0.1, 0, 0];
      this.computedMatrix = [0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.recalcMatrix(0);
    }
    var proto = OrbitCameraController.prototype;
    proto.lastT = function() {
      return Math.max(
        this.radius.lastT(),
        this.center.lastT(),
        this.rotation.lastT()
      );
    };
    proto.recalcMatrix = function(t) {
      this.radius.curve(t);
      this.center.curve(t);
      this.rotation.curve(t);
      var quat = this.computedRotation;
      normalize4(quat, quat);
      var mat = this.computedMatrix;
      mat4FromQuat(mat, quat);
      var center = this.computedCenter;
      var eye = this.computedEye;
      var up = this.computedUp;
      var radius = Math.exp(this.computedRadius[0]);
      eye[0] = center[0] + radius * mat[2];
      eye[1] = center[1] + radius * mat[6];
      eye[2] = center[2] + radius * mat[10];
      up[0] = mat[1];
      up[1] = mat[5];
      up[2] = mat[9];
      for (var i = 0; i < 3; ++i) {
        var rr = 0;
        for (var j = 0; j < 3; ++j) {
          rr += mat[i + 4 * j] * eye[j];
        }
        mat[12 + i] = -rr;
      }
    };
    proto.getMatrix = function(t, result) {
      this.recalcMatrix(t);
      var m = this.computedMatrix;
      if (result) {
        for (var i = 0; i < 16; ++i) {
          result[i] = m[i];
        }
        return result;
      }
      return m;
    };
    proto.idle = function(t) {
      this.center.idle(t);
      this.radius.idle(t);
      this.rotation.idle(t);
    };
    proto.flush = function(t) {
      this.center.flush(t);
      this.radius.flush(t);
      this.rotation.flush(t);
    };
    proto.pan = function(t, dx, dy, dz) {
      dx = dx || 0;
      dy = dy || 0;
      dz = dz || 0;
      this.recalcMatrix(t);
      var mat = this.computedMatrix;
      var ux = mat[1];
      var uy = mat[5];
      var uz = mat[9];
      var ul = len3(ux, uy, uz);
      ux /= ul;
      uy /= ul;
      uz /= ul;
      var rx = mat[0];
      var ry = mat[4];
      var rz = mat[8];
      var ru = rx * ux + ry * uy + rz * uz;
      rx -= ux * ru;
      ry -= uy * ru;
      rz -= uz * ru;
      var rl = len3(rx, ry, rz);
      rx /= rl;
      ry /= rl;
      rz /= rl;
      var fx = mat[2];
      var fy = mat[6];
      var fz = mat[10];
      var fu = fx * ux + fy * uy + fz * uz;
      var fr = fx * rx + fy * ry + fz * rz;
      fx -= fu * ux + fr * rx;
      fy -= fu * uy + fr * ry;
      fz -= fu * uz + fr * rz;
      var fl = len3(fx, fy, fz);
      fx /= fl;
      fy /= fl;
      fz /= fl;
      var vx = rx * dx + ux * dy;
      var vy = ry * dx + uy * dy;
      var vz = rz * dx + uz * dy;
      this.center.move(t, vx, vy, vz);
      var radius = Math.exp(this.computedRadius[0]);
      radius = Math.max(1e-4, radius + dz);
      this.radius.set(t, Math.log(radius));
    };
    proto.rotate = function(t, dx, dy, dz) {
      this.recalcMatrix(t);
      dx = dx || 0;
      dy = dy || 0;
      var mat = this.computedMatrix;
      var rx = mat[0];
      var ry = mat[4];
      var rz = mat[8];
      var ux = mat[1];
      var uy = mat[5];
      var uz = mat[9];
      var fx = mat[2];
      var fy = mat[6];
      var fz = mat[10];
      var qx = dx * rx + dy * ux;
      var qy = dx * ry + dy * uy;
      var qz = dx * rz + dy * uz;
      var bx = -(fy * qz - fz * qy);
      var by = -(fz * qx - fx * qz);
      var bz = -(fx * qy - fy * qx);
      var bw = Math.sqrt(Math.max(0, 1 - Math.pow(bx, 2) - Math.pow(by, 2) - Math.pow(bz, 2)));
      var bl = len4(bx, by, bz, bw);
      if (bl > 1e-6) {
        bx /= bl;
        by /= bl;
        bz /= bl;
        bw /= bl;
      } else {
        bx = by = bz = 0;
        bw = 1;
      }
      var rotation = this.computedRotation;
      var ax = rotation[0];
      var ay = rotation[1];
      var az = rotation[2];
      var aw = rotation[3];
      var cx = ax * bw + aw * bx + ay * bz - az * by;
      var cy = ay * bw + aw * by + az * bx - ax * bz;
      var cz = az * bw + aw * bz + ax * by - ay * bx;
      var cw = aw * bw - ax * bx - ay * by - az * bz;
      if (dz) {
        bx = fx;
        by = fy;
        bz = fz;
        var s = Math.sin(dz) / len3(bx, by, bz);
        bx *= s;
        by *= s;
        bz *= s;
        bw = Math.cos(dx);
        cx = cx * bw + cw * bx + cy * bz - cz * by;
        cy = cy * bw + cw * by + cz * bx - cx * bz;
        cz = cz * bw + cw * bz + cx * by - cy * bx;
        cw = cw * bw - cx * bx - cy * by - cz * bz;
      }
      var cl = len4(cx, cy, cz, cw);
      if (cl > 1e-6) {
        cx /= cl;
        cy /= cl;
        cz /= cl;
        cw /= cl;
      } else {
        cx = cy = cz = 0;
        cw = 1;
      }
      this.rotation.set(t, cx, cy, cz, cw);
    };
    proto.lookAt = function(t, eye, center, up) {
      this.recalcMatrix(t);
      center = center || this.computedCenter;
      eye = eye || this.computedEye;
      up = up || this.computedUp;
      var mat = this.computedMatrix;
      lookAt(mat, eye, center, up);
      var rotation = this.computedRotation;
      quatFromFrame(
        rotation,
        mat[0],
        mat[1],
        mat[2],
        mat[4],
        mat[5],
        mat[6],
        mat[8],
        mat[9],
        mat[10]
      );
      normalize4(rotation, rotation);
      this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);
      var fl = 0;
      for (var i = 0; i < 3; ++i) {
        fl += Math.pow(center[i] - eye[i], 2);
      }
      this.radius.set(t, 0.5 * Math.log(Math.max(fl, 1e-6)));
      this.center.set(t, center[0], center[1], center[2]);
    };
    proto.translate = function(t, dx, dy, dz) {
      this.center.move(
        t,
        dx || 0,
        dy || 0,
        dz || 0
      );
    };
    proto.setMatrix = function(t, matrix) {
      var rotation = this.computedRotation;
      quatFromFrame(
        rotation,
        matrix[0],
        matrix[1],
        matrix[2],
        matrix[4],
        matrix[5],
        matrix[6],
        matrix[8],
        matrix[9],
        matrix[10]
      );
      normalize4(rotation, rotation);
      this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);
      var mat = this.computedMatrix;
      invert44(mat, matrix);
      var w = mat[15];
      if (Math.abs(w) > 1e-6) {
        var cx = mat[12] / w;
        var cy = mat[13] / w;
        var cz = mat[14] / w;
        this.recalcMatrix(t);
        var r = Math.exp(this.computedRadius[0]);
        this.center.set(t, cx - mat[2] * r, cy - mat[6] * r, cz - mat[10] * r);
        this.radius.idle(t);
      } else {
        this.center.idle(t);
        this.radius.idle(t);
      }
    };
    proto.setDistance = function(t, d) {
      if (d > 0) {
        this.radius.set(t, Math.log(d));
      }
    };
    proto.setDistanceLimits = function(lo, hi) {
      if (lo > 0) {
        lo = Math.log(lo);
      } else {
        lo = -Infinity;
      }
      if (hi > 0) {
        hi = Math.log(hi);
      } else {
        hi = Infinity;
      }
      hi = Math.max(hi, lo);
      this.radius.bounds[0][0] = lo;
      this.radius.bounds[1][0] = hi;
    };
    proto.getDistanceLimits = function(out) {
      var bounds = this.radius.bounds;
      if (out) {
        out[0] = Math.exp(bounds[0][0]);
        out[1] = Math.exp(bounds[1][0]);
        return out;
      }
      return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];
    };
    proto.toJSON = function() {
      this.recalcMatrix(this.lastT());
      return {
        center: this.computedCenter.slice(),
        rotation: this.computedRotation.slice(),
        distance: Math.log(this.computedRadius[0]),
        zoomMin: this.radius.bounds[0][0],
        zoomMax: this.radius.bounds[1][0]
      };
    };
    proto.fromJSON = function(options) {
      var t = this.lastT();
      var c = options.center;
      if (c) {
        this.center.set(t, c[0], c[1], c[2]);
      }
      var r = options.rotation;
      if (r) {
        this.rotation.set(t, r[0], r[1], r[2], r[3]);
      }
      var d = options.distance;
      if (d && d > 0) {
        this.radius.set(t, Math.log(d));
      }
      this.setDistanceLimits(options.zoomMin, options.zoomMax);
    };
    function createOrbitController(options) {
      options = options || {};
      var center = options.center || [0, 0, 0];
      var rotation = options.rotation || [0, 0, 0, 1];
      var radius = options.radius || 1;
      center = [].slice.call(center, 0, 3);
      rotation = [].slice.call(rotation, 0, 4);
      normalize4(rotation, rotation);
      var result = new OrbitCameraController(
        rotation,
        center,
        Math.log(radius)
      );
      result.setDistanceLimits(options.zoomMin, options.zoomMax);
      if ("eye" in options || "up" in options) {
        result.lookAt(0, options.eye, options.center, options.up);
      }
      return result;
    }
  }
});

// node_modules/gl-mat4/translate.js
var require_translate = __commonJS({
  "node_modules/gl-mat4/translate.js"(exports2, module2) {
    module2.exports = translate;
    function translate(out, a, v) {
      var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }
      return out;
    }
  }
});

// node_modules/gl-mat4/create.js
var require_create2 = __commonJS({
  "node_modules/gl-mat4/create.js"(exports2, module2) {
    module2.exports = create;
    function create() {
      var out = new Float32Array(16);
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/gl-mat4/scale.js
var require_scale2 = __commonJS({
  "node_modules/gl-mat4/scale.js"(exports2, module2) {
    module2.exports = scale;
    function scale(out, a, v) {
      var x = v[0], y = v[1], z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
  }
});

// node_modules/gl-mat4/fromRotationTranslation.js
var require_fromRotationTranslation = __commonJS({
  "node_modules/gl-mat4/fromRotationTranslation.js"(exports2, module2) {
    module2.exports = fromRotationTranslation;
    function fromRotationTranslation(out, q, v) {
      var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
      out[0] = 1 - (yy + zz);
      out[1] = xy + wz;
      out[2] = xz - wy;
      out[3] = 0;
      out[4] = xy - wz;
      out[5] = 1 - (xx + zz);
      out[6] = yz + wx;
      out[7] = 0;
      out[8] = xz + wy;
      out[9] = yz - wx;
      out[10] = 1 - (xx + yy);
      out[11] = 0;
      out[12] = v[0];
      out[13] = v[1];
      out[14] = v[2];
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/mat4-recompose/index.js
var require_mat4_recompose = __commonJS({
  "node_modules/mat4-recompose/index.js"(exports2, module2) {
    var mat4 = {
      identity: require_identity(),
      translate: require_translate(),
      multiply: require_multiply2(),
      create: require_create2(),
      scale: require_scale2(),
      fromRotationTranslation: require_fromRotationTranslation()
    };
    var rotationMatrix = mat4.create();
    var temp = mat4.create();
    module2.exports = function recomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {
      mat4.identity(matrix);
      mat4.fromRotationTranslation(matrix, quaternion, translation);
      matrix[3] = perspective[0];
      matrix[7] = perspective[1];
      matrix[11] = perspective[2];
      matrix[15] = perspective[3];
      mat4.identity(temp);
      if (skew[2] !== 0) {
        temp[9] = skew[2];
        mat4.multiply(matrix, matrix, temp);
      }
      if (skew[1] !== 0) {
        temp[9] = 0;
        temp[8] = skew[1];
        mat4.multiply(matrix, matrix, temp);
      }
      if (skew[0] !== 0) {
        temp[8] = 0;
        temp[4] = skew[0];
        mat4.multiply(matrix, matrix, temp);
      }
      mat4.scale(matrix, matrix, scale);
      return matrix;
    };
  }
});

// node_modules/mat4-decompose/normalize.js
var require_normalize2 = __commonJS({
  "node_modules/mat4-decompose/normalize.js"(exports2, module2) {
    module2.exports = function normalize(out, mat) {
      var m44 = mat[15];
      if (m44 === 0)
        return false;
      var scale = 1 / m44;
      for (var i = 0; i < 16; i++)
        out[i] = mat[i] * scale;
      return true;
    };
  }
});

// node_modules/gl-mat4/clone.js
var require_clone2 = __commonJS({
  "node_modules/gl-mat4/clone.js"(exports2, module2) {
    module2.exports = clone;
    function clone(a) {
      var out = new Float32Array(16);
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
  }
});

// node_modules/gl-mat4/determinant.js
var require_determinant = __commonJS({
  "node_modules/gl-mat4/determinant.js"(exports2, module2) {
    module2.exports = determinant;
    function determinant(a) {
      var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    }
  }
});

// node_modules/gl-mat4/transpose.js
var require_transpose = __commonJS({
  "node_modules/gl-mat4/transpose.js"(exports2, module2) {
    module2.exports = transpose;
    function transpose(out, a) {
      if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
      } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
      }
      return out;
    }
  }
});

// node_modules/mat4-decompose/index.js
var require_mat4_decompose = __commonJS({
  "node_modules/mat4-decompose/index.js"(exports2, module2) {
    var normalize = require_normalize2();
    var create = require_create2();
    var clone = require_clone2();
    var determinant = require_determinant();
    var invert = require_invert();
    var transpose = require_transpose();
    var vec3 = {
      length: require_length(),
      normalize: require_normalize(),
      dot: require_dot(),
      cross: require_cross()
    };
    var tmp = create();
    var perspectiveMatrix = create();
    var tmpVec4 = [0, 0, 0, 0];
    var row = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    var pdum3 = [0, 0, 0];
    module2.exports = function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {
      if (!translation) translation = [0, 0, 0];
      if (!scale) scale = [0, 0, 0];
      if (!skew) skew = [0, 0, 0];
      if (!perspective) perspective = [0, 0, 0, 1];
      if (!quaternion) quaternion = [0, 0, 0, 1];
      if (!normalize(tmp, matrix))
        return false;
      clone(perspectiveMatrix, tmp);
      perspectiveMatrix[3] = 0;
      perspectiveMatrix[7] = 0;
      perspectiveMatrix[11] = 0;
      perspectiveMatrix[15] = 1;
      if (Math.abs(determinant(perspectiveMatrix) < 1e-8))
        return false;
      var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
      if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
        tmpVec4[0] = a03;
        tmpVec4[1] = a13;
        tmpVec4[2] = a23;
        tmpVec4[3] = a33;
        var ret = invert(perspectiveMatrix, perspectiveMatrix);
        if (!ret) return false;
        transpose(perspectiveMatrix, perspectiveMatrix);
        vec4multMat4(perspective, tmpVec4, perspectiveMatrix);
      } else {
        perspective[0] = perspective[1] = perspective[2] = 0;
        perspective[3] = 1;
      }
      translation[0] = a30;
      translation[1] = a31;
      translation[2] = a32;
      mat3from4(row, tmp);
      scale[0] = vec3.length(row[0]);
      vec3.normalize(row[0], row[0]);
      skew[0] = vec3.dot(row[0], row[1]);
      combine(row[1], row[1], row[0], 1, -skew[0]);
      scale[1] = vec3.length(row[1]);
      vec3.normalize(row[1], row[1]);
      skew[0] /= scale[1];
      skew[1] = vec3.dot(row[0], row[2]);
      combine(row[2], row[2], row[0], 1, -skew[1]);
      skew[2] = vec3.dot(row[1], row[2]);
      combine(row[2], row[2], row[1], 1, -skew[2]);
      scale[2] = vec3.length(row[2]);
      vec3.normalize(row[2], row[2]);
      skew[1] /= scale[2];
      skew[2] /= scale[2];
      vec3.cross(pdum3, row[1], row[2]);
      if (vec3.dot(row[0], pdum3) < 0) {
        for (var i = 0; i < 3; i++) {
          scale[i] *= -1;
          row[i][0] *= -1;
          row[i][1] *= -1;
          row[i][2] *= -1;
        }
      }
      quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
      quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
      quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
      quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
      if (row[2][1] > row[1][2])
        quaternion[0] = -quaternion[0];
      if (row[0][2] > row[2][0])
        quaternion[1] = -quaternion[1];
      if (row[1][0] > row[0][1])
        quaternion[2] = -quaternion[2];
      return true;
    };
    function vec4multMat4(out, a, m) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return out;
    }
    function mat3from4(out, mat4x4) {
      out[0][0] = mat4x4[0];
      out[0][1] = mat4x4[1];
      out[0][2] = mat4x4[2];
      out[1][0] = mat4x4[4];
      out[1][1] = mat4x4[5];
      out[1][2] = mat4x4[6];
      out[2][0] = mat4x4[8];
      out[2][1] = mat4x4[9];
      out[2][2] = mat4x4[10];
    }
    function combine(out, a, b, scale1, scale2) {
      out[0] = a[0] * scale1 + b[0] * scale2;
      out[1] = a[1] * scale1 + b[1] * scale2;
      out[2] = a[2] * scale1 + b[2] * scale2;
    }
  }
});

// node_modules/gl-quat/slerp.js
var require_slerp = __commonJS({
  "node_modules/gl-quat/slerp.js"(exports2, module2) {
    module2.exports = slerp;
    function slerp(out, a, b, t) {
      var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
      var omega, cosom, sinom, scale0, scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      if (1 - cosom > 1e-6) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        scale0 = 1 - t;
        scale1 = t;
      }
      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }
  }
});

// node_modules/quat-slerp/index.js
var require_quat_slerp = __commonJS({
  "node_modules/quat-slerp/index.js"(exports2, module2) {
    module2.exports = require_slerp();
  }
});

// node_modules/mat4-interpolate/index.js
var require_mat4_interpolate = __commonJS({
  "node_modules/mat4-interpolate/index.js"(exports2, module2) {
    var lerp = require_lerp();
    var recompose = require_mat4_recompose();
    var decompose = require_mat4_decompose();
    var determinant = require_determinant();
    var slerp = require_quat_slerp();
    var state0 = state();
    var state1 = state();
    var tmp = state();
    module2.exports = interpolate;
    function interpolate(out, start, end, alpha) {
      if (determinant(start) === 0 || determinant(end) === 0)
        return false;
      var r0 = decompose(start, state0.translate, state0.scale, state0.skew, state0.perspective, state0.quaternion);
      var r1 = decompose(end, state1.translate, state1.scale, state1.skew, state1.perspective, state1.quaternion);
      if (!r0 || !r1)
        return false;
      lerp(tmp.translate, state0.translate, state1.translate, alpha);
      lerp(tmp.skew, state0.skew, state1.skew, alpha);
      lerp(tmp.scale, state0.scale, state1.scale, alpha);
      lerp(tmp.perspective, state0.perspective, state1.perspective, alpha);
      slerp(tmp.quaternion, state0.quaternion, state1.quaternion, alpha);
      recompose(out, tmp.translate, tmp.scale, tmp.skew, tmp.perspective, tmp.quaternion);
      return true;
    }
    function state() {
      return {
        translate: vec3(),
        scale: vec3(1),
        skew: vec3(),
        perspective: vec4(),
        quaternion: vec4()
      };
    }
    function vec3(n) {
      return [n || 0, n || 0, n || 0];
    }
    function vec4() {
      return [0, 0, 0, 1];
    }
  }
});

// node_modules/gl-mat4/rotateX.js
var require_rotateX2 = __commonJS({
  "node_modules/gl-mat4/rotateX.js"(exports2, module2) {
    module2.exports = rotateX;
    function rotateX(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
      if (a !== out) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }
      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
    }
  }
});

// node_modules/gl-mat4/rotateY.js
var require_rotateY2 = __commonJS({
  "node_modules/gl-mat4/rotateY.js"(exports2, module2) {
    module2.exports = rotateY;
    function rotateY(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
      if (a !== out) {
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }
      out[0] = a00 * c - a20 * s;
      out[1] = a01 * c - a21 * s;
      out[2] = a02 * c - a22 * s;
      out[3] = a03 * c - a23 * s;
      out[8] = a00 * s + a20 * c;
      out[9] = a01 * s + a21 * c;
      out[10] = a02 * s + a22 * c;
      out[11] = a03 * s + a23 * c;
      return out;
    }
  }
});

// node_modules/gl-mat4/rotateZ.js
var require_rotateZ2 = __commonJS({
  "node_modules/gl-mat4/rotateZ.js"(exports2, module2) {
    module2.exports = rotateZ;
    function rotateZ(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
      if (a !== out) {
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }
      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
    }
  }
});

// node_modules/matrix-camera-controller/matrix.js
var require_matrix = __commonJS({
  "node_modules/matrix-camera-controller/matrix.js"(exports2, module2) {
    "use strict";
    var bsearch = require_search_bounds();
    var m4interp = require_mat4_interpolate();
    var invert44 = require_invert();
    var rotateX = require_rotateX2();
    var rotateY = require_rotateY2();
    var rotateZ = require_rotateZ2();
    var lookAt = require_lookAt();
    var translate = require_translate();
    var scale = require_scale2();
    var normalize = require_normalize();
    var DEFAULT_CENTER = [0, 0, 0];
    module2.exports = createMatrixCameraController;
    function MatrixCameraController(initialMatrix) {
      this._components = initialMatrix.slice();
      this._time = [0];
      this.prevMatrix = initialMatrix.slice();
      this.nextMatrix = initialMatrix.slice();
      this.computedMatrix = initialMatrix.slice();
      this.computedInverse = initialMatrix.slice();
      this.computedEye = [0, 0, 0];
      this.computedUp = [0, 0, 0];
      this.computedCenter = [0, 0, 0];
      this.computedRadius = [0];
      this._limits = [-Infinity, Infinity];
    }
    var proto = MatrixCameraController.prototype;
    proto.recalcMatrix = function(t) {
      var time = this._time;
      var tidx = bsearch.le(time, t);
      var mat = this.computedMatrix;
      if (tidx < 0) {
        return;
      }
      var comps = this._components;
      if (tidx === time.length - 1) {
        var ptr = 16 * tidx;
        for (var i = 0; i < 16; ++i) {
          mat[i] = comps[ptr++];
        }
      } else {
        var dt = time[tidx + 1] - time[tidx];
        var ptr = 16 * tidx;
        var prev = this.prevMatrix;
        var allEqual = true;
        for (var i = 0; i < 16; ++i) {
          prev[i] = comps[ptr++];
        }
        var next = this.nextMatrix;
        for (var i = 0; i < 16; ++i) {
          next[i] = comps[ptr++];
          allEqual = allEqual && prev[i] === next[i];
        }
        if (dt < 1e-6 || allEqual) {
          for (var i = 0; i < 16; ++i) {
            mat[i] = prev[i];
          }
        } else {
          m4interp(mat, prev, next, (t - time[tidx]) / dt);
        }
      }
      var up = this.computedUp;
      up[0] = mat[1];
      up[1] = mat[5];
      up[2] = mat[9];
      normalize(up, up);
      var imat = this.computedInverse;
      invert44(imat, mat);
      var eye = this.computedEye;
      var w = imat[15];
      eye[0] = imat[12] / w;
      eye[1] = imat[13] / w;
      eye[2] = imat[14] / w;
      var center = this.computedCenter;
      var radius = Math.exp(this.computedRadius[0]);
      for (var i = 0; i < 3; ++i) {
        center[i] = eye[i] - mat[2 + 4 * i] * radius;
      }
    };
    proto.idle = function(t) {
      if (t < this.lastT()) {
        return;
      }
      var mc = this._components;
      var ptr = mc.length - 16;
      for (var i = 0; i < 16; ++i) {
        mc.push(mc[ptr++]);
      }
      this._time.push(t);
    };
    proto.flush = function(t) {
      var idx = bsearch.gt(this._time, t) - 2;
      if (idx < 0) {
        return;
      }
      this._time.splice(0, idx);
      this._components.splice(0, 16 * idx);
    };
    proto.lastT = function() {
      return this._time[this._time.length - 1];
    };
    proto.lookAt = function(t, eye, center, up) {
      this.recalcMatrix(t);
      eye = eye || this.computedEye;
      center = center || DEFAULT_CENTER;
      up = up || this.computedUp;
      this.setMatrix(t, lookAt(this.computedMatrix, eye, center, up));
      var d2 = 0;
      for (var i = 0; i < 3; ++i) {
        d2 += Math.pow(center[i] - eye[i], 2);
      }
      d2 = Math.log(Math.sqrt(d2));
      this.computedRadius[0] = d2;
    };
    proto.rotate = function(t, yaw, pitch, roll) {
      this.recalcMatrix(t);
      var mat = this.computedInverse;
      if (yaw) rotateY(mat, mat, yaw);
      if (pitch) rotateX(mat, mat, pitch);
      if (roll) rotateZ(mat, mat, roll);
      this.setMatrix(t, invert44(this.computedMatrix, mat));
    };
    var tvec = [0, 0, 0];
    proto.pan = function(t, dx, dy, dz) {
      tvec[0] = -(dx || 0);
      tvec[1] = -(dy || 0);
      tvec[2] = -(dz || 0);
      this.recalcMatrix(t);
      var mat = this.computedInverse;
      translate(mat, mat, tvec);
      this.setMatrix(t, invert44(mat, mat));
    };
    proto.translate = function(t, dx, dy, dz) {
      tvec[0] = dx || 0;
      tvec[1] = dy || 0;
      tvec[2] = dz || 0;
      this.recalcMatrix(t);
      var mat = this.computedMatrix;
      translate(mat, mat, tvec);
      this.setMatrix(t, mat);
    };
    proto.setMatrix = function(t, mat) {
      if (t < this.lastT()) {
        return;
      }
      this._time.push(t);
      for (var i = 0; i < 16; ++i) {
        this._components.push(mat[i]);
      }
    };
    proto.setDistance = function(t, d) {
      this.computedRadius[0] = d;
    };
    proto.setDistanceLimits = function(a, b) {
      var lim = this._limits;
      lim[0] = a;
      lim[1] = b;
    };
    proto.getDistanceLimits = function(out) {
      var lim = this._limits;
      if (out) {
        out[0] = lim[0];
        out[1] = lim[1];
        return out;
      }
      return lim;
    };
    function createMatrixCameraController(options) {
      options = options || {};
      var matrix = options.matrix || [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      return new MatrixCameraController(matrix);
    }
  }
});

// node_modules/3d-view/view.js
var require_view = __commonJS({
  "node_modules/3d-view/view.js"(exports2, module2) {
    "use strict";
    module2.exports = createViewController;
    var createTurntable = require_turntable();
    var createOrbit = require_orbit();
    var createMatrix = require_matrix();
    function ViewController(controllers, mode) {
      this._controllerNames = Object.keys(controllers);
      this._controllerList = this._controllerNames.map(function(n) {
        return controllers[n];
      });
      this._mode = mode;
      this._active = controllers[mode];
      if (!this._active) {
        this._mode = "turntable";
        this._active = controllers.turntable;
      }
      this.modes = this._controllerNames;
      this.computedMatrix = this._active.computedMatrix;
      this.computedEye = this._active.computedEye;
      this.computedUp = this._active.computedUp;
      this.computedCenter = this._active.computedCenter;
      this.computedRadius = this._active.computedRadius;
    }
    var proto = ViewController.prototype;
    proto.flush = function(a0) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].flush(a0);
      }
    };
    proto.idle = function(a0) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].idle(a0);
      }
    };
    proto.lookAt = function(a0, a1, a2, a3) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].lookAt(a0, a1, a2, a3);
      }
    };
    proto.rotate = function(a0, a1, a2, a3) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].rotate(a0, a1, a2, a3);
      }
    };
    proto.pan = function(a0, a1, a2, a3) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].pan(a0, a1, a2, a3);
      }
    };
    proto.translate = function(a0, a1, a2, a3) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].translate(a0, a1, a2, a3);
      }
    };
    proto.setMatrix = function(a0, a1) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].setMatrix(a0, a1);
      }
    };
    proto.setDistanceLimits = function(a0, a1) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].setDistanceLimits(a0, a1);
      }
    };
    proto.setDistance = function(a0, a1) {
      var cc = this._controllerList;
      for (var i = 0; i < cc.length; ++i) {
        cc[i].setDistance(a0, a1);
      }
    };
    proto.recalcMatrix = function(t) {
      this._active.recalcMatrix(t);
    };
    proto.getDistance = function(t) {
      return this._active.getDistance(t);
    };
    proto.getDistanceLimits = function(out) {
      return this._active.getDistanceLimits(out);
    };
    proto.lastT = function() {
      return this._active.lastT();
    };
    proto.setMode = function(mode) {
      if (mode === this._mode) {
        return;
      }
      var idx = this._controllerNames.indexOf(mode);
      if (idx < 0) {
        return;
      }
      var prev = this._active;
      var next = this._controllerList[idx];
      var lastT = Math.max(prev.lastT(), next.lastT());
      prev.recalcMatrix(lastT);
      next.setMatrix(lastT, prev.computedMatrix);
      this._active = next;
      this._mode = mode;
      this.computedMatrix = this._active.computedMatrix;
      this.computedEye = this._active.computedEye;
      this.computedUp = this._active.computedUp;
      this.computedCenter = this._active.computedCenter;
      this.computedRadius = this._active.computedRadius;
    };
    proto.getMode = function() {
      return this._mode;
    };
    function createViewController(options) {
      options = options || {};
      var eye = options.eye || [0, 0, 1];
      var center = options.center || [0, 0, 0];
      var up = options.up || [0, 1, 0];
      var limits = options.distanceLimits || [0, Infinity];
      var mode = options.mode || "turntable";
      var turntable = createTurntable();
      var orbit = createOrbit();
      var matrix = createMatrix();
      turntable.setDistanceLimits(limits[0], limits[1]);
      turntable.lookAt(0, eye, center, up);
      orbit.setDistanceLimits(limits[0], limits[1]);
      orbit.lookAt(0, eye, center, up);
      matrix.setDistanceLimits(limits[0], limits[1]);
      matrix.lookAt(0, eye, center, up);
      return new ViewController({
        turntable,
        orbit,
        matrix
      }, mode);
    }
  }
});

// node_modules/mouse-event/mouse.js
var require_mouse = __commonJS({
  "node_modules/mouse-event/mouse.js"(exports2) {
    "use strict";
    function mouseButtons(ev) {
      if (typeof ev === "object") {
        if ("buttons" in ev) {
          return ev.buttons;
        } else if ("which" in ev) {
          var b = ev.which;
          if (b === 2) {
            return 4;
          } else if (b === 3) {
            return 2;
          } else if (b > 0) {
            return 1 << b - 1;
          }
        } else if ("button" in ev) {
          var b = ev.button;
          if (b === 1) {
            return 4;
          } else if (b === 2) {
            return 2;
          } else if (b >= 0) {
            return 1 << b;
          }
        }
      }
      return 0;
    }
    exports2.buttons = mouseButtons;
    function mouseElement(ev) {
      return ev.target || ev.srcElement || window;
    }
    exports2.element = mouseElement;
    function mouseRelativeX(ev) {
      if (typeof ev === "object") {
        if ("offsetX" in ev) {
          return ev.offsetX;
        }
        var target = mouseElement(ev);
        var bounds = target.getBoundingClientRect();
        return ev.clientX - bounds.left;
      }
      return 0;
    }
    exports2.x = mouseRelativeX;
    function mouseRelativeY(ev) {
      if (typeof ev === "object") {
        if ("offsetY" in ev) {
          return ev.offsetY;
        }
        var target = mouseElement(ev);
        var bounds = target.getBoundingClientRect();
        return ev.clientY - bounds.top;
      }
      return 0;
    }
    exports2.y = mouseRelativeY;
  }
});

// node_modules/mouse-change/mouse-listen.js
var require_mouse_listen = __commonJS({
  "node_modules/mouse-change/mouse-listen.js"(exports2, module2) {
    "use strict";
    module2.exports = mouseListen;
    var mouse = require_mouse();
    function mouseListen(element, callback) {
      if (!callback) {
        callback = element;
        element = window;
      }
      var buttonState = 0;
      var x = 0;
      var y = 0;
      var mods = {
        shift: false,
        alt: false,
        control: false,
        meta: false
      };
      var attached = false;
      function updateMods(ev) {
        var changed = false;
        if ("altKey" in ev) {
          changed = changed || ev.altKey !== mods.alt;
          mods.alt = !!ev.altKey;
        }
        if ("shiftKey" in ev) {
          changed = changed || ev.shiftKey !== mods.shift;
          mods.shift = !!ev.shiftKey;
        }
        if ("ctrlKey" in ev) {
          changed = changed || ev.ctrlKey !== mods.control;
          mods.control = !!ev.ctrlKey;
        }
        if ("metaKey" in ev) {
          changed = changed || ev.metaKey !== mods.meta;
          mods.meta = !!ev.metaKey;
        }
        return changed;
      }
      function handleEvent(nextButtons, ev) {
        var nextX = mouse.x(ev);
        var nextY = mouse.y(ev);
        if ("buttons" in ev) {
          nextButtons = ev.buttons | 0;
        }
        if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
          buttonState = nextButtons | 0;
          x = nextX || 0;
          y = nextY || 0;
          callback && callback(buttonState, x, y, mods);
        }
      }
      function clearState(ev) {
        handleEvent(0, ev);
      }
      function handleBlur() {
        if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
          x = y = 0;
          buttonState = 0;
          mods.shift = mods.alt = mods.control = mods.meta = false;
          callback && callback(0, 0, 0, mods);
        }
      }
      function handleMods(ev) {
        if (updateMods(ev)) {
          callback && callback(buttonState, x, y, mods);
        }
      }
      function handleMouseMove(ev) {
        if (mouse.buttons(ev) === 0) {
          handleEvent(0, ev);
        } else {
          handleEvent(buttonState, ev);
        }
      }
      function handleMouseDown(ev) {
        handleEvent(buttonState | mouse.buttons(ev), ev);
      }
      function handleMouseUp(ev) {
        handleEvent(buttonState & ~mouse.buttons(ev), ev);
      }
      function attachListeners() {
        if (attached) {
          return;
        }
        attached = true;
        element.addEventListener("mousemove", handleMouseMove);
        element.addEventListener("mousedown", handleMouseDown);
        element.addEventListener("mouseup", handleMouseUp);
        element.addEventListener("mouseleave", clearState);
        element.addEventListener("mouseenter", clearState);
        element.addEventListener("mouseout", clearState);
        element.addEventListener("mouseover", clearState);
        element.addEventListener("blur", handleBlur);
        element.addEventListener("keyup", handleMods);
        element.addEventListener("keydown", handleMods);
        element.addEventListener("keypress", handleMods);
        if (element !== window) {
          window.addEventListener("blur", handleBlur);
          window.addEventListener("keyup", handleMods);
          window.addEventListener("keydown", handleMods);
          window.addEventListener("keypress", handleMods);
        }
      }
      function detachListeners() {
        if (!attached) {
          return;
        }
        attached = false;
        element.removeEventListener("mousemove", handleMouseMove);
        element.removeEventListener("mousedown", handleMouseDown);
        element.removeEventListener("mouseup", handleMouseUp);
        element.removeEventListener("mouseleave", clearState);
        element.removeEventListener("mouseenter", clearState);
        element.removeEventListener("mouseout", clearState);
        element.removeEventListener("mouseover", clearState);
        element.removeEventListener("blur", handleBlur);
        element.removeEventListener("keyup", handleMods);
        element.removeEventListener("keydown", handleMods);
        element.removeEventListener("keypress", handleMods);
        if (element !== window) {
          window.removeEventListener("blur", handleBlur);
          window.removeEventListener("keyup", handleMods);
          window.removeEventListener("keydown", handleMods);
          window.removeEventListener("keypress", handleMods);
        }
      }
      attachListeners();
      var result = {
        element
      };
      Object.defineProperties(result, {
        enabled: {
          get: function() {
            return attached;
          },
          set: function(f) {
            if (f) {
              attachListeners();
            } else {
              detachListeners();
            }
          },
          enumerable: true
        },
        buttons: {
          get: function() {
            return buttonState;
          },
          enumerable: true
        },
        x: {
          get: function() {
            return x;
          },
          enumerable: true
        },
        y: {
          get: function() {
            return y;
          },
          enumerable: true
        },
        mods: {
          get: function() {
            return mods;
          },
          enumerable: true
        }
      });
      return result;
    }
  }
});

// node_modules/parse-unit/index.js
var require_parse_unit = __commonJS({
  "node_modules/parse-unit/index.js"(exports2, module2) {
    module2.exports = function parseUnit(str, out) {
      if (!out)
        out = [0, ""];
      str = String(str);
      var num = parseFloat(str, 10);
      out[0] = num;
      out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || "";
      return out;
    };
  }
});

// node_modules/to-px/topx.js
var require_topx = __commonJS({
  "node_modules/to-px/topx.js"(exports2, module2) {
    "use strict";
    var parseUnit = require_parse_unit();
    module2.exports = toPX;
    var PIXELS_PER_INCH = 96;
    function getPropertyInPX(element, prop) {
      var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop));
      return parts[0] * toPX(parts[1], element);
    }
    function getSizeBrutal(unit, element) {
      var testDIV = document.createElement("div");
      testDIV.style["font-size"] = "128" + unit;
      element.appendChild(testDIV);
      var size = getPropertyInPX(testDIV, "font-size") / 128;
      element.removeChild(testDIV);
      return size;
    }
    function toPX(str, element) {
      element = element || document.body;
      str = (str || "px").trim().toLowerCase();
      if (element === window || element === document) {
        element = document.body;
      }
      switch (str) {
        case "%":
          return element.clientHeight / 100;
        case "ch":
        case "ex":
          return getSizeBrutal(str, element);
        case "em":
          return getPropertyInPX(element, "font-size");
        case "rem":
          return getPropertyInPX(document.body, "font-size");
        case "vw":
          return window.innerWidth / 100;
        case "vh":
          return window.innerHeight / 100;
        case "vmin":
          return Math.min(window.innerWidth, window.innerHeight) / 100;
        case "vmax":
          return Math.max(window.innerWidth, window.innerHeight) / 100;
        case "in":
          return PIXELS_PER_INCH;
        case "cm":
          return PIXELS_PER_INCH / 2.54;
        case "mm":
          return PIXELS_PER_INCH / 25.4;
        case "pt":
          return PIXELS_PER_INCH / 72;
        case "pc":
          return PIXELS_PER_INCH / 6;
      }
      return 1;
    }
  }
});

// node_modules/mouse-wheel/wheel.js
var require_wheel = __commonJS({
  "node_modules/mouse-wheel/wheel.js"(exports2, module2) {
    "use strict";
    var toPX = require_topx();
    module2.exports = mouseWheelListen;
    function mouseWheelListen(element, callback, noScroll) {
      if (typeof element === "function") {
        noScroll = !!callback;
        callback = element;
        element = window;
      }
      var lineHeight = toPX("ex", element);
      var listener = function(ev) {
        if (noScroll) {
          ev.preventDefault();
        }
        var dx = ev.deltaX || 0;
        var dy = ev.deltaY || 0;
        var dz = ev.deltaZ || 0;
        var mode = ev.deltaMode;
        var scale = 1;
        switch (mode) {
          case 1:
            scale = lineHeight;
            break;
          case 2:
            scale = window.innerHeight;
            break;
        }
        dx *= scale;
        dy *= scale;
        dz *= scale;
        if (dx || dy || dz) {
          return callback(dx, dy, dz, ev);
        }
      };
      element.addEventListener("wheel", listener);
      return listener;
    }
  }
});

// node_modules/mouse-event-offset/index.js
var require_mouse_event_offset = __commonJS({
  "node_modules/mouse-event-offset/index.js"(exports2, module2) {
    var rootPosition = { left: 0, top: 0 };
    module2.exports = mouseEventOffset;
    function mouseEventOffset(ev, target, out) {
      target = target || ev.currentTarget || ev.srcElement;
      if (!Array.isArray(out)) {
        out = [0, 0];
      }
      var cx = ev.clientX || 0;
      var cy = ev.clientY || 0;
      var rect = getBoundingClientOffset(target);
      out[0] = cx - rect.left;
      out[1] = cy - rect.top;
      return out;
    }
    function getBoundingClientOffset(element) {
      if (element === window || element === document || element === document.body) {
        return rootPosition;
      } else {
        return element.getBoundingClientRect();
      }
    }
  }
});

// node_modules/is-browser/client.js
var require_client = __commonJS({
  "node_modules/is-browser/client.js"(exports2, module2) {
    module2.exports = true;
  }
});

// node_modules/has-passive-events/index.js
var require_has_passive_events = __commonJS({
  "node_modules/has-passive-events/index.js"(exports2, module2) {
    "use strict";
    var isBrowser = require_client();
    function detect() {
      var supported = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function() {
            supported = true;
          }
        });
        window.addEventListener("test", null, opts);
        window.removeEventListener("test", null, opts);
      } catch (e) {
        supported = false;
      }
      return supported;
    }
    module2.exports = isBrowser && detect();
  }
});

// node_modules/gl-plot3d/camera.js
var require_camera = __commonJS({
  "node_modules/gl-plot3d/camera.js"(exports2, module2) {
    "use strict";
    module2.exports = createCamera;
    var now = require_browser2();
    var createView = require_view();
    var mouseChange = require_mouse_listen();
    var mouseWheel = require_wheel();
    var mouseOffset = require_mouse_event_offset();
    var hasPassive = require_has_passive_events();
    function createCamera(element, options) {
      element = element || document.body;
      options = options || {};
      var limits = [0.01, Infinity];
      if ("distanceLimits" in options) {
        limits[0] = options.distanceLimits[0];
        limits[1] = options.distanceLimits[1];
      }
      if ("zoomMin" in options) {
        limits[0] = options.zoomMin;
      }
      if ("zoomMax" in options) {
        limits[1] = options.zoomMax;
      }
      var view = createView({
        center: options.center || [0, 0, 0],
        up: options.up || [0, 1, 0],
        eye: options.eye || [0, 0, 10],
        mode: options.mode || "orbit",
        distanceLimits: limits
      });
      var pmatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var distance = 0;
      var width = element.clientWidth;
      var height = element.clientHeight;
      var camera = {
        keyBindingMode: "rotate",
        enableWheel: true,
        view,
        element,
        delay: options.delay || 16,
        rotateSpeed: options.rotateSpeed || 1,
        zoomSpeed: options.zoomSpeed || 1,
        translateSpeed: options.translateSpeed || 1,
        flipX: !!options.flipX,
        flipY: !!options.flipY,
        modes: view.modes,
        _ortho: options._ortho || options.projection && options.projection.type === "orthographic" || false,
        tick: function() {
          var t = now();
          var delay = this.delay;
          var ctime = t - 2 * delay;
          view.idle(t - delay);
          view.recalcMatrix(ctime);
          view.flush(t - (100 + delay * 2));
          var allEqual = true;
          var matrix = view.computedMatrix;
          for (var i = 0; i < 16; ++i) {
            allEqual = allEqual && pmatrix[i] === matrix[i];
            pmatrix[i] = matrix[i];
          }
          var sizeChanged = element.clientWidth === width && element.clientHeight === height;
          width = element.clientWidth;
          height = element.clientHeight;
          if (allEqual) {
            return !sizeChanged;
          }
          distance = Math.exp(view.computedRadius[0]);
          return true;
        },
        lookAt: function(eye, center, up) {
          view.lookAt(view.lastT(), eye, center, up);
        },
        rotate: function(pitch, yaw, roll) {
          view.rotate(view.lastT(), pitch, yaw, roll);
        },
        pan: function(dx, dy, dz) {
          view.pan(view.lastT(), dx, dy, dz);
        },
        translate: function(dx, dy, dz) {
          view.translate(view.lastT(), dx, dy, dz);
        }
      };
      Object.defineProperties(camera, {
        matrix: {
          get: function() {
            return view.computedMatrix;
          },
          set: function(mat) {
            view.setMatrix(view.lastT(), mat);
            return view.computedMatrix;
          },
          enumerable: true
        },
        mode: {
          get: function() {
            return view.getMode();
          },
          set: function(mode) {
            var curUp = view.computedUp.slice();
            var curEye = view.computedEye.slice();
            var curCenter = view.computedCenter.slice();
            view.setMode(mode);
            if (mode === "turntable") {
              var t0 = now();
              view._active.lookAt(t0, curEye, curCenter, curUp);
              view._active.lookAt(t0 + 500, curEye, curCenter, [0, 0, 1]);
              view._active.flush(t0);
            }
            return view.getMode();
          },
          enumerable: true
        },
        center: {
          get: function() {
            return view.computedCenter;
          },
          set: function(ncenter) {
            view.lookAt(view.lastT(), null, ncenter);
            return view.computedCenter;
          },
          enumerable: true
        },
        eye: {
          get: function() {
            return view.computedEye;
          },
          set: function(neye) {
            view.lookAt(view.lastT(), neye);
            return view.computedEye;
          },
          enumerable: true
        },
        up: {
          get: function() {
            return view.computedUp;
          },
          set: function(nup) {
            view.lookAt(view.lastT(), null, null, nup);
            return view.computedUp;
          },
          enumerable: true
        },
        distance: {
          get: function() {
            return distance;
          },
          set: function(d) {
            view.setDistance(view.lastT(), d);
            return d;
          },
          enumerable: true
        },
        distanceLimits: {
          get: function() {
            return view.getDistanceLimits(limits);
          },
          set: function(v) {
            view.setDistanceLimits(v);
            return v;
          },
          enumerable: true
        }
      });
      element.addEventListener("contextmenu", function(ev) {
        ev.preventDefault();
        return false;
      });
      camera._lastX = -1;
      camera._lastY = -1;
      camera._lastMods = { shift: false, control: false, alt: false, meta: false };
      camera.enableMouseListeners = function() {
        camera.mouseListener = mouseChange(element, handleInteraction);
        element.addEventListener("touchstart", function(ev) {
          var xy = mouseOffset(ev.changedTouches[0], element);
          handleInteraction(0, xy[0], xy[1], camera._lastMods);
          handleInteraction(1, xy[0], xy[1], camera._lastMods);
        }, hasPassive ? { passive: true } : false);
        element.addEventListener("touchmove", function(ev) {
          var xy = mouseOffset(ev.changedTouches[0], element);
          handleInteraction(1, xy[0], xy[1], camera._lastMods);
          ev.preventDefault();
        }, hasPassive ? { passive: false } : false);
        element.addEventListener("touchend", function(ev) {
          handleInteraction(0, camera._lastX, camera._lastY, camera._lastMods);
        }, hasPassive ? { passive: true } : false);
        function handleInteraction(buttons, x, y, mods) {
          var keyBindingMode = camera.keyBindingMode;
          if (keyBindingMode === false) return;
          var rotate = keyBindingMode === "rotate";
          var pan = keyBindingMode === "pan";
          var zoom = keyBindingMode === "zoom";
          var ctrl = !!mods.control;
          var alt = !!mods.alt;
          var shift = !!mods.shift;
          var left = !!(buttons & 1);
          var right = !!(buttons & 2);
          var middle = !!(buttons & 4);
          var scale = 1 / element.clientHeight;
          var dx = scale * (x - camera._lastX);
          var dy = scale * (y - camera._lastY);
          var flipX = camera.flipX ? 1 : -1;
          var flipY = camera.flipY ? 1 : -1;
          var drot = Math.PI * camera.rotateSpeed;
          var t = now();
          if (camera._lastX !== -1 && camera._lastY !== -1) {
            if (rotate && left && !ctrl && !alt && !shift || left && !ctrl && !alt && shift) {
              view.rotate(t, flipX * drot * dx, -flipY * drot * dy, 0);
            }
            if (pan && left && !ctrl && !alt && !shift || right || left && ctrl && !alt && !shift) {
              view.pan(t, -camera.translateSpeed * dx * distance, camera.translateSpeed * dy * distance, 0);
            }
            if (zoom && left && !ctrl && !alt && !shift || middle || left && !ctrl && alt && !shift) {
              var kzoom = -camera.zoomSpeed * dy / window.innerHeight * (t - view.lastT()) * 100;
              view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));
            }
          }
          camera._lastX = x;
          camera._lastY = y;
          camera._lastMods = mods;
          return true;
        }
        camera.wheelListener = mouseWheel(element, function(dx, dy) {
          if (camera.keyBindingMode === false) return;
          if (!camera.enableWheel) return;
          var flipX = camera.flipX ? 1 : -1;
          var flipY = camera.flipY ? 1 : -1;
          var t = now();
          if (Math.abs(dx) > Math.abs(dy)) {
            view.rotate(t, 0, 0, -dx * flipX * Math.PI * camera.rotateSpeed / window.innerWidth);
          } else {
            if (!camera._ortho) {
              var kzoom = -camera.zoomSpeed * flipY * dy / window.innerHeight * (t - view.lastT()) / 20;
              view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));
            }
          }
        }, true);
      };
      camera.enableMouseListeners();
      return camera;
    }
  }
});

// node_modules/gl-axes3d/lib/shaders/index.js
var require_shaders7 = __commonJS({
  "node_modules/gl-axes3d/lib/shaders/index.js"(exports2) {
    "use strict";
    var glslify = require_browser();
    var createShader = require_gl_shader();
    var lineVert = glslify("./lineVert.glsl");
    var lineFrag = glslify("./lineFrag.glsl");
    exports2.line = function(gl2) {
      return createShader(gl2, lineVert, lineFrag, null, [
        { name: "position", type: "vec3" }
      ]);
    };
    var textVert = glslify("./textVert.glsl");
    var textFrag = glslify("./textFrag.glsl");
    exports2.text = function(gl2) {
      return createShader(gl2, textVert, textFrag, null, [
        { name: "position", type: "vec3" }
      ]);
    };
    var bgVert = glslify("./backgroundVert.glsl");
    var bgFrag = glslify("./backgroundFrag.glsl");
    exports2.bg = function(gl2) {
      return createShader(gl2, bgVert, bgFrag, null, [
        { name: "position", type: "vec3" },
        { name: "normal", type: "vec3" }
      ]);
    };
  }
});

// node_modules/gl-axes3d/lib/text.js
var require_text2 = __commonJS({
  "node_modules/gl-axes3d/lib/text.js"(exports2, module2) {
    "use strict";
    module2.exports = createTextSprites;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var vectorizeText = require_vectorize_text();
    var createShader = require_shaders7().text;
    var globals = window || process.global || {};
    var __TEXT_CACHE = globals.__TEXT_CACHE || {};
    globals.__TEXT_CACHE = {};
    var VERTEX_SIZE = 3;
    function TextSprites(gl2, shader, buffer, vao) {
      this.gl = gl2;
      this.shader = shader;
      this.buffer = buffer;
      this.vao = vao;
      this.tickOffset = this.tickCount = this.labelOffset = this.labelCount = null;
    }
    var proto = TextSprites.prototype;
    var SHAPE = [0, 0];
    proto.bind = function(model, view, projection, pixelScale) {
      this.vao.bind();
      this.shader.bind();
      var uniforms = this.shader.uniforms;
      uniforms.model = model;
      uniforms.view = view;
      uniforms.projection = projection;
      uniforms.pixelScale = pixelScale;
      SHAPE[0] = this.gl.drawingBufferWidth;
      SHAPE[1] = this.gl.drawingBufferHeight;
      this.shader.uniforms.resolution = SHAPE;
    };
    proto.unbind = function() {
      this.vao.unbind();
    };
    proto.update = function(bounds, labels, labelFont, ticks, tickFont) {
      var data = [];
      function addItem(t, text, font2, size, lineSpacing2, styletags2) {
        var fontKey = [
          font2.style,
          font2.weight,
          font2.variant,
          font2.family
        ].join("_");
        var fontcache = __TEXT_CACHE[fontKey];
        if (!fontcache) {
          fontcache = __TEXT_CACHE[fontKey] = {};
        }
        var mesh = fontcache[text];
        if (!mesh) {
          mesh = fontcache[text] = tryVectorizeText(text, {
            triangles: true,
            font: font2.family,
            fontStyle: font2.style,
            fontWeight: font2.weight,
            fontVariant: font2.variant,
            textAlign: "center",
            textBaseline: "middle",
            lineSpacing: lineSpacing2,
            styletags: styletags2
          });
        }
        var scale = (size || 12) / 12;
        var positions = mesh.positions;
        var cells = mesh.cells;
        for (var i2 = 0, nc = cells.length; i2 < nc; ++i2) {
          var c = cells[i2];
          for (var j = 2; j >= 0; --j) {
            var p = positions[c[j]];
            data.push(scale * p[0], -scale * p[1], t);
          }
        }
      }
      var tickOffset = [0, 0, 0];
      var tickCount = [0, 0, 0];
      var labelOffset = [0, 0, 0];
      var labelCount = [0, 0, 0];
      var lineSpacing = 1.25;
      var styletags = {
        breaklines: true,
        bolds: true,
        italics: true,
        subscripts: true,
        superscripts: true
      };
      for (var d = 0; d < 3; ++d) {
        labelOffset[d] = data.length / VERTEX_SIZE | 0;
        addItem(
          0.5 * (bounds[0][d] + bounds[1][d]),
          labels[d],
          labelFont[d],
          12,
          // labelFontSize
          lineSpacing,
          styletags
        );
        labelCount[d] = (data.length / VERTEX_SIZE | 0) - labelOffset[d];
        tickOffset[d] = data.length / VERTEX_SIZE | 0;
        for (var i = 0; i < ticks[d].length; ++i) {
          if (!ticks[d][i].text) {
            continue;
          }
          var font = {
            family: ticks[d][i].font || tickFont[d].family,
            style: tickFont[d].fontStyle || tickFont[d].style,
            weight: tickFont[d].fontWeight || tickFont[d].weight,
            variant: tickFont[d].fontVariant || tickFont[d].variant
          };
          addItem(
            ticks[d][i].x,
            ticks[d][i].text,
            font,
            ticks[d][i].fontSize || 12,
            lineSpacing,
            styletags
          );
        }
        tickCount[d] = (data.length / VERTEX_SIZE | 0) - tickOffset[d];
      }
      this.buffer.update(data);
      this.tickOffset = tickOffset;
      this.tickCount = tickCount;
      this.labelOffset = labelOffset;
      this.labelCount = labelCount;
    };
    proto.drawTicks = function(d, scale, angle, offset, color, axis, alignDir, alignOpt) {
      if (!this.tickCount[d]) {
        return;
      }
      this.shader.uniforms.axis = axis;
      this.shader.uniforms.color = color;
      this.shader.uniforms.angle = angle;
      this.shader.uniforms.scale = scale;
      this.shader.uniforms.offset = offset;
      this.shader.uniforms.alignDir = alignDir;
      this.shader.uniforms.alignOpt = alignOpt;
      this.vao.draw(this.gl.TRIANGLES, this.tickCount[d], this.tickOffset[d]);
    };
    proto.drawLabel = function(d, scale, angle, offset, color, axis, alignDir, alignOpt) {
      if (!this.labelCount[d]) {
        return;
      }
      this.shader.uniforms.axis = axis;
      this.shader.uniforms.color = color;
      this.shader.uniforms.angle = angle;
      this.shader.uniforms.scale = scale;
      this.shader.uniforms.offset = offset;
      this.shader.uniforms.alignDir = alignDir;
      this.shader.uniforms.alignOpt = alignOpt;
      this.vao.draw(this.gl.TRIANGLES, this.labelCount[d], this.labelOffset[d]);
    };
    proto.dispose = function() {
      this.shader.dispose();
      this.vao.dispose();
      this.buffer.dispose();
    };
    function tryVectorizeText(text, options) {
      try {
        return vectorizeText(text, options);
      } catch (e) {
        console.warn('error vectorizing text:"' + text + '" error:', e);
        return {
          cells: [],
          positions: []
        };
      }
    }
    function createTextSprites(gl2, bounds, labels, labelFont, ticks, tickFont) {
      var buffer = createBuffer(gl2);
      var vao = createVAO(gl2, [
        {
          "buffer": buffer,
          "size": 3
        }
      ]);
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      var result = new TextSprites(
        gl2,
        shader,
        buffer,
        vao
      );
      result.update(bounds, labels, labelFont, ticks, tickFont);
      return result;
    }
  }
});

// node_modules/gl-axes3d/lib/lines.js
var require_lines2 = __commonJS({
  "node_modules/gl-axes3d/lib/lines.js"(exports2, module2) {
    "use strict";
    module2.exports = createLines;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createShader = require_shaders7().line;
    var MAJOR_AXIS = [0, 0, 0];
    var MINOR_AXIS = [0, 0, 0];
    var SCREEN_AXIS = [0, 0, 0];
    var OFFSET_VEC = [0, 0, 0];
    var SHAPE = [1, 1];
    function zeroVec(a) {
      a[0] = a[1] = a[2] = 0;
      return a;
    }
    function copyVec(a, b) {
      a[0] = b[0];
      a[1] = b[1];
      a[2] = b[2];
      return a;
    }
    function Lines(gl2, vertBuffer, vao, shader, tickCount, tickOffset, gridCount, gridOffset) {
      this.gl = gl2;
      this.vertBuffer = vertBuffer;
      this.vao = vao;
      this.shader = shader;
      this.tickCount = tickCount;
      this.tickOffset = tickOffset;
      this.gridCount = gridCount;
      this.gridOffset = gridOffset;
    }
    var proto = Lines.prototype;
    proto.bind = function(model, view, projection) {
      this.shader.bind();
      this.shader.uniforms.model = model;
      this.shader.uniforms.view = view;
      this.shader.uniforms.projection = projection;
      SHAPE[0] = this.gl.drawingBufferWidth;
      SHAPE[1] = this.gl.drawingBufferHeight;
      this.shader.uniforms.screenShape = SHAPE;
      this.vao.bind();
    };
    proto.unbind = function() {
      this.vao.unbind();
    };
    proto.drawAxisLine = function(j, bounds, offset, color, lineWidth) {
      var minorAxis = zeroVec(MINOR_AXIS);
      this.shader.uniforms.majorAxis = MINOR_AXIS;
      minorAxis[j] = bounds[1][j] - bounds[0][j];
      this.shader.uniforms.minorAxis = minorAxis;
      var noffset = copyVec(OFFSET_VEC, offset);
      noffset[j] += bounds[0][j];
      this.shader.uniforms.offset = noffset;
      this.shader.uniforms.lineWidth = lineWidth;
      this.shader.uniforms.color = color;
      var screenAxis = zeroVec(SCREEN_AXIS);
      screenAxis[(j + 2) % 3] = 1;
      this.shader.uniforms.screenAxis = screenAxis;
      this.vao.draw(this.gl.TRIANGLES, 6);
      var screenAxis = zeroVec(SCREEN_AXIS);
      screenAxis[(j + 1) % 3] = 1;
      this.shader.uniforms.screenAxis = screenAxis;
      this.vao.draw(this.gl.TRIANGLES, 6);
    };
    proto.drawAxisTicks = function(j, offset, minorAxis, color, lineWidth) {
      if (!this.tickCount[j]) {
        return;
      }
      var majorAxis = zeroVec(MAJOR_AXIS);
      majorAxis[j] = 1;
      this.shader.uniforms.majorAxis = majorAxis;
      this.shader.uniforms.offset = offset;
      this.shader.uniforms.minorAxis = minorAxis;
      this.shader.uniforms.color = color;
      this.shader.uniforms.lineWidth = lineWidth;
      var screenAxis = zeroVec(SCREEN_AXIS);
      screenAxis[j] = 1;
      this.shader.uniforms.screenAxis = screenAxis;
      this.vao.draw(this.gl.TRIANGLES, this.tickCount[j], this.tickOffset[j]);
    };
    proto.drawGrid = function(i, j, bounds, offset, color, lineWidth) {
      if (!this.gridCount[i]) {
        return;
      }
      var minorAxis = zeroVec(MINOR_AXIS);
      minorAxis[j] = bounds[1][j] - bounds[0][j];
      this.shader.uniforms.minorAxis = minorAxis;
      var noffset = copyVec(OFFSET_VEC, offset);
      noffset[j] += bounds[0][j];
      this.shader.uniforms.offset = noffset;
      var majorAxis = zeroVec(MAJOR_AXIS);
      majorAxis[i] = 1;
      this.shader.uniforms.majorAxis = majorAxis;
      var screenAxis = zeroVec(SCREEN_AXIS);
      screenAxis[i] = 1;
      this.shader.uniforms.screenAxis = screenAxis;
      this.shader.uniforms.lineWidth = lineWidth;
      this.shader.uniforms.color = color;
      this.vao.draw(this.gl.TRIANGLES, this.gridCount[i], this.gridOffset[i]);
    };
    proto.drawZero = function(j, i, bounds, offset, color, lineWidth) {
      var minorAxis = zeroVec(MINOR_AXIS);
      this.shader.uniforms.majorAxis = minorAxis;
      minorAxis[j] = bounds[1][j] - bounds[0][j];
      this.shader.uniforms.minorAxis = minorAxis;
      var noffset = copyVec(OFFSET_VEC, offset);
      noffset[j] += bounds[0][j];
      this.shader.uniforms.offset = noffset;
      var screenAxis = zeroVec(SCREEN_AXIS);
      screenAxis[i] = 1;
      this.shader.uniforms.screenAxis = screenAxis;
      this.shader.uniforms.lineWidth = lineWidth;
      this.shader.uniforms.color = color;
      this.vao.draw(this.gl.TRIANGLES, 6);
    };
    proto.dispose = function() {
      this.vao.dispose();
      this.vertBuffer.dispose();
      this.shader.dispose();
    };
    function createLines(gl2, bounds, ticks) {
      var vertices = [];
      var tickOffset = [0, 0, 0];
      var tickCount = [0, 0, 0];
      var gridOffset = [0, 0, 0];
      var gridCount = [0, 0, 0];
      vertices.push(
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        1,
        1,
        0,
        1,
        -1
      );
      for (var i = 0; i < 3; ++i) {
        var start = vertices.length / 3 | 0;
        for (var j = 0; j < ticks[i].length; ++j) {
          var x = +ticks[i][j].x;
          vertices.push(
            x,
            0,
            1,
            x,
            1,
            1,
            x,
            0,
            -1,
            x,
            0,
            -1,
            x,
            1,
            1,
            x,
            1,
            -1
          );
        }
        var end = vertices.length / 3 | 0;
        tickOffset[i] = start;
        tickCount[i] = end - start;
        var start = vertices.length / 3 | 0;
        for (var k = 0; k < ticks[i].length; ++k) {
          var x = +ticks[i][k].x;
          vertices.push(
            x,
            0,
            1,
            x,
            1,
            1,
            x,
            0,
            -1,
            x,
            0,
            -1,
            x,
            1,
            1,
            x,
            1,
            -1
          );
        }
        var end = vertices.length / 3 | 0;
        gridOffset[i] = start;
        gridCount[i] = end - start;
      }
      var vertBuf = createBuffer(gl2, new Float32Array(vertices));
      var vao = createVAO(gl2, [
        {
          "buffer": vertBuf,
          "type": gl2.FLOAT,
          "size": 3,
          "stride": 0,
          "offset": 0
        }
      ]);
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      return new Lines(gl2, vertBuf, vao, shader, tickCount, tickOffset, gridCount, gridOffset);
    }
  }
});

// node_modules/gl-axes3d/lib/background.js
var require_background = __commonJS({
  "node_modules/gl-axes3d/lib/background.js"(exports2, module2) {
    "use strict";
    module2.exports = createBackgroundCube;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createShader = require_shaders7().bg;
    function BackgroundCube(gl2, buffer, vao, shader) {
      this.gl = gl2;
      this.buffer = buffer;
      this.vao = vao;
      this.shader = shader;
    }
    var proto = BackgroundCube.prototype;
    proto.draw = function(model, view, projection, bounds, enable, colors) {
      var needsBG = false;
      for (var i = 0; i < 3; ++i) {
        needsBG = needsBG || enable[i];
      }
      if (!needsBG) {
        return;
      }
      var gl2 = this.gl;
      gl2.enable(gl2.POLYGON_OFFSET_FILL);
      gl2.polygonOffset(1, 2);
      this.shader.bind();
      this.shader.uniforms = {
        model,
        view,
        projection,
        bounds,
        enable,
        colors
      };
      this.vao.bind();
      this.vao.draw(this.gl.TRIANGLES, 36);
      this.vao.unbind();
      gl2.disable(gl2.POLYGON_OFFSET_FILL);
    };
    proto.dispose = function() {
      this.vao.dispose();
      this.buffer.dispose();
      this.shader.dispose();
    };
    function createBackgroundCube(gl2) {
      var vertices = [];
      var indices = [];
      var ptr = 0;
      for (var d = 0; d < 3; ++d) {
        var u = (d + 1) % 3;
        var v = (d + 2) % 3;
        var x = [0, 0, 0];
        var c = [0, 0, 0];
        for (var s = -1; s <= 1; s += 2) {
          indices.push(
            ptr,
            ptr + 2,
            ptr + 1,
            ptr + 1,
            ptr + 2,
            ptr + 3
          );
          x[d] = s;
          c[d] = s;
          for (var i = -1; i <= 1; i += 2) {
            x[u] = i;
            for (var j = -1; j <= 1; j += 2) {
              x[v] = j;
              vertices.push(
                x[0],
                x[1],
                x[2],
                c[0],
                c[1],
                c[2]
              );
              ptr += 1;
            }
          }
          var tt = u;
          u = v;
          v = tt;
        }
      }
      var buffer = createBuffer(gl2, new Float32Array(vertices));
      var elements = createBuffer(gl2, new Uint16Array(indices), gl2.ELEMENT_ARRAY_BUFFER);
      var vao = createVAO(gl2, [
        {
          buffer,
          type: gl2.FLOAT,
          size: 3,
          offset: 0,
          stride: 24
        },
        {
          buffer,
          type: gl2.FLOAT,
          size: 3,
          offset: 12,
          stride: 24
        }
      ], elements);
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      shader.attributes.normal.location = 1;
      return new BackgroundCube(gl2, buffer, vao, shader);
    }
  }
});

// node_modules/robust-dot-product/dot-prod.js
var require_dot_prod = __commonJS({
  "node_modules/robust-dot-product/dot-prod.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    module2.exports = robustDotProduct;
    function robustDotProduct(a, b) {
      var r = twoProduct(a[0], b[0]);
      for (var i = 1; i < a.length; ++i) {
        r = robustSum(r, twoProduct(a[i], b[i]));
      }
      return r;
    }
  }
});

// node_modules/split-polygon/clip-poly.js
var require_clip_poly = __commonJS({
  "node_modules/split-polygon/clip-poly.js"(exports2, module2) {
    "use strict";
    var robustDot = require_dot_prod();
    var robustSum = require_robust_sum();
    module2.exports = splitPolygon;
    module2.exports.positive = positive;
    module2.exports.negative = negative;
    function planeT(p, plane) {
      var r = robustSum(robustDot(p, plane), [plane[plane.length - 1]]);
      return r[r.length - 1];
    }
    function lerpW(a, wa, b, wb) {
      var d = wb - wa;
      var t = -wa / d;
      if (t < 0) {
        t = 0;
      } else if (t > 1) {
        t = 1;
      }
      var ti = 1 - t;
      var n = a.length;
      var r = new Array(n);
      for (var i = 0; i < n; ++i) {
        r[i] = t * a[i] + ti * b[i];
      }
      return r;
    }
    function splitPolygon(points, plane) {
      var pos = [];
      var neg = [];
      var a = planeT(points[points.length - 1], plane);
      for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {
        t = points[i];
        var b = planeT(t, plane);
        if (a < 0 && b > 0 || a > 0 && b < 0) {
          var p = lerpW(s, b, t, a);
          pos.push(p);
          neg.push(p.slice());
        }
        if (b < 0) {
          neg.push(t.slice());
        } else if (b > 0) {
          pos.push(t.slice());
        } else {
          pos.push(t.slice());
          neg.push(t.slice());
        }
        a = b;
      }
      return { positive: pos, negative: neg };
    }
    function positive(points, plane) {
      var pos = [];
      var a = planeT(points[points.length - 1], plane);
      for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {
        t = points[i];
        var b = planeT(t, plane);
        if (a < 0 && b > 0 || a > 0 && b < 0) {
          pos.push(lerpW(s, b, t, a));
        }
        if (b >= 0) {
          pos.push(t.slice());
        }
        a = b;
      }
      return pos;
    }
    function negative(points, plane) {
      var neg = [];
      var a = planeT(points[points.length - 1], plane);
      for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {
        t = points[i];
        var b = planeT(t, plane);
        if (a < 0 && b > 0 || a > 0 && b < 0) {
          neg.push(lerpW(s, b, t, a));
        }
        if (b <= 0) {
          neg.push(t.slice());
        }
        a = b;
      }
      return neg;
    }
  }
});

// node_modules/gl-axes3d/lib/cube.js
var require_cube = __commonJS({
  "node_modules/gl-axes3d/lib/cube.js"(exports2, module2) {
    "use strict";
    module2.exports = getCubeEdges;
    var bits = require_twiddle();
    var multiply = require_multiply2();
    var splitPoly = require_clip_poly();
    var orient = require_orientation();
    var mvp = new Array(16);
    var pCubeVerts = new Array(8);
    var cubeVerts = new Array(8);
    var x = new Array(3);
    var zero3 = [0, 0, 0];
    (function() {
      for (var i = 0; i < 8; ++i) {
        pCubeVerts[i] = [1, 1, 1, 1];
        cubeVerts[i] = [1, 1, 1];
      }
    })();
    function transformHg(result, x2, mat) {
      for (var i = 0; i < 4; ++i) {
        result[i] = mat[12 + i];
        for (var j = 0; j < 3; ++j) {
          result[i] += x2[j] * mat[4 * j + i];
        }
      }
    }
    var FRUSTUM_PLANES = [
      [0, 0, 1, 0, 0],
      [0, 0, -1, 1, 0],
      [0, -1, 0, 1, 0],
      [0, 1, 0, 1, 0],
      [-1, 0, 0, 1, 0],
      [1, 0, 0, 1, 0]
    ];
    function polygonArea(p) {
      for (var i = 0; i < FRUSTUM_PLANES.length; ++i) {
        p = splitPoly.positive(p, FRUSTUM_PLANES[i]);
        if (p.length < 3) {
          return 0;
        }
      }
      var base = p[0];
      var ax = base[0] / base[3];
      var ay = base[1] / base[3];
      var area = 0;
      for (var i = 1; i + 1 < p.length; ++i) {
        var b = p[i];
        var c = p[i + 1];
        var bx = b[0] / b[3];
        var by = b[1] / b[3];
        var cx = c[0] / c[3];
        var cy = c[1] / c[3];
        var ux = bx - ax;
        var uy = by - ay;
        var vx = cx - ax;
        var vy = cy - ay;
        area += Math.abs(ux * vy - uy * vx);
      }
      return area;
    }
    var CUBE_EDGES = [1, 1, 1];
    var CUBE_AXIS = [0, 0, 0];
    var CUBE_RESULT = {
      cubeEdges: CUBE_EDGES,
      axis: CUBE_AXIS
    };
    function getCubeEdges(model, view, projection, bounds, ortho) {
      multiply(mvp, view, model);
      multiply(mvp, projection, mvp);
      var ptr = 0;
      for (var i = 0; i < 2; ++i) {
        x[2] = bounds[i][2];
        for (var j = 0; j < 2; ++j) {
          x[1] = bounds[j][1];
          for (var k = 0; k < 2; ++k) {
            x[0] = bounds[k][0];
            transformHg(pCubeVerts[ptr], x, mvp);
            ptr += 1;
          }
        }
      }
      var closest = -1;
      for (var i = 0; i < 8; ++i) {
        var w = pCubeVerts[i][3];
        for (var l = 0; l < 3; ++l) {
          cubeVerts[i][l] = pCubeVerts[i][l] / w;
        }
        if (ortho) cubeVerts[i][2] *= -1;
        if (w < 0) {
          if (closest < 0) {
            closest = i;
          } else if (cubeVerts[i][2] < cubeVerts[closest][2]) {
            closest = i;
          }
        }
      }
      if (closest < 0) {
        closest = 0;
        for (var d = 0; d < 3; ++d) {
          var u = (d + 2) % 3;
          var v = (d + 1) % 3;
          var o0 = -1;
          var o1 = -1;
          for (var s = 0; s < 2; ++s) {
            var f0 = s << d;
            var f1 = f0 + (s << u) + (1 - s << v);
            var f2 = f0 + (1 - s << u) + (s << v);
            if (orient(cubeVerts[f0], cubeVerts[f1], cubeVerts[f2], zero3) < 0) {
              continue;
            }
            if (s) {
              o0 = 1;
            } else {
              o1 = 1;
            }
          }
          if (o0 < 0 || o1 < 0) {
            if (o1 > o0) {
              closest |= 1 << d;
            }
            continue;
          }
          for (var s = 0; s < 2; ++s) {
            var f0 = s << d;
            var f1 = f0 + (s << u) + (1 - s << v);
            var f2 = f0 + (1 - s << u) + (s << v);
            var o = polygonArea([
              pCubeVerts[f0],
              pCubeVerts[f1],
              pCubeVerts[f2],
              pCubeVerts[f0 + (1 << u) + (1 << v)]
            ]);
            if (s) {
              o0 = o;
            } else {
              o1 = o;
            }
          }
          if (o1 > o0) {
            closest |= 1 << d;
            continue;
          }
        }
      }
      var farthest = 7 ^ closest;
      var bottom = -1;
      for (var i = 0; i < 8; ++i) {
        if (i === closest || i === farthest) {
          continue;
        }
        if (bottom < 0) {
          bottom = i;
        } else if (cubeVerts[bottom][1] > cubeVerts[i][1]) {
          bottom = i;
        }
      }
      var left = -1;
      for (var i = 0; i < 3; ++i) {
        var idx = bottom ^ 1 << i;
        if (idx === closest || idx === farthest) {
          continue;
        }
        if (left < 0) {
          left = idx;
        }
        var v = cubeVerts[idx];
        if (v[0] < cubeVerts[left][0]) {
          left = idx;
        }
      }
      var right = -1;
      for (var i = 0; i < 3; ++i) {
        var idx = bottom ^ 1 << i;
        if (idx === closest || idx === farthest || idx === left) {
          continue;
        }
        if (right < 0) {
          right = idx;
        }
        var v = cubeVerts[idx];
        if (v[0] > cubeVerts[right][0]) {
          right = idx;
        }
      }
      var cubeEdges = CUBE_EDGES;
      cubeEdges[0] = cubeEdges[1] = cubeEdges[2] = 0;
      cubeEdges[bits.log2(left ^ bottom)] = bottom & left;
      cubeEdges[bits.log2(bottom ^ right)] = bottom & right;
      var top = right ^ 7;
      if (top === closest || top === farthest) {
        top = left ^ 7;
        cubeEdges[bits.log2(right ^ top)] = top & right;
      } else {
        cubeEdges[bits.log2(left ^ top)] = top & left;
      }
      var axis = CUBE_AXIS;
      var cutCorner = closest;
      for (var d = 0; d < 3; ++d) {
        if (cutCorner & 1 << d) {
          axis[d] = -1;
        } else {
          axis[d] = 1;
        }
      }
      return CUBE_RESULT;
    }
  }
});

// node_modules/gl-axes3d/lib/ticks.js
var require_ticks = __commonJS({
  "node_modules/gl-axes3d/lib/ticks.js"(exports2) {
    "use strict";
    exports2.create = defaultTicks;
    exports2.equal = ticksEqual;
    function prettyPrint(spacing, i) {
      var stepStr = spacing + "";
      var u = stepStr.indexOf(".");
      var sigFigs = 0;
      if (u >= 0) {
        sigFigs = stepStr.length - u - 1;
      }
      var shift = Math.pow(10, sigFigs);
      var x = Math.round(spacing * i * shift);
      var xstr = x + "";
      if (xstr.indexOf("e") >= 0) {
        return xstr;
      }
      var xi = x / shift, xf = x % shift;
      if (x < 0) {
        xi = -Math.ceil(xi) | 0;
        xf = -xf | 0;
      } else {
        xi = Math.floor(xi) | 0;
        xf = xf | 0;
      }
      var xis = "" + xi;
      if (x < 0) {
        xis = "-" + xis;
      }
      if (sigFigs) {
        var xs = "" + xf;
        while (xs.length < sigFigs) {
          xs = "0" + xs;
        }
        return xis + "." + xs;
      } else {
        return xis;
      }
    }
    function defaultTicks(bounds, tickSpacing) {
      var array = [];
      for (var d = 0; d < 3; ++d) {
        var ticks = [];
        var m = 0.5 * (bounds[0][d] + bounds[1][d]);
        for (var t = 0; t * tickSpacing[d] <= bounds[1][d]; ++t) {
          ticks.push({ x: t * tickSpacing[d], text: prettyPrint(tickSpacing[d], t) });
        }
        for (var t = -1; t * tickSpacing[d] >= bounds[0][d]; --t) {
          ticks.push({ x: t * tickSpacing[d], text: prettyPrint(tickSpacing[d], t) });
        }
        array.push(ticks);
      }
      return array;
    }
    function ticksEqual(ticksA, ticksB) {
      for (var i = 0; i < 3; ++i) {
        if (ticksA[i].length !== ticksB[i].length) {
          return false;
        }
        for (var j = 0; j < ticksA[i].length; ++j) {
          var a = ticksA[i][j];
          var b = ticksB[i][j];
          if (a.x !== b.x || a.text !== b.text || a.font !== b.font || a.fontColor !== b.fontColor || a.fontSize !== b.fontSize || a.dx !== b.dx || a.dy !== b.dy) {
            return false;
          }
        }
      }
      return true;
    }
  }
});

// node_modules/gl-axes3d/axes.js
var require_axes = __commonJS({
  "node_modules/gl-axes3d/axes.js"(exports2, module2) {
    "use strict";
    module2.exports = createAxes;
    var createText = require_text2();
    var createLines = require_lines2();
    var createBackground = require_background();
    var getCubeProperties = require_cube();
    var Ticks = require_ticks();
    var identity = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    var ab = ArrayBuffer;
    var dv = DataView;
    function isTypedArray(a) {
      return ab.isView(a) && !(a instanceof dv);
    }
    function isArrayOrTypedArray(a) {
      return Array.isArray(a) || isTypedArray(a);
    }
    function copyVec3(a, b) {
      a[0] = b[0];
      a[1] = b[1];
      a[2] = b[2];
      return a;
    }
    function Axes(gl2) {
      this.gl = gl2;
      this.pixelRatio = 1;
      this.bounds = [
        [-10, -10, -10],
        [10, 10, 10]
      ];
      this.ticks = [[], [], []];
      this.autoTicks = true;
      this.tickSpacing = [1, 1, 1];
      this.tickEnable = [true, true, true];
      this.tickFont = ["sans-serif", "sans-serif", "sans-serif"];
      this.tickFontStyle = ["normal", "normal", "normal"];
      this.tickFontWeight = ["normal", "normal", "normal"];
      this.tickFontVariant = ["normal", "normal", "normal"];
      this.tickSize = [12, 12, 12];
      this.tickAngle = [0, 0, 0];
      this.tickAlign = ["auto", "auto", "auto"];
      this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.tickPad = [10, 10, 10];
      this.lastCubeProps = {
        cubeEdges: [0, 0, 0],
        axis: [0, 0, 0]
      };
      this.labels = ["x", "y", "z"];
      this.labelEnable = [true, true, true];
      this.labelFont = ["sans-serif", "sans-serif", "sans-serif"];
      this.labelFontStyle = ["normal", "normal", "normal"];
      this.labelFontWeight = ["normal", "normal", "normal"];
      this.labelFontVariant = ["normal", "normal", "normal"];
      this.labelSize = [20, 20, 20];
      this.labelAngle = [0, 0, 0];
      this.labelAlign = ["auto", "auto", "auto"];
      this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.labelPad = [10, 10, 10];
      this.lineEnable = [true, true, true];
      this.lineMirror = [false, false, false];
      this.lineWidth = [1, 1, 1];
      this.lineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.lineTickEnable = [true, true, true];
      this.lineTickMirror = [false, false, false];
      this.lineTickLength = [0, 0, 0];
      this.lineTickWidth = [1, 1, 1];
      this.lineTickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.gridEnable = [true, true, true];
      this.gridWidth = [1, 1, 1];
      this.gridColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.zeroEnable = [true, true, true];
      this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.zeroLineWidth = [2, 2, 2];
      this.backgroundEnable = [false, false, false];
      this.backgroundColor = [
        [0.8, 0.8, 0.8, 0.5],
        [0.8, 0.8, 0.8, 0.5],
        [0.8, 0.8, 0.8, 0.5]
      ];
      this._firstInit = true;
      this._text = null;
      this._lines = null;
      this._background = createBackground(gl2);
    }
    var proto = Axes.prototype;
    proto.update = function(options) {
      options = options || {};
      function parseOption(nest, cons, name2) {
        if (name2 in options) {
          var opt = options[name2];
          var prev = this[name2];
          var next;
          if (nest ? isArrayOrTypedArray(opt) && isArrayOrTypedArray(opt[0]) : isArrayOrTypedArray(opt)) {
            this[name2] = next = [cons(opt[0]), cons(opt[1]), cons(opt[2])];
          } else {
            this[name2] = next = [cons(opt), cons(opt), cons(opt)];
          }
          for (var i2 = 0; i2 < 3; ++i2) {
            if (next[i2] !== prev[i2]) {
              return true;
            }
          }
        }
        return false;
      }
      var NUMBER = parseOption.bind(this, false, Number);
      var BOOLEAN = parseOption.bind(this, false, Boolean);
      var STRING = parseOption.bind(this, false, String);
      var COLOR = parseOption.bind(this, true, function(v) {
        if (isArrayOrTypedArray(v)) {
          if (v.length === 3) {
            return [+v[0], +v[1], +v[2], 1];
          } else if (v.length === 4) {
            return [+v[0], +v[1], +v[2], +v[3]];
          }
        }
        return [0, 0, 0, 1];
      });
      var nextTicks;
      var ticksUpdate = false;
      var boundsChanged = false;
      if ("bounds" in options) {
        var bounds = options.bounds;
        i_loop:
          for (var i = 0; i < 2; ++i) {
            for (var j = 0; j < 3; ++j) {
              if (bounds[i][j] !== this.bounds[i][j]) {
                boundsChanged = true;
              }
              this.bounds[i][j] = bounds[i][j];
            }
          }
      }
      if ("ticks" in options) {
        nextTicks = options.ticks;
        ticksUpdate = true;
        this.autoTicks = false;
        for (var i = 0; i < 3; ++i) {
          this.tickSpacing[i] = 0;
        }
      } else if (NUMBER("tickSpacing")) {
        this.autoTicks = true;
        boundsChanged = true;
      }
      if (this._firstInit) {
        if (!("ticks" in options || "tickSpacing" in options)) {
          this.autoTicks = true;
        }
        boundsChanged = true;
        ticksUpdate = true;
        this._firstInit = false;
      }
      if (boundsChanged && this.autoTicks) {
        nextTicks = Ticks.create(this.bounds, this.tickSpacing);
        ticksUpdate = true;
      }
      if (ticksUpdate) {
        for (var i = 0; i < 3; ++i) {
          nextTicks[i].sort(function(a, b) {
            return a.x - b.x;
          });
        }
        if (Ticks.equal(nextTicks, this.ticks)) {
          ticksUpdate = false;
        } else {
          this.ticks = nextTicks;
        }
      }
      BOOLEAN("tickEnable");
      if (STRING("tickFont")) ticksUpdate = true;
      if (STRING("tickFontStyle")) ticksUpdate = true;
      if (STRING("tickFontWeight")) ticksUpdate = true;
      if (STRING("tickFontVariant")) ticksUpdate = true;
      NUMBER("tickSize");
      NUMBER("tickAngle");
      NUMBER("tickPad");
      COLOR("tickColor");
      var labelUpdate = STRING("labels");
      if (STRING("labelFont")) labelUpdate = true;
      if (STRING("labelFontStyle")) labelUpdate = true;
      if (STRING("labelFontWeight")) labelUpdate = true;
      if (STRING("labelFontVariant")) labelUpdate = true;
      BOOLEAN("labelEnable");
      NUMBER("labelSize");
      NUMBER("labelPad");
      COLOR("labelColor");
      BOOLEAN("lineEnable");
      BOOLEAN("lineMirror");
      NUMBER("lineWidth");
      COLOR("lineColor");
      BOOLEAN("lineTickEnable");
      BOOLEAN("lineTickMirror");
      NUMBER("lineTickLength");
      NUMBER("lineTickWidth");
      COLOR("lineTickColor");
      BOOLEAN("gridEnable");
      NUMBER("gridWidth");
      COLOR("gridColor");
      BOOLEAN("zeroEnable");
      COLOR("zeroLineColor");
      NUMBER("zeroLineWidth");
      BOOLEAN("backgroundEnable");
      COLOR("backgroundColor");
      var labelFontOpts = [
        {
          family: this.labelFont[0],
          style: this.labelFontStyle[0],
          weight: this.labelFontWeight[0],
          variant: this.labelFontVariant[0]
        },
        {
          family: this.labelFont[1],
          style: this.labelFontStyle[1],
          weight: this.labelFontWeight[1],
          variant: this.labelFontVariant[1]
        },
        {
          family: this.labelFont[2],
          style: this.labelFontStyle[2],
          weight: this.labelFontWeight[2],
          variant: this.labelFontVariant[2]
        }
      ];
      var tickFontOpts = [
        {
          family: this.tickFont[0],
          style: this.tickFontStyle[0],
          weight: this.tickFontWeight[0],
          variant: this.tickFontVariant[0]
        },
        {
          family: this.tickFont[1],
          style: this.tickFontStyle[1],
          weight: this.tickFontWeight[1],
          variant: this.tickFontVariant[1]
        },
        {
          family: this.tickFont[2],
          style: this.tickFontStyle[2],
          weight: this.tickFontWeight[2],
          variant: this.tickFontVariant[2]
        }
      ];
      if (!this._text) {
        this._text = createText(
          this.gl,
          this.bounds,
          this.labels,
          labelFontOpts,
          this.ticks,
          tickFontOpts
        );
      } else if (this._text && (labelUpdate || ticksUpdate)) {
        this._text.update(
          this.bounds,
          this.labels,
          labelFontOpts,
          this.ticks,
          tickFontOpts
        );
      }
      if (this._lines && ticksUpdate) {
        this._lines.dispose();
        this._lines = null;
      }
      if (!this._lines) {
        this._lines = createLines(this.gl, this.bounds, this.ticks);
      }
    };
    function OffsetInfo() {
      this.primalOffset = [0, 0, 0];
      this.primalMinor = [0, 0, 0];
      this.mirrorOffset = [0, 0, 0];
      this.mirrorMinor = [0, 0, 0];
    }
    var LINE_OFFSET = [new OffsetInfo(), new OffsetInfo(), new OffsetInfo()];
    function computeLineOffset(result, i, bounds, cubeEdges, cubeAxis) {
      var primalOffset = result.primalOffset;
      var primalMinor = result.primalMinor;
      var dualOffset = result.mirrorOffset;
      var dualMinor = result.mirrorMinor;
      var e = cubeEdges[i];
      for (var j = 0; j < 3; ++j) {
        if (i === j) {
          continue;
        }
        var a = primalOffset, b = dualOffset, c = primalMinor, d = dualMinor;
        if (e & 1 << j) {
          a = dualOffset;
          b = primalOffset;
          c = dualMinor;
          d = primalMinor;
        }
        a[j] = bounds[0][j];
        b[j] = bounds[1][j];
        if (cubeAxis[j] > 0) {
          c[j] = -1;
          d[j] = 0;
        } else {
          c[j] = 0;
          d[j] = 1;
        }
      }
    }
    var CUBE_ENABLE = [0, 0, 0];
    var DEFAULT_PARAMS = {
      model: identity,
      view: identity,
      projection: identity,
      _ortho: false
    };
    proto.isOpaque = function() {
      return true;
    };
    proto.isTransparent = function() {
      return false;
    };
    proto.drawTransparent = function(params) {
    };
    var ALIGN_OPTION_AUTO = 0;
    var PRIMAL_MINOR = [0, 0, 0];
    var MIRROR_MINOR = [0, 0, 0];
    var PRIMAL_OFFSET = [0, 0, 0];
    proto.draw = function(params) {
      params = params || DEFAULT_PARAMS;
      var gl2 = this.gl;
      var model = params.model || identity;
      var view = params.view || identity;
      var projection = params.projection || identity;
      var bounds = this.bounds;
      var isOrtho = params._ortho || false;
      var cubeParams = getCubeProperties(model, view, projection, bounds, isOrtho);
      var cubeEdges = cubeParams.cubeEdges;
      var cubeAxis = cubeParams.axis;
      var cx = view[12];
      var cy = view[13];
      var cz = view[14];
      var cw = view[15];
      var orthoFix = isOrtho ? 2 : 1;
      var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl2.drawingBufferHeight;
      for (var i = 0; i < 3; ++i) {
        this.lastCubeProps.cubeEdges[i] = cubeEdges[i];
        this.lastCubeProps.axis[i] = cubeAxis[i];
      }
      var lineOffset = LINE_OFFSET;
      for (var i = 0; i < 3; ++i) {
        computeLineOffset(
          LINE_OFFSET[i],
          i,
          this.bounds,
          cubeEdges,
          cubeAxis
        );
      }
      var gl2 = this.gl;
      var cubeEnable = CUBE_ENABLE;
      for (var i = 0; i < 3; ++i) {
        if (this.backgroundEnable[i]) {
          cubeEnable[i] = cubeAxis[i];
        } else {
          cubeEnable[i] = 0;
        }
      }
      this._background.draw(
        model,
        view,
        projection,
        bounds,
        cubeEnable,
        this.backgroundColor
      );
      this._lines.bind(
        model,
        view,
        projection,
        this
      );
      for (var i = 0; i < 3; ++i) {
        var x = [0, 0, 0];
        if (cubeAxis[i] > 0) {
          x[i] = bounds[1][i];
        } else {
          x[i] = bounds[0][i];
        }
        for (var j = 0; j < 2; ++j) {
          var u = (i + 1 + j) % 3;
          var v = (i + 1 + (j ^ 1)) % 3;
          if (this.gridEnable[u]) {
            this._lines.drawGrid(u, v, this.bounds, x, this.gridColor[u], this.gridWidth[u] * this.pixelRatio);
          }
        }
        for (var j = 0; j < 2; ++j) {
          var u = (i + 1 + j) % 3;
          var v = (i + 1 + (j ^ 1)) % 3;
          if (this.zeroEnable[v]) {
            if (Math.min(bounds[0][v], bounds[1][v]) <= 0 && Math.max(bounds[0][v], bounds[1][v]) >= 0) {
              this._lines.drawZero(u, v, this.bounds, x, this.zeroLineColor[v], this.zeroLineWidth[v] * this.pixelRatio);
            }
          }
        }
      }
      for (var i = 0; i < 3; ++i) {
        if (this.lineEnable[i]) {
          this._lines.drawAxisLine(i, this.bounds, lineOffset[i].primalOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);
        }
        if (this.lineMirror[i]) {
          this._lines.drawAxisLine(i, this.bounds, lineOffset[i].mirrorOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);
        }
        var primalMinor = copyVec3(PRIMAL_MINOR, lineOffset[i].primalMinor);
        var mirrorMinor = copyVec3(MIRROR_MINOR, lineOffset[i].mirrorMinor);
        var tickLength = this.lineTickLength;
        for (var j = 0; j < 3; ++j) {
          var scaleFactor = pixelScaleF / model[5 * j];
          primalMinor[j] *= tickLength[j] * scaleFactor;
          mirrorMinor[j] *= tickLength[j] * scaleFactor;
        }
        if (this.lineTickEnable[i]) {
          this._lines.drawAxisTicks(i, lineOffset[i].primalOffset, primalMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);
        }
        if (this.lineTickMirror[i]) {
          this._lines.drawAxisTicks(i, lineOffset[i].mirrorOffset, mirrorMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);
        }
      }
      this._lines.unbind();
      this._text.bind(
        model,
        view,
        projection,
        this.pixelRatio
      );
      var alignOpt;
      var hv_ratio = 0.5;
      var enableAlign;
      var alignDir;
      function alignTo(i2) {
        alignDir = [0, 0, 0];
        alignDir[i2] = 1;
      }
      function solveTickAlignments(i2, minor2, major2) {
        var i1 = (i2 + 1) % 3;
        var i22 = (i2 + 2) % 3;
        var A = minor2[i1];
        var B = minor2[i22];
        var C = major2[i1];
        var D = major2[i22];
        if (A > 0 && D > 0) {
          alignTo(i1);
          return;
        } else if (A > 0 && D < 0) {
          alignTo(i1);
          return;
        } else if (A < 0 && D > 0) {
          alignTo(i1);
          return;
        } else if (A < 0 && D < 0) {
          alignTo(i1);
          return;
        } else if (B > 0 && C > 0) {
          alignTo(i22);
          return;
        } else if (B > 0 && C < 0) {
          alignTo(i22);
          return;
        } else if (B < 0 && C > 0) {
          alignTo(i22);
          return;
        } else if (B < 0 && C < 0) {
          alignTo(i22);
          return;
        }
      }
      for (var i = 0; i < 3; ++i) {
        var minor = lineOffset[i].primalMinor;
        var major = lineOffset[i].mirrorMinor;
        var offset = copyVec3(PRIMAL_OFFSET, lineOffset[i].primalOffset);
        for (var j = 0; j < 3; ++j) {
          if (this.lineTickEnable[i]) {
            offset[j] += pixelScaleF * minor[j] * Math.max(this.lineTickLength[j], 0) / model[5 * j];
          }
        }
        var axis = [0, 0, 0];
        axis[i] = 1;
        if (this.tickEnable[i]) {
          if (this.tickAngle[i] === -3600) {
            this.tickAngle[i] = 0;
            this.tickAlign[i] = "auto";
          } else {
            this.tickAlign[i] = -1;
          }
          enableAlign = 1;
          alignOpt = [this.tickAlign[i], hv_ratio, enableAlign];
          if (alignOpt[0] === "auto") alignOpt[0] = ALIGN_OPTION_AUTO;
          else alignOpt[0] = parseInt("" + alignOpt[0]);
          alignDir = [0, 0, 0];
          solveTickAlignments(i, minor, major);
          for (var j = 0; j < 3; ++j) {
            offset[j] += pixelScaleF * minor[j] * this.tickPad[j] / model[5 * j];
          }
          this._text.drawTicks(
            i,
            this.tickSize[i],
            this.tickAngle[i],
            offset,
            this.tickColor[i],
            axis,
            alignDir,
            alignOpt
          );
        }
        if (this.labelEnable[i]) {
          enableAlign = 0;
          alignDir = [0, 0, 0];
          if (this.labels[i].length > 4) {
            alignTo(i);
            enableAlign = 1;
          }
          alignOpt = [this.labelAlign[i], hv_ratio, enableAlign];
          if (alignOpt[0] === "auto") alignOpt[0] = ALIGN_OPTION_AUTO;
          else alignOpt[0] = parseInt("" + alignOpt[0]);
          for (var j = 0; j < 3; ++j) {
            offset[j] += pixelScaleF * minor[j] * this.labelPad[j] / model[5 * j];
          }
          offset[i] += 0.5 * (bounds[0][i] + bounds[1][i]);
          this._text.drawLabel(
            i,
            this.labelSize[i],
            this.labelAngle[i],
            offset,
            this.labelColor[i],
            [0, 0, 0],
            alignDir,
            alignOpt
          );
        }
      }
      this._text.unbind();
    };
    proto.dispose = function() {
      this._text.dispose();
      this._lines.dispose();
      this._background.dispose();
      this._lines = null;
      this._text = null;
      this._background = null;
      this.gl = null;
    };
    function createAxes(gl2, options) {
      var axes = new Axes(gl2);
      axes.update(options);
      return axes;
    }
  }
});

// node_modules/extract-frustum-planes/extract-planes.js
var require_extract_planes = __commonJS({
  "node_modules/extract-frustum-planes/extract-planes.js"(exports2, module2) {
    "use strict";
    module2.exports = extractPlanes;
    function extractPlanes(M, zNear, zFar) {
      var z = zNear || 0;
      var zf = zFar || 1;
      return [
        [M[12] + M[0], M[13] + M[1], M[14] + M[2], M[15] + M[3]],
        [M[12] - M[0], M[13] - M[1], M[14] - M[2], M[15] - M[3]],
        [M[12] + M[4], M[13] + M[5], M[14] + M[6], M[15] + M[7]],
        [M[12] - M[4], M[13] - M[5], M[14] - M[6], M[15] - M[7]],
        [z * M[12] + M[8], z * M[13] + M[9], z * M[14] + M[10], z * M[15] + M[11]],
        [zf * M[12] - M[8], zf * M[13] - M[9], zf * M[14] - M[10], zf * M[15] - M[11]]
      ];
    }
  }
});

// node_modules/gl-vec4/transformMat4.js
var require_transformMat42 = __commonJS({
  "node_modules/gl-vec4/transformMat4.js"(exports2, module2) {
    module2.exports = transformMat4;
    function transformMat4(out, a, m) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return out;
    }
  }
});

// node_modules/gl-axes3d/properties.js
var require_properties = __commonJS({
  "node_modules/gl-axes3d/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = axesProperties;
    var getPlanes = require_extract_planes();
    var splitPoly = require_clip_poly();
    var cubeParams = require_cube();
    var m4mul = require_multiply2();
    var m4transpose = require_transpose();
    var v4transformMat4 = require_transformMat42();
    var identity = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    var mvp = new Float32Array(16);
    function AxesRange3D(lo, hi, pixelsPerDataUnit) {
      this.lo = lo;
      this.hi = hi;
      this.pixelsPerDataUnit = pixelsPerDataUnit;
    }
    var SCRATCH_P = [0, 0, 0, 1];
    var SCRATCH_Q = [0, 0, 0, 1];
    function gradient(result, M, v, width, height) {
      for (var i = 0; i < 3; ++i) {
        var p = SCRATCH_P;
        var q = SCRATCH_Q;
        for (var j = 0; j < 3; ++j) {
          q[j] = p[j] = v[j];
        }
        q[3] = p[3] = 1;
        q[i] += 1;
        v4transformMat4(q, q, M);
        if (q[3] < 0) {
          result[i] = Infinity;
        }
        p[i] -= 1;
        v4transformMat4(p, p, M);
        if (p[3] < 0) {
          result[i] = Infinity;
        }
        var dx = (p[0] / p[3] - q[0] / q[3]) * width;
        var dy = (p[1] / p[3] - q[1] / q[3]) * height;
        result[i] = 0.25 * Math.sqrt(dx * dx + dy * dy);
      }
      return result;
    }
    var RANGES = [
      new AxesRange3D(Infinity, -Infinity, Infinity),
      new AxesRange3D(Infinity, -Infinity, Infinity),
      new AxesRange3D(Infinity, -Infinity, Infinity)
    ];
    var SCRATCH_X = [0, 0, 0];
    function axesProperties(axes, camera, width, height, params) {
      var model = camera.model || identity;
      var view = camera.view || identity;
      var projection = camera.projection || identity;
      var isOrtho = camera._ortho || false;
      var bounds = axes.bounds;
      var params = params || cubeParams(model, view, projection, bounds, isOrtho);
      var axis = params.axis;
      m4mul(mvp, view, model);
      m4mul(mvp, projection, mvp);
      var ranges = RANGES;
      for (var i = 0; i < 3; ++i) {
        ranges[i].lo = Infinity;
        ranges[i].hi = -Infinity;
        ranges[i].pixelsPerDataUnit = Infinity;
      }
      var frustum = getPlanes(m4transpose(mvp, mvp));
      m4transpose(mvp, mvp);
      for (var d = 0; d < 3; ++d) {
        var u = (d + 1) % 3;
        var v = (d + 2) % 3;
        var x = SCRATCH_X;
        i_loop:
          for (var i = 0; i < 2; ++i) {
            var poly = [];
            if (axis[d] < 0 === !!i) {
              continue;
            }
            x[d] = bounds[i][d];
            for (var j = 0; j < 2; ++j) {
              x[u] = bounds[j ^ i][u];
              for (var k = 0; k < 2; ++k) {
                x[v] = bounds[k ^ j ^ i][v];
                poly.push(x.slice());
              }
            }
            var Q = isOrtho ? 5 : 4;
            for (var j = Q; j === Q; ++j) {
              if (poly.length === 0) {
                continue i_loop;
              }
              poly = splitPoly.positive(poly, frustum[j]);
            }
            for (var j = 0; j < poly.length; ++j) {
              var v = poly[j];
              var grad = gradient(SCRATCH_X, mvp, v, width, height);
              for (var k = 0; k < 3; ++k) {
                ranges[k].lo = Math.min(ranges[k].lo, v[k]);
                ranges[k].hi = Math.max(ranges[k].hi, v[k]);
                if (k !== d) {
                  ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]));
                }
              }
            }
          }
      }
      return ranges;
    }
  }
});

// node_modules/gl-spikes3d/shaders/index.js
var require_shaders8 = __commonJS({
  "node_modules/gl-spikes3d/shaders/index.js"(exports2, module2) {
    "use strict";
    var glslify = require_browser();
    var createShader = require_gl_shader();
    var vertSrc = glslify("./vertex.glsl");
    var fragSrc = glslify("./fragment.glsl");
    module2.exports = function(gl2) {
      return createShader(gl2, vertSrc, fragSrc, null, [
        { name: "position", type: "vec3" },
        { name: "color", type: "vec3" },
        { name: "weight", type: "float" }
      ]);
    };
  }
});

// node_modules/gl-spikes3d/spikes.js
var require_spikes = __commonJS({
  "node_modules/gl-spikes3d/spikes.js"(exports2, module2) {
    "use strict";
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createShader = require_shaders8();
    module2.exports = createSpikes;
    var identity = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    function AxisSpikes(gl2, buffer, vao, shader) {
      this.gl = gl2;
      this.buffer = buffer;
      this.vao = vao;
      this.shader = shader;
      this.pixelRatio = 1;
      this.bounds = [[-1e3, -1e3, -1e3], [1e3, 1e3, 1e3]];
      this.position = [0, 0, 0];
      this.lineWidth = [2, 2, 2];
      this.colors = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.enabled = [true, true, true];
      this.drawSides = [true, true, true];
      this.axes = null;
    }
    var proto = AxisSpikes.prototype;
    var OUTER_FACE = [0, 0, 0];
    var INNER_FACE = [0, 0, 0];
    var SHAPE = [0, 0];
    proto.isTransparent = function() {
      return false;
    };
    proto.drawTransparent = function(camera) {
    };
    proto.draw = function(camera) {
      var gl2 = this.gl;
      var vao = this.vao;
      var shader = this.shader;
      vao.bind();
      shader.bind();
      var model = camera.model || identity;
      var view = camera.view || identity;
      var projection = camera.projection || identity;
      var axis;
      if (this.axes) {
        axis = this.axes.lastCubeProps.axis;
      }
      var outerFace = OUTER_FACE;
      var innerFace = INNER_FACE;
      for (var i = 0; i < 3; ++i) {
        if (axis && axis[i] < 0) {
          outerFace[i] = this.bounds[0][i];
          innerFace[i] = this.bounds[1][i];
        } else {
          outerFace[i] = this.bounds[1][i];
          innerFace[i] = this.bounds[0][i];
        }
      }
      SHAPE[0] = gl2.drawingBufferWidth;
      SHAPE[1] = gl2.drawingBufferHeight;
      shader.uniforms.model = model;
      shader.uniforms.view = view;
      shader.uniforms.projection = projection;
      shader.uniforms.coordinates = [this.position, outerFace, innerFace];
      shader.uniforms.colors = this.colors;
      shader.uniforms.screenShape = SHAPE;
      for (var i = 0; i < 3; ++i) {
        shader.uniforms.lineWidth = this.lineWidth[i] * this.pixelRatio;
        if (this.enabled[i]) {
          vao.draw(gl2.TRIANGLES, 6, 6 * i);
          if (this.drawSides[i]) {
            vao.draw(gl2.TRIANGLES, 12, 18 + 12 * i);
          }
        }
      }
      vao.unbind();
    };
    proto.update = function(options) {
      if (!options) {
        return;
      }
      if ("bounds" in options) {
        this.bounds = options.bounds;
      }
      if ("position" in options) {
        this.position = options.position;
      }
      if ("lineWidth" in options) {
        this.lineWidth = options.lineWidth;
      }
      if ("colors" in options) {
        this.colors = options.colors;
      }
      if ("enabled" in options) {
        this.enabled = options.enabled;
      }
      if ("drawSides" in options) {
        this.drawSides = options.drawSides;
      }
    };
    proto.dispose = function() {
      this.vao.dispose();
      this.buffer.dispose();
      this.shader.dispose();
    };
    function createSpikes(gl2, options) {
      var data = [];
      function line(x, y, z, i, l, h) {
        var row = [x, y, z, 0, 0, 0, 1];
        row[i + 3] = 1;
        row[i] = l;
        data.push.apply(data, row);
        row[6] = -1;
        data.push.apply(data, row);
        row[i] = h;
        data.push.apply(data, row);
        data.push.apply(data, row);
        row[6] = 1;
        data.push.apply(data, row);
        row[i] = l;
        data.push.apply(data, row);
      }
      line(0, 0, 0, 0, 0, 1);
      line(0, 0, 0, 1, 0, 1);
      line(0, 0, 0, 2, 0, 1);
      line(1, 0, 0, 1, -1, 1);
      line(1, 0, 0, 2, -1, 1);
      line(0, 1, 0, 0, -1, 1);
      line(0, 1, 0, 2, -1, 1);
      line(0, 0, 1, 0, -1, 1);
      line(0, 0, 1, 1, -1, 1);
      var buffer = createBuffer(gl2, data);
      var vao = createVAO(gl2, [{
        type: gl2.FLOAT,
        buffer,
        size: 3,
        offset: 0,
        stride: 28
      }, {
        type: gl2.FLOAT,
        buffer,
        size: 3,
        offset: 12,
        stride: 28
      }, {
        type: gl2.FLOAT,
        buffer,
        size: 1,
        offset: 24,
        stride: 28
      }]);
      var shader = createShader(gl2);
      shader.attributes.position.location = 0;
      shader.attributes.color.location = 1;
      shader.attributes.weight.location = 2;
      var spikes = new AxisSpikes(gl2, buffer, vao, shader);
      spikes.update(options);
      return spikes;
    }
  }
});

// node_modules/weak-map/weak-map.js
var require_weak_map = __commonJS({
  "node_modules/weak-map/weak-map.js"(exports2, module2) {
    (function WeakMapModule() {
      "use strict";
      if (typeof ses !== "undefined" && ses.ok && !ses.ok()) {
        return;
      }
      function weakMapPermitHostObjects(map) {
        if (map.permitHostObjects___) {
          map.permitHostObjects___(weakMapPermitHostObjects);
        }
      }
      if (typeof ses !== "undefined") {
        ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
      }
      var doubleWeakMapCheckSilentFailure = false;
      if (typeof WeakMap === "function") {
        var HostWeakMap = WeakMap;
        if (typeof navigator !== "undefined" && /Firefox/.test(navigator.userAgent)) {
        } else {
          var testMap = new HostWeakMap();
          var testObject = Object.freeze({});
          testMap.set(testObject, 1);
          if (testMap.get(testObject) !== 1) {
            doubleWeakMapCheckSilentFailure = true;
          } else {
            module2.exports = WeakMap;
            return;
          }
        }
      }
      var hop = Object.prototype.hasOwnProperty;
      var gopn = Object.getOwnPropertyNames;
      var defProp = Object.defineProperty;
      var isExtensible = Object.isExtensible;
      var HIDDEN_NAME_PREFIX = "weakmap:";
      var HIDDEN_NAME = HIDDEN_NAME_PREFIX + "ident:" + Math.random() + "___";
      if (typeof crypto !== "undefined" && typeof crypto.getRandomValues === "function" && typeof ArrayBuffer === "function" && typeof Uint8Array === "function") {
        var ab = new ArrayBuffer(25);
        var u8s = new Uint8Array(ab);
        crypto.getRandomValues(u8s);
        HIDDEN_NAME = HIDDEN_NAME_PREFIX + "rand:" + Array.prototype.map.call(u8s, function(u8) {
          return (u8 % 36).toString(36);
        }).join("") + "___";
      }
      function isNotHiddenName(name2) {
        return !(name2.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX && name2.substr(name2.length - 3) === "___");
      }
      defProp(Object, "getOwnPropertyNames", {
        value: function fakeGetOwnPropertyNames(obj) {
          return gopn(obj).filter(isNotHiddenName);
        }
      });
      if ("getPropertyNames" in Object) {
        var originalGetPropertyNames = Object.getPropertyNames;
        defProp(Object, "getPropertyNames", {
          value: function fakeGetPropertyNames(obj) {
            return originalGetPropertyNames(obj).filter(isNotHiddenName);
          }
        });
      }
      function getHiddenRecord(key) {
        if (key !== Object(key)) {
          throw new TypeError("Not an object: " + key);
        }
        var hiddenRecord = key[HIDDEN_NAME];
        if (hiddenRecord && hiddenRecord.key === key) {
          return hiddenRecord;
        }
        if (!isExtensible(key)) {
          return void 0;
        }
        hiddenRecord = { key };
        try {
          defProp(key, HIDDEN_NAME, {
            value: hiddenRecord,
            writable: false,
            enumerable: false,
            configurable: false
          });
          return hiddenRecord;
        } catch (error) {
          return void 0;
        }
      }
      (function() {
        var oldFreeze = Object.freeze;
        defProp(Object, "freeze", {
          value: function identifyingFreeze(obj) {
            getHiddenRecord(obj);
            return oldFreeze(obj);
          }
        });
        var oldSeal = Object.seal;
        defProp(Object, "seal", {
          value: function identifyingSeal(obj) {
            getHiddenRecord(obj);
            return oldSeal(obj);
          }
        });
        var oldPreventExtensions = Object.preventExtensions;
        defProp(Object, "preventExtensions", {
          value: function identifyingPreventExtensions(obj) {
            getHiddenRecord(obj);
            return oldPreventExtensions(obj);
          }
        });
      })();
      function constFunc(func) {
        func.prototype = null;
        return Object.freeze(func);
      }
      var calledAsFunctionWarningDone = false;
      function calledAsFunctionWarning() {
        if (!calledAsFunctionWarningDone && typeof console !== "undefined") {
          calledAsFunctionWarningDone = true;
          console.warn("WeakMap should be invoked as new WeakMap(), not WeakMap(). This will be an error in the future.");
        }
      }
      var nextId = 0;
      var OurWeakMap = function() {
        if (!(this instanceof OurWeakMap)) {
          calledAsFunctionWarning();
        }
        var keys = [];
        var values = [];
        var id = nextId++;
        function get___(key, opt_default) {
          var index;
          var hiddenRecord = getHiddenRecord(key);
          if (hiddenRecord) {
            return id in hiddenRecord ? hiddenRecord[id] : opt_default;
          } else {
            index = keys.indexOf(key);
            return index >= 0 ? values[index] : opt_default;
          }
        }
        function has___(key) {
          var hiddenRecord = getHiddenRecord(key);
          if (hiddenRecord) {
            return id in hiddenRecord;
          } else {
            return keys.indexOf(key) >= 0;
          }
        }
        function set___(key, value) {
          var index;
          var hiddenRecord = getHiddenRecord(key);
          if (hiddenRecord) {
            hiddenRecord[id] = value;
          } else {
            index = keys.indexOf(key);
            if (index >= 0) {
              values[index] = value;
            } else {
              index = keys.length;
              values[index] = value;
              keys[index] = key;
            }
          }
          return this;
        }
        function delete___(key) {
          var hiddenRecord = getHiddenRecord(key);
          var index, lastIndex;
          if (hiddenRecord) {
            return id in hiddenRecord && delete hiddenRecord[id];
          } else {
            index = keys.indexOf(key);
            if (index < 0) {
              return false;
            }
            lastIndex = keys.length - 1;
            keys[index] = void 0;
            values[index] = values[lastIndex];
            keys[index] = keys[lastIndex];
            keys.length = lastIndex;
            values.length = lastIndex;
            return true;
          }
        }
        return Object.create(OurWeakMap.prototype, {
          get___: { value: constFunc(get___) },
          has___: { value: constFunc(has___) },
          set___: { value: constFunc(set___) },
          delete___: { value: constFunc(delete___) }
        });
      };
      OurWeakMap.prototype = Object.create(Object.prototype, {
        get: {
          /**
           * Return the value most recently associated with key, or
           * opt_default if none.
           */
          value: function get(key, opt_default) {
            return this.get___(key, opt_default);
          },
          writable: true,
          configurable: true
        },
        has: {
          /**
           * Is there a value associated with key in this WeakMap?
           */
          value: function has(key) {
            return this.has___(key);
          },
          writable: true,
          configurable: true
        },
        set: {
          /**
           * Associate value with key in this WeakMap, overwriting any
           * previous association if present.
           */
          value: function set(key, value) {
            return this.set___(key, value);
          },
          writable: true,
          configurable: true
        },
        "delete": {
          /**
           * Remove any association for key in this WeakMap, returning
           * whether there was one.
           *
           * <p>Note that the boolean return here does not work like the
           * {@code delete} operator. The {@code delete} operator returns
           * whether the deletion succeeds at bringing about a state in
           * which the deleted property is absent. The {@code delete}
           * operator therefore returns true if the property was already
           * absent, whereas this {@code delete} method returns false if
           * the association was already absent.
           */
          value: function remove(key) {
            return this.delete___(key);
          },
          writable: true,
          configurable: true
        }
      });
      if (typeof HostWeakMap === "function") {
        (function() {
          if (doubleWeakMapCheckSilentFailure && typeof Proxy !== "undefined") {
            Proxy = void 0;
          }
          function DoubleWeakMap() {
            if (!(this instanceof OurWeakMap)) {
              calledAsFunctionWarning();
            }
            var hmap = new HostWeakMap();
            var omap = void 0;
            var enableSwitching = false;
            function dget(key, opt_default) {
              if (omap) {
                return hmap.has(key) ? hmap.get(key) : omap.get___(key, opt_default);
              } else {
                return hmap.get(key, opt_default);
              }
            }
            function dhas(key) {
              return hmap.has(key) || (omap ? omap.has___(key) : false);
            }
            var dset;
            if (doubleWeakMapCheckSilentFailure) {
              dset = function(key, value) {
                hmap.set(key, value);
                if (!hmap.has(key)) {
                  if (!omap) {
                    omap = new OurWeakMap();
                  }
                  omap.set(key, value);
                }
                return this;
              };
            } else {
              dset = function(key, value) {
                if (enableSwitching) {
                  try {
                    hmap.set(key, value);
                  } catch (e) {
                    if (!omap) {
                      omap = new OurWeakMap();
                    }
                    omap.set___(key, value);
                  }
                } else {
                  hmap.set(key, value);
                }
                return this;
              };
            }
            function ddelete(key) {
              var result = !!hmap["delete"](key);
              if (omap) {
                return omap.delete___(key) || result;
              }
              return result;
            }
            return Object.create(OurWeakMap.prototype, {
              get___: { value: constFunc(dget) },
              has___: { value: constFunc(dhas) },
              set___: { value: constFunc(dset) },
              delete___: { value: constFunc(ddelete) },
              permitHostObjects___: { value: constFunc(function(token) {
                if (token === weakMapPermitHostObjects) {
                  enableSwitching = true;
                } else {
                  throw new Error("bogus call to permitHostObjects___");
                }
              }) }
            });
          }
          DoubleWeakMap.prototype = OurWeakMap.prototype;
          module2.exports = DoubleWeakMap;
          Object.defineProperty(WeakMap.prototype, "constructor", {
            value: WeakMap,
            enumerable: false,
            // as default .constructor is
            configurable: true,
            writable: true
          });
        })();
      } else {
        if (typeof Proxy !== "undefined") {
          Proxy = void 0;
        }
        module2.exports = OurWeakMap;
      }
    })();
  }
});

// node_modules/a-big-triangle/triangle.js
var require_triangle = __commonJS({
  "node_modules/a-big-triangle/triangle.js"(exports2, module2) {
    "use strict";
    var weakMap = typeof WeakMap === "undefined" ? require_weak_map() : WeakMap;
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var TriangleCache = new weakMap();
    function createABigTriangle(gl2) {
      var triangleVAO = TriangleCache.get(gl2);
      var handle = triangleVAO && (triangleVAO._triangleBuffer.handle || triangleVAO._triangleBuffer.buffer);
      if (!handle || !gl2.isBuffer(handle)) {
        var buf = createBuffer(gl2, new Float32Array([-1, -1, -1, 4, 4, -1]));
        triangleVAO = createVAO(gl2, [
          {
            buffer: buf,
            type: gl2.FLOAT,
            size: 2
          }
        ]);
        triangleVAO._triangleBuffer = buf;
        TriangleCache.set(gl2, triangleVAO);
      }
      triangleVAO.bind();
      gl2.drawArrays(gl2.TRIANGLES, 0, 3);
      triangleVAO.unbind();
    }
    module2.exports = createABigTriangle;
  }
});

// node_modules/gl-mat4/perspective.js
var require_perspective = __commonJS({
  "node_modules/gl-mat4/perspective.js"(exports2, module2) {
    module2.exports = perspective;
    function perspective(out, fovy, aspect, near, far) {
      var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = 2 * far * near * nf;
      out[15] = 0;
      return out;
    }
  }
});

// node_modules/gl-mat4/ortho.js
var require_ortho = __commonJS({
  "node_modules/gl-mat4/ortho.js"(exports2, module2) {
    module2.exports = ortho;
    function ortho(out, left, right, bottom, top, near, far) {
      var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
      out[0] = -2 * lr;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = -2 * bt;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 2 * nf;
      out[11] = 0;
      out[12] = (left + right) * lr;
      out[13] = (top + bottom) * bt;
      out[14] = (far + near) * nf;
      out[15] = 1;
      return out;
    }
  }
});

// node_modules/gl-plot3d/lib/shader.js
var require_shader = __commonJS({
  "node_modules/gl-plot3d/lib/shader.js"(exports2, module2) {
    var glslify = require_browser();
    var createShader = require_gl_shader();
    var vertSrc = glslify("./vertex.glsl");
    var fragSrc = glslify("./composite.glsl");
    module2.exports = function(gl2) {
      return createShader(gl2, vertSrc, fragSrc, null, [{ name: "position", type: "vec2" }]);
    };
  }
});

// node_modules/is-mobile/index.js
var require_is_mobile = __commonJS({
  "node_modules/is-mobile/index.js"(exports2, module2) {
    "use strict";
    module2.exports = isMobile;
    module2.exports.isMobile = isMobile;
    module2.exports.default = isMobile;
    var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
    var notMobileRE = /CrOS/;
    var tabletRE = /android|ipad|playbook|silk/i;
    function isMobile(opts) {
      if (!opts) opts = {};
      let ua = opts.ua;
      if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
      if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
        ua = ua.headers["user-agent"];
      }
      if (typeof ua !== "string") return false;
      let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
      if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
        result = true;
      }
      return result;
    }
  }
});

// node_modules/gl-plot3d/scene.js
var require_scene = __commonJS({
  "node_modules/gl-plot3d/scene.js"(exports2, module2) {
    "use strict";
    var createCamera = require_camera();
    var createAxes = require_axes();
    var axesRanges = require_properties();
    var createSpikes = require_spikes();
    var createSelect = require_select();
    var createFBO = require_fbo();
    var drawTriangle = require_triangle();
    var mouseChange = require_mouse_listen();
    var perspective = require_perspective();
    var ortho = require_ortho();
    var createShader = require_shader();
    var isMobile = require_is_mobile()({ tablet: true, featureDetect: true });
    module2.exports = {
      createScene,
      createCamera
    };
    function MouseSelect() {
      this.mouse = [-1, -1];
      this.screen = null;
      this.distance = Infinity;
      this.index = null;
      this.dataCoordinate = null;
      this.dataPosition = null;
      this.object = null;
      this.data = null;
    }
    function getContext(canvas, options) {
      var gl2 = null;
      try {
        gl2 = canvas.getContext("webgl", options);
        if (!gl2) {
          gl2 = canvas.getContext("experimental-webgl", options);
        }
      } catch (e) {
        return null;
      }
      return gl2;
    }
    function roundUpPow10(x) {
      var y = Math.round(Math.log(Math.abs(x)) / Math.log(10));
      if (y < 0) {
        var base = Math.round(Math.pow(10, -y));
        return Math.ceil(x * base) / base;
      } else if (y > 0) {
        var base = Math.round(Math.pow(10, y));
        return Math.ceil(x / base) * base;
      }
      return Math.ceil(x);
    }
    function defaultBool(x) {
      if (typeof x === "boolean") {
        return x;
      }
      return true;
    }
    function createScene(options) {
      options = options || {};
      options.camera = options.camera || {};
      var canvas = options.canvas;
      if (!canvas) {
        canvas = document.createElement("canvas");
        if (options.container) {
          var container = options.container;
          container.appendChild(canvas);
        } else {
          document.body.appendChild(canvas);
        }
      }
      var gl2 = options.gl;
      if (!gl2) {
        if (options.glOptions) {
          isMobile = !!options.glOptions.preserveDrawingBuffer;
        }
        gl2 = getContext(
          canvas,
          options.glOptions || {
            premultipliedAlpha: true,
            antialias: true,
            preserveDrawingBuffer: isMobile
          }
        );
      }
      if (!gl2) {
        throw new Error("webgl not supported");
      }
      var bounds = options.bounds || [[-10, -10, -10], [10, 10, 10]];
      var selection = new MouseSelect();
      var accumBuffer = createFBO(
        gl2,
        gl2.drawingBufferWidth,
        gl2.drawingBufferHeight,
        {
          preferFloat: !isMobile
        }
      );
      var accumShader = createShader(gl2);
      var isOrtho = options.cameraObject && options.cameraObject._ortho === true || options.camera.projection && options.camera.projection.type === "orthographic" || false;
      var cameraOptions = {
        eye: options.camera.eye || [2, 0, 0],
        center: options.camera.center || [0, 0, 0],
        up: options.camera.up || [0, 1, 0],
        zoomMin: options.camera.zoomMax || 0.1,
        zoomMax: options.camera.zoomMin || 100,
        mode: options.camera.mode || "turntable",
        _ortho: isOrtho
      };
      var axesOptions = options.axes || {};
      var axes = createAxes(gl2, axesOptions);
      axes.enable = !axesOptions.disable;
      var spikeOptions = options.spikes || {};
      var spikes = createSpikes(gl2, spikeOptions);
      var objects = [];
      var pickBufferIds = [];
      var pickBufferCount = [];
      var pickBuffers = [];
      var dirty = true;
      var pickDirty = true;
      var projection = new Array(16);
      var model = new Array(16);
      var cameraParams = {
        view: null,
        projection,
        model,
        _ortho: false
      };
      var pickDirty = true;
      var viewShape = [gl2.drawingBufferWidth, gl2.drawingBufferHeight];
      var camera = options.cameraObject || createCamera(canvas, cameraOptions);
      var scene = {
        gl: gl2,
        contextLost: false,
        pixelRatio: options.pixelRatio || 1,
        canvas,
        selection,
        camera,
        axes,
        axesPixels: null,
        spikes,
        bounds,
        objects,
        shape: viewShape,
        aspect: options.aspectRatio || [1, 1, 1],
        pickRadius: options.pickRadius || 10,
        zNear: options.zNear || 0.01,
        zFar: options.zFar || 1e3,
        fovy: options.fovy || Math.PI / 4,
        clearColor: options.clearColor || [0, 0, 0, 0],
        autoResize: defaultBool(options.autoResize),
        autoBounds: defaultBool(options.autoBounds),
        autoScale: !!options.autoScale,
        autoCenter: defaultBool(options.autoCenter),
        clipToBounds: defaultBool(options.clipToBounds),
        snapToData: !!options.snapToData,
        onselect: options.onselect || null,
        onrender: options.onrender || null,
        onclick: options.onclick || null,
        cameraParams,
        oncontextloss: null,
        mouseListener: null,
        _stopped: false,
        getAspectratio: function() {
          return {
            x: this.aspect[0],
            y: this.aspect[1],
            z: this.aspect[2]
          };
        },
        setAspectratio: function(aspectratio) {
          this.aspect[0] = aspectratio.x;
          this.aspect[1] = aspectratio.y;
          this.aspect[2] = aspectratio.z;
          pickDirty = true;
        },
        setBounds: function(axisIndex, range) {
          this.bounds[0][axisIndex] = range.min;
          this.bounds[1][axisIndex] = range.max;
        },
        setClearColor: function(clearColor) {
          this.clearColor = clearColor;
        },
        clearRGBA: function() {
          this.gl.clearColor(
            this.clearColor[0],
            this.clearColor[1],
            this.clearColor[2],
            this.clearColor[3]
          );
          this.gl.clear(
            this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT
          );
        }
      };
      var pickShape = [gl2.drawingBufferWidth / scene.pixelRatio | 0, gl2.drawingBufferHeight / scene.pixelRatio | 0];
      function resizeListener() {
        if (scene._stopped) {
          return;
        }
        if (!scene.autoResize) {
          return;
        }
        var parent = canvas.parentNode;
        var width = 1;
        var height = 1;
        if (parent && parent !== document.body) {
          width = parent.clientWidth;
          height = parent.clientHeight;
        } else {
          width = window.innerWidth;
          height = window.innerHeight;
        }
        var nextWidth = Math.ceil(width * scene.pixelRatio) | 0;
        var nextHeight = Math.ceil(height * scene.pixelRatio) | 0;
        if (nextWidth !== canvas.width || nextHeight !== canvas.height) {
          canvas.width = nextWidth;
          canvas.height = nextHeight;
          var style = canvas.style;
          style.position = style.position || "absolute";
          style.left = "0px";
          style.top = "0px";
          style.width = width + "px";
          style.height = height + "px";
          dirty = true;
        }
      }
      if (scene.autoResize) {
        resizeListener();
      }
      window.addEventListener("resize", resizeListener);
      function reallocPickIds() {
        var numObjs = objects.length;
        var numPick = pickBuffers.length;
        for (var i = 0; i < numPick; ++i) {
          pickBufferCount[i] = 0;
        }
        obj_loop:
          for (var i = 0; i < numObjs; ++i) {
            var obj = objects[i];
            var pickCount = obj.pickSlots;
            if (!pickCount) {
              pickBufferIds[i] = -1;
              continue;
            }
            for (var j = 0; j < numPick; ++j) {
              if (pickBufferCount[j] + pickCount < 255) {
                pickBufferIds[i] = j;
                obj.setPickBase(pickBufferCount[j] + 1);
                pickBufferCount[j] += pickCount;
                continue obj_loop;
              }
            }
            var nbuffer = createSelect(gl2, viewShape);
            pickBufferIds[i] = numPick;
            pickBuffers.push(nbuffer);
            pickBufferCount.push(pickCount);
            obj.setPickBase(1);
            numPick += 1;
          }
        while (numPick > 0 && pickBufferCount[numPick - 1] === 0) {
          pickBufferCount.pop();
          pickBuffers.pop().dispose();
        }
      }
      scene.update = function(options2) {
        if (scene._stopped) {
          return;
        }
        options2 = options2 || {};
        dirty = true;
        pickDirty = true;
      };
      scene.add = function(obj) {
        if (scene._stopped) {
          return;
        }
        obj.axes = axes;
        objects.push(obj);
        pickBufferIds.push(-1);
        dirty = true;
        pickDirty = true;
        reallocPickIds();
      };
      scene.remove = function(obj) {
        if (scene._stopped) {
          return;
        }
        var idx = objects.indexOf(obj);
        if (idx < 0) {
          return;
        }
        objects.splice(idx, 1);
        pickBufferIds.pop();
        dirty = true;
        pickDirty = true;
        reallocPickIds();
      };
      scene.dispose = function() {
        if (scene._stopped) {
          return;
        }
        scene._stopped = true;
        window.removeEventListener("resize", resizeListener);
        canvas.removeEventListener("webglcontextlost", checkContextLoss);
        scene.mouseListener.enabled = false;
        if (scene.contextLost) {
          return;
        }
        axes.dispose();
        spikes.dispose();
        for (var i = 0; i < objects.length; ++i) {
          objects[i].dispose();
        }
        accumBuffer.dispose();
        for (var i = 0; i < pickBuffers.length; ++i) {
          pickBuffers[i].dispose();
        }
        accumShader.dispose();
        gl2 = null;
        axes = null;
        spikes = null;
        objects = [];
      };
      scene._mouseRotating = false;
      scene._prevButtons = 0;
      scene.enableMouseListeners = function() {
        scene.mouseListener = mouseChange(canvas, function(buttons, x, y) {
          if (scene._stopped) {
            return;
          }
          var numPick = pickBuffers.length;
          var numObjs = objects.length;
          var prevObj = selection.object;
          selection.distance = Infinity;
          selection.mouse[0] = x;
          selection.mouse[1] = y;
          selection.object = null;
          selection.screen = null;
          selection.dataCoordinate = selection.dataPosition = null;
          var change = false;
          if (buttons && scene._prevButtons) {
            scene._mouseRotating = true;
          } else {
            if (scene._mouseRotating) {
              pickDirty = true;
            }
            scene._mouseRotating = false;
            for (var i = 0; i < numPick; ++i) {
              var result = pickBuffers[i].query(x, pickShape[1] - y - 1, scene.pickRadius);
              if (result) {
                if (result.distance > selection.distance) {
                  continue;
                }
                for (var j = 0; j < numObjs; ++j) {
                  var obj = objects[j];
                  if (pickBufferIds[j] !== i) {
                    continue;
                  }
                  var objPick = obj.pick(result);
                  if (objPick) {
                    selection.buttons = buttons;
                    selection.screen = result.coord;
                    selection.distance = result.distance;
                    selection.object = obj;
                    selection.index = objPick.distance;
                    selection.dataPosition = objPick.position;
                    selection.dataCoordinate = objPick.dataCoordinate;
                    selection.data = objPick;
                    change = true;
                  }
                }
              }
            }
          }
          if (prevObj && prevObj !== selection.object) {
            if (prevObj.highlight) {
              prevObj.highlight(null);
            }
            dirty = true;
          }
          if (selection.object) {
            if (selection.object.highlight) {
              selection.object.highlight(selection.data);
            }
            dirty = true;
          }
          change = change || selection.object !== prevObj;
          if (change && scene.onselect) {
            scene.onselect(selection);
          }
          if (buttons & 1 && !(scene._prevButtons & 1) && scene.onclick) {
            scene.onclick(selection);
          }
          scene._prevButtons = buttons;
        });
      };
      function checkContextLoss() {
        if (scene.contextLost) {
          return true;
        }
        if (gl2.isContextLost()) {
          scene.contextLost = true;
          scene.mouseListener.enabled = false;
          scene.selection.object = null;
          if (scene.oncontextloss) {
            scene.oncontextloss();
          }
        }
      }
      canvas.addEventListener("webglcontextlost", checkContextLoss);
      function renderPick() {
        if (checkContextLoss()) {
          return;
        }
        gl2.colorMask(true, true, true, true);
        gl2.depthMask(true);
        gl2.disable(gl2.BLEND);
        gl2.enable(gl2.DEPTH_TEST);
        gl2.depthFunc(gl2.LEQUAL);
        var numObjs = objects.length;
        var numPick = pickBuffers.length;
        for (var j = 0; j < numPick; ++j) {
          var buf = pickBuffers[j];
          buf.shape = pickShape;
          buf.begin();
          for (var i = 0; i < numObjs; ++i) {
            if (pickBufferIds[i] !== j) {
              continue;
            }
            var obj = objects[i];
            if (obj.drawPick) {
              obj.pixelRatio = 1;
              obj.drawPick(cameraParams);
            }
          }
          buf.end();
        }
      }
      var nBounds = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      var prevBounds = [nBounds[0].slice(), nBounds[1].slice()];
      function redraw() {
        if (checkContextLoss()) {
          return;
        }
        resizeListener();
        var cameraMoved = scene.camera.tick();
        cameraParams.view = scene.camera.matrix;
        dirty = dirty || cameraMoved;
        pickDirty = pickDirty || cameraMoved;
        axes.pixelRatio = scene.pixelRatio;
        spikes.pixelRatio = scene.pixelRatio;
        var numObjs = objects.length;
        var lo = nBounds[0];
        var hi = nBounds[1];
        lo[0] = lo[1] = lo[2] = Infinity;
        hi[0] = hi[1] = hi[2] = -Infinity;
        for (var i = 0; i < numObjs; ++i) {
          var obj = objects[i];
          obj.pixelRatio = scene.pixelRatio;
          obj.axes = scene.axes;
          dirty = dirty || !!obj.dirty;
          pickDirty = pickDirty || !!obj.dirty;
          var obb = obj.bounds;
          if (obb) {
            var olo = obb[0];
            var ohi = obb[1];
            for (var j = 0; j < 3; ++j) {
              lo[j] = Math.min(lo[j], olo[j]);
              hi[j] = Math.max(hi[j], ohi[j]);
            }
          }
        }
        var bounds2 = scene.bounds;
        if (scene.autoBounds) {
          for (var j = 0; j < 3; ++j) {
            if (hi[j] < lo[j]) {
              lo[j] = -1;
              hi[j] = 1;
            } else {
              if (lo[j] === hi[j]) {
                lo[j] -= 1;
                hi[j] += 1;
              }
              var padding = 0.05 * (hi[j] - lo[j]);
              lo[j] = lo[j] - padding;
              hi[j] = hi[j] + padding;
            }
            bounds2[0][j] = lo[j];
            bounds2[1][j] = hi[j];
          }
        }
        var boundsChanged = false;
        for (var j = 0; j < 3; ++j) {
          boundsChanged = boundsChanged || prevBounds[0][j] !== bounds2[0][j] || prevBounds[1][j] !== bounds2[1][j];
          prevBounds[0][j] = bounds2[0][j];
          prevBounds[1][j] = bounds2[1][j];
        }
        pickDirty = pickDirty || boundsChanged;
        dirty = dirty || boundsChanged;
        if (!dirty) {
          return;
        }
        if (boundsChanged) {
          var tickSpacing = [0, 0, 0];
          for (var i = 0; i < 3; ++i) {
            tickSpacing[i] = roundUpPow10((bounds2[1][i] - bounds2[0][i]) / 10);
          }
          if (axes.autoTicks) {
            axes.update({
              bounds: bounds2,
              tickSpacing
            });
          } else {
            axes.update({
              bounds: bounds2
            });
          }
        }
        var width = gl2.drawingBufferWidth;
        var height = gl2.drawingBufferHeight;
        viewShape[0] = width;
        viewShape[1] = height;
        pickShape[0] = Math.max(width / scene.pixelRatio, 1) | 0;
        pickShape[1] = Math.max(height / scene.pixelRatio, 1) | 0;
        calcCameraParams(scene, isOrtho);
        for (var i = 0; i < numObjs; ++i) {
          var obj = objects[i];
          obj.axesBounds = bounds2;
          if (scene.clipToBounds) {
            obj.clipBounds = bounds2;
          }
        }
        if (selection.object) {
          if (scene.snapToData) {
            spikes.position = selection.dataCoordinate;
          } else {
            spikes.position = selection.dataPosition;
          }
          spikes.bounds = bounds2;
        }
        if (pickDirty) {
          pickDirty = false;
          renderPick();
        }
        scene.axesPixels = axesRanges(scene.axes, cameraParams, width, height);
        if (scene.onrender) {
          scene.onrender();
        }
        gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
        gl2.viewport(0, 0, width, height);
        scene.clearRGBA();
        gl2.depthMask(true);
        gl2.colorMask(true, true, true, true);
        gl2.enable(gl2.DEPTH_TEST);
        gl2.depthFunc(gl2.LEQUAL);
        gl2.disable(gl2.BLEND);
        gl2.disable(gl2.CULL_FACE);
        var hasTransparent = false;
        if (axes.enable) {
          hasTransparent = hasTransparent || axes.isTransparent();
          axes.draw(cameraParams);
        }
        spikes.axes = axes;
        if (selection.object) {
          spikes.draw(cameraParams);
        }
        gl2.disable(gl2.CULL_FACE);
        for (var i = 0; i < numObjs; ++i) {
          var obj = objects[i];
          obj.axes = axes;
          obj.pixelRatio = scene.pixelRatio;
          if (obj.isOpaque && obj.isOpaque()) {
            obj.draw(cameraParams);
          }
          if (obj.isTransparent && obj.isTransparent()) {
            hasTransparent = true;
          }
        }
        if (hasTransparent) {
          accumBuffer.shape = viewShape;
          accumBuffer.bind();
          gl2.clear(gl2.DEPTH_BUFFER_BIT);
          gl2.colorMask(false, false, false, false);
          gl2.depthMask(true);
          gl2.depthFunc(gl2.LESS);
          if (axes.enable && axes.isTransparent()) {
            axes.drawTransparent(cameraParams);
          }
          for (var i = 0; i < numObjs; ++i) {
            var obj = objects[i];
            if (obj.isOpaque && obj.isOpaque()) {
              obj.draw(cameraParams);
            }
          }
          gl2.enable(gl2.BLEND);
          gl2.blendEquation(gl2.FUNC_ADD);
          gl2.blendFunc(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
          gl2.colorMask(true, true, true, true);
          gl2.depthMask(false);
          gl2.clearColor(0, 0, 0, 0);
          gl2.clear(gl2.COLOR_BUFFER_BIT);
          if (axes.isTransparent()) {
            axes.drawTransparent(cameraParams);
          }
          for (var i = 0; i < numObjs; ++i) {
            var obj = objects[i];
            if (obj.isTransparent && obj.isTransparent()) {
              obj.drawTransparent(cameraParams);
            }
          }
          gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
          gl2.blendFunc(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
          gl2.disable(gl2.DEPTH_TEST);
          accumShader.bind();
          accumBuffer.color[0].bind(0);
          accumShader.uniforms.accumBuffer = 0;
          drawTriangle(gl2);
          gl2.disable(gl2.BLEND);
        }
        dirty = false;
        for (var i = 0; i < numObjs; ++i) {
          objects[i].dirty = false;
        }
      }
      function render() {
        if (scene._stopped || scene.contextLost) {
          return;
        }
        redraw();
        requestAnimationFrame(render);
      }
      scene.enableMouseListeners();
      render();
      scene.redraw = function() {
        if (scene._stopped) {
          return;
        }
        dirty = true;
        redraw();
      };
      return scene;
    }
    function calcCameraParams(scene, isOrtho) {
      var bounds = scene.bounds;
      var cameraParams = scene.cameraParams;
      var projection = cameraParams.projection;
      var model = cameraParams.model;
      var width = scene.gl.drawingBufferWidth;
      var height = scene.gl.drawingBufferHeight;
      var zNear = scene.zNear;
      var zFar = scene.zFar;
      var fovy = scene.fovy;
      var r = width / height;
      if (isOrtho) {
        ortho(
          projection,
          -r,
          r,
          -1,
          1,
          zNear,
          zFar
        );
        cameraParams._ortho = true;
      } else {
        perspective(
          projection,
          fovy,
          r,
          zNear,
          zFar
        );
        cameraParams._ortho = false;
      }
      for (var i = 0; i < 16; ++i) {
        model[i] = 0;
      }
      model[15] = 1;
      var maxS = 0;
      for (var i = 0; i < 3; ++i) {
        maxS = Math.max(maxS, bounds[1][i] - bounds[0][i]);
      }
      for (var i = 0; i < 3; ++i) {
        if (scene.autoScale) {
          model[5 * i] = scene.aspect[i] / (bounds[1][i] - bounds[0][i]);
        } else {
          model[5 * i] = 1 / maxS;
        }
        if (scene.autoCenter) {
          model[12 + i] = -model[5 * i] * 0.5 * (bounds[0][i] + bounds[1][i]);
        }
      }
    }
  }
});

// node_modules/gl-pointcloud2d/lib/shader.js
var require_shader2 = __commonJS({
  "node_modules/gl-pointcloud2d/lib/shader.js"(exports2) {
    var glslify = require_browser();
    exports2.pointVertex = glslify("./shader/point-vertex.glsl");
    exports2.pointFragment = glslify("./shader/point-fragment.glsl");
    exports2.pickVertex = glslify("./shader/pick-vertex.glsl");
    exports2.pickFragment = glslify("./shader/pick-fragment.glsl");
  }
});

// node_modules/gl-pointcloud2d/pointcloud2d.js
var require_pointcloud2d = __commonJS({
  "node_modules/gl-pointcloud2d/pointcloud2d.js"(exports2, module2) {
    "use strict";
    var createShader = require_gl_shader();
    var createBuffer = require_buffer2();
    var pool = require_pool();
    var SHADERS = require_shader2();
    module2.exports = createPointcloud2D;
    function Pointcloud2D(plot, offsetBuffer, pickBuffer, shader, pickShader) {
      this.plot = plot;
      this.offsetBuffer = offsetBuffer;
      this.pickBuffer = pickBuffer;
      this.shader = shader;
      this.pickShader = pickShader;
      this.sizeMin = 0.5;
      this.sizeMinCap = 2;
      this.sizeMax = 20;
      this.areaRatio = 1;
      this.pointCount = 0;
      this.color = [1, 0, 0, 1];
      this.borderColor = [0, 0, 0, 1];
      this.blend = false;
      this.pickOffset = 0;
      this.points = null;
    }
    var proto = Pointcloud2D.prototype;
    proto.dispose = function() {
      this.shader.dispose();
      this.pickShader.dispose();
      this.offsetBuffer.dispose();
      this.pickBuffer.dispose();
      this.plot.removeObject(this);
    };
    proto.update = function(options) {
      var i;
      options = options || {};
      function dflt(opt, value) {
        if (opt in options) {
          return options[opt];
        }
        return value;
      }
      this.sizeMin = dflt("sizeMin", 0.5);
      this.sizeMax = dflt("sizeMax", 20);
      this.color = dflt("color", [1, 0, 0, 1]).slice();
      this.areaRatio = dflt("areaRatio", 1);
      this.borderColor = dflt("borderColor", [0, 0, 0, 1]).slice();
      this.blend = dflt("blend", false);
      var pointCount = options.positions.length >>> 1;
      var dataStraightThrough = options.positions instanceof Float32Array;
      var idStraightThrough = options.idToIndex instanceof Int32Array && options.idToIndex.length >= pointCount;
      var data = options.positions;
      var packed = dataStraightThrough ? data : pool.mallocFloat32(data.length);
      var packedId = idStraightThrough ? options.idToIndex : pool.mallocInt32(pointCount);
      if (!dataStraightThrough) {
        packed.set(data);
      }
      if (!idStraightThrough) {
        packed.set(data);
        for (i = 0; i < pointCount; i++) {
          packedId[i] = i;
        }
      }
      this.points = data;
      this.offsetBuffer.update(packed);
      this.pickBuffer.update(packedId);
      if (!dataStraightThrough) {
        pool.free(packed);
      }
      if (!idStraightThrough) {
        pool.free(packedId);
      }
      this.pointCount = pointCount;
      this.pickOffset = 0;
    };
    function count(points, dataBox) {
      var visiblePointCountEstimate = 0;
      var length = points.length >>> 1;
      var i;
      for (i = 0; i < length; i++) {
        var x = points[i * 2];
        var y = points[i * 2 + 1];
        if (x >= dataBox[0] && x <= dataBox[2] && y >= dataBox[1] && y <= dataBox[3])
          visiblePointCountEstimate++;
      }
      return visiblePointCountEstimate;
    }
    proto.unifiedDraw = /* @__PURE__ */ function() {
      var MATRIX = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      var PICK_VEC4 = [0, 0, 0, 0];
      return function(pickOffset) {
        var pick = pickOffset !== void 0;
        var shader = pick ? this.pickShader : this.shader;
        var gl2 = this.plot.gl;
        var dataBox = this.plot.dataBox;
        if (this.pointCount === 0) {
          return pickOffset;
        }
        var dataX = dataBox[2] - dataBox[0];
        var dataY = dataBox[3] - dataBox[1];
        var visiblePointCountEstimate = count(this.points, dataBox);
        var basicPointSize = this.plot.pickPixelRatio * Math.max(Math.min(this.sizeMinCap, this.sizeMin), Math.min(this.sizeMax, this.sizeMax / Math.pow(visiblePointCountEstimate, 0.33333)));
        MATRIX[0] = 2 / dataX;
        MATRIX[4] = 2 / dataY;
        MATRIX[6] = -2 * dataBox[0] / dataX - 1;
        MATRIX[7] = -2 * dataBox[1] / dataY - 1;
        this.offsetBuffer.bind();
        shader.bind();
        shader.attributes.position.pointer();
        shader.uniforms.matrix = MATRIX;
        shader.uniforms.color = this.color;
        shader.uniforms.borderColor = this.borderColor;
        shader.uniforms.pointCloud = basicPointSize < 5;
        shader.uniforms.pointSize = basicPointSize;
        shader.uniforms.centerFraction = Math.min(1, Math.max(0, Math.sqrt(1 - this.areaRatio)));
        if (pick) {
          PICK_VEC4[0] = pickOffset & 255;
          PICK_VEC4[1] = pickOffset >> 8 & 255;
          PICK_VEC4[2] = pickOffset >> 16 & 255;
          PICK_VEC4[3] = pickOffset >> 24 & 255;
          this.pickBuffer.bind();
          shader.attributes.pickId.pointer(gl2.UNSIGNED_BYTE);
          shader.uniforms.pickOffset = PICK_VEC4;
          this.pickOffset = pickOffset;
        }
        var blend = gl2.getParameter(gl2.BLEND);
        var dither = gl2.getParameter(gl2.DITHER);
        if (blend && !this.blend)
          gl2.disable(gl2.BLEND);
        if (dither)
          gl2.disable(gl2.DITHER);
        gl2.drawArrays(gl2.POINTS, 0, this.pointCount);
        if (blend && !this.blend)
          gl2.enable(gl2.BLEND);
        if (dither)
          gl2.enable(gl2.DITHER);
        return pickOffset + this.pointCount;
      };
    }();
    proto.draw = proto.unifiedDraw;
    proto.drawPick = proto.unifiedDraw;
    proto.pick = function(x, y, value) {
      var pickOffset = this.pickOffset;
      var pointCount = this.pointCount;
      if (value < pickOffset || value >= pickOffset + pointCount) {
        return null;
      }
      var pointId = value - pickOffset;
      var points = this.points;
      return {
        object: this,
        pointId,
        dataCoord: [points[2 * pointId], points[2 * pointId + 1]]
      };
    };
    function createPointcloud2D(plot, options) {
      var gl2 = plot.gl;
      var buffer = createBuffer(gl2);
      var pickBuffer = createBuffer(gl2);
      var shader = createShader(gl2, SHADERS.pointVertex, SHADERS.pointFragment);
      var pickShader = createShader(gl2, SHADERS.pickVertex, SHADERS.pickFragment);
      var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader);
      result.update(options);
      plot.addObject(result);
      return result;
    }
  }
});

// node_modules/is-string-blank/index.js
var require_is_string_blank = __commonJS({
  "node_modules/is-string-blank/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      var l = str.length, a;
      for (var i = 0; i < l; i++) {
        a = str.charCodeAt(i);
        if ((a < 9 || a > 13) && a !== 32 && a !== 133 && a !== 160 && a !== 5760 && a !== 6158 && (a < 8192 || a > 8205) && a !== 8232 && a !== 8233 && a !== 8239 && a !== 8287 && a !== 8288 && a !== 12288 && a !== 65279) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/gl-scatter3d/lib/shaders.js
var require_shaders9 = __commonJS({
  "node_modules/gl-scatter3d/lib/shaders.js"(exports2) {
    var createShaderWrapper = require_gl_shader();
    var glslify = require_browser();
    var perspectiveVertSrc = glslify("./perspective.glsl");
    var orthographicVertSrc = glslify("./orthographic.glsl");
    var projectionVertSrc = glslify("./projection.glsl");
    var drawFragSrc = glslify("./draw-fragment.glsl");
    var pickFragSrc = glslify("./pick-fragment.glsl");
    var ATTRIBUTES = [
      { name: "position", type: "vec3" },
      { name: "color", type: "vec4" },
      { name: "glyph", type: "vec2" },
      { name: "id", type: "vec4" }
    ];
    var perspective = {
      vertex: perspectiveVertSrc,
      fragment: drawFragSrc,
      attributes: ATTRIBUTES
    };
    var ortho = {
      vertex: orthographicVertSrc,
      fragment: drawFragSrc,
      attributes: ATTRIBUTES
    };
    var project = {
      vertex: projectionVertSrc,
      fragment: drawFragSrc,
      attributes: ATTRIBUTES
    };
    var pickPerspective = {
      vertex: perspectiveVertSrc,
      fragment: pickFragSrc,
      attributes: ATTRIBUTES
    };
    var pickOrtho = {
      vertex: orthographicVertSrc,
      fragment: pickFragSrc,
      attributes: ATTRIBUTES
    };
    var pickProject = {
      vertex: projectionVertSrc,
      fragment: pickFragSrc,
      attributes: ATTRIBUTES
    };
    function createShader(gl2, src) {
      var shader = createShaderWrapper(gl2, src);
      var attr = shader.attributes;
      attr.position.location = 0;
      attr.color.location = 1;
      attr.glyph.location = 2;
      attr.id.location = 3;
      return shader;
    }
    exports2.createPerspective = function(gl2) {
      return createShader(gl2, perspective);
    };
    exports2.createOrtho = function(gl2) {
      return createShader(gl2, ortho);
    };
    exports2.createProject = function(gl2) {
      return createShader(gl2, project);
    };
    exports2.createPickPerspective = function(gl2) {
      return createShader(gl2, pickPerspective);
    };
    exports2.createPickOrtho = function(gl2) {
      return createShader(gl2, pickOrtho);
    };
    exports2.createPickProject = function(gl2) {
      return createShader(gl2, pickProject);
    };
  }
});

// node_modules/gl-scatter3d/lib/glyphs.js
var require_glyphs = __commonJS({
  "node_modules/gl-scatter3d/lib/glyphs.js"(exports2, module2) {
    "use strict";
    var vectorizeText = require_vectorize_text();
    module2.exports = getGlyph;
    var GLYPH_CACHE = {};
    function getGlyph(symbol, font, pixelRatio) {
      var fontKey = [
        font.style,
        font.weight,
        font.variant,
        font.family
      ].join("_");
      var fontCache = GLYPH_CACHE[fontKey];
      if (!fontCache) {
        fontCache = GLYPH_CACHE[fontKey] = {};
      }
      if (symbol in fontCache) {
        return fontCache[symbol];
      }
      var config = {
        textAlign: "center",
        textBaseline: "middle",
        lineHeight: 1,
        font: font.family,
        fontStyle: font.style,
        fontWeight: font.weight,
        fontVariant: font.variant,
        lineSpacing: 1.25,
        styletags: {
          breaklines: true,
          bolds: true,
          italics: true,
          subscripts: true,
          superscripts: true
        }
      };
      config.triangles = true;
      var triSymbol = vectorizeText(symbol, config);
      config.triangles = false;
      var lineSymbol = vectorizeText(symbol, config);
      var i, j;
      if (pixelRatio && pixelRatio !== 1) {
        for (i = 0; i < triSymbol.positions.length; ++i) {
          for (j = 0; j < triSymbol.positions[i].length; ++j) {
            triSymbol.positions[i][j] /= pixelRatio;
          }
        }
        for (i = 0; i < lineSymbol.positions.length; ++i) {
          for (j = 0; j < lineSymbol.positions[i].length; ++j) {
            lineSymbol.positions[i][j] /= pixelRatio;
          }
        }
      }
      var bounds = [[Infinity, Infinity], [-Infinity, -Infinity]];
      var n = lineSymbol.positions.length;
      for (i = 0; i < n; ++i) {
        var p = lineSymbol.positions[i];
        for (j = 0; j < 2; ++j) {
          bounds[0][j] = Math.min(bounds[0][j], p[j]);
          bounds[1][j] = Math.max(bounds[1][j], p[j]);
        }
      }
      return fontCache[symbol] = [triSymbol, lineSymbol, bounds];
    }
  }
});

// node_modules/gl-scatter3d/lib/get-simple-string.js
var require_get_simple_string = __commonJS({
  "node_modules/gl-scatter3d/lib/get-simple-string.js"(exports2, module2) {
    "use strict";
    module2.exports = function(a) {
      return !a && a !== 0 ? "" : a.toString();
    };
  }
});

// node_modules/gl-scatter3d/pointcloud.js
var require_pointcloud = __commonJS({
  "node_modules/gl-scatter3d/pointcloud.js"(exports2, module2) {
    "use strict";
    var isAllBlank = require_is_string_blank();
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var pool = require_pool();
    var mat4mult = require_multiply2();
    var shaders = require_shaders9();
    var getGlyph = require_glyphs();
    var getSimpleString = require_get_simple_string();
    var IDENTITY = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    var ab = ArrayBuffer;
    var dv = DataView;
    function isTypedArray(a) {
      return ab.isView(a) && !(a instanceof dv);
    }
    function isArrayOrTypedArray(a) {
      return Array.isArray(a) || isTypedArray(a);
    }
    module2.exports = createPointCloud;
    function transformMat4(x, m) {
      var x0 = x[0];
      var x1 = x[1];
      var x2 = x[2];
      var x3 = x[3];
      x[0] = m[0] * x0 + m[4] * x1 + m[8] * x2 + m[12] * x3;
      x[1] = m[1] * x0 + m[5] * x1 + m[9] * x2 + m[13] * x3;
      x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3;
      x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3;
      return x;
    }
    function project(p, v, m, x) {
      transformMat4(x, x, m);
      transformMat4(x, x, v);
      return transformMat4(x, x, p);
    }
    function ScatterPlotPickResult(index, position) {
      this.index = index;
      this.dataCoordinate = this.position = position;
    }
    function fixOpacity(a) {
      if (a === true) return 1;
      if (a > 1) return 1;
      return a;
    }
    function PointCloud(gl2, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader) {
      this.gl = gl2;
      this.pixelRatio = 1;
      this.shader = shader;
      this.orthoShader = orthoShader;
      this.projectShader = projectShader;
      this.pointBuffer = pointBuffer;
      this.colorBuffer = colorBuffer;
      this.glyphBuffer = glyphBuffer;
      this.idBuffer = idBuffer;
      this.vao = vao;
      this.vertexCount = 0;
      this.lineVertexCount = 0;
      this.opacity = 1;
      this.hasAlpha = false;
      this.lineWidth = 0;
      this.projectScale = [2 / 3, 2 / 3, 2 / 3];
      this.projectOpacity = [1, 1, 1];
      this.projectHasAlpha = false;
      this.pickId = 0;
      this.pickPerspectiveShader = pickPerspectiveShader;
      this.pickOrthoShader = pickOrthoShader;
      this.pickProjectShader = pickProjectShader;
      this.points = [];
      this._selectResult = new ScatterPlotPickResult(0, [0, 0, 0]);
      this.useOrtho = true;
      this.bounds = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      this.axesProject = [true, true, true];
      this.axesBounds = [
        [-Infinity, -Infinity, -Infinity],
        [Infinity, Infinity, Infinity]
      ];
      this.highlightId = [1, 1, 1, 1];
      this.highlightScale = 2;
      this.clipBounds = [
        [-Infinity, -Infinity, -Infinity],
        [Infinity, Infinity, Infinity]
      ];
      this.dirty = true;
    }
    var proto = PointCloud.prototype;
    proto.pickSlots = 1;
    proto.setPickBase = function(pickBase) {
      this.pickId = pickBase;
    };
    proto.isTransparent = function() {
      if (this.hasAlpha) {
        return true;
      }
      for (var i = 0; i < 3; ++i) {
        if (this.axesProject[i] && this.projectHasAlpha) {
          return true;
        }
      }
      return false;
    };
    proto.isOpaque = function() {
      if (!this.hasAlpha) {
        return true;
      }
      for (var i = 0; i < 3; ++i) {
        if (this.axesProject[i] && !this.projectHasAlpha) {
          return true;
        }
      }
      return false;
    };
    var VIEW_SHAPE = [0, 0];
    var U_VEC = [0, 0, 0];
    var V_VEC = [0, 0, 0];
    var MU_VEC = [0, 0, 0, 1];
    var MV_VEC = [0, 0, 0, 1];
    var SCRATCH_MATRIX = IDENTITY.slice();
    var SCRATCH_VEC = [0, 0, 0];
    var CLIP_BOUNDS = [[0, 0, 0], [0, 0, 0]];
    function zeroVec(a) {
      a[0] = a[1] = a[2] = 0;
      return a;
    }
    function augment(hg, af) {
      hg[0] = af[0];
      hg[1] = af[1];
      hg[2] = af[2];
      hg[3] = 1;
      return hg;
    }
    function setComponent(out, v, i, x) {
      out[0] = v[0];
      out[1] = v[1];
      out[2] = v[2];
      out[i] = x;
      return out;
    }
    function getClipBounds(bounds) {
      var result = CLIP_BOUNDS;
      for (var i = 0; i < 2; ++i) {
        for (var j = 0; j < 3; ++j) {
          result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8);
        }
      }
      return result;
    }
    function drawProject(shader, points, camera, pixelRatio) {
      var axesProject = points.axesProject;
      var gl2 = points.gl;
      var uniforms = shader.uniforms;
      var model = camera.model || IDENTITY;
      var view = camera.view || IDENTITY;
      var projection = camera.projection || IDENTITY;
      var bounds = points.axesBounds;
      var clipBounds = getClipBounds(points.clipBounds);
      var cubeAxis;
      if (points.axes && points.axes.lastCubeProps) {
        cubeAxis = points.axes.lastCubeProps.axis;
      } else {
        cubeAxis = [1, 1, 1];
      }
      VIEW_SHAPE[0] = 2 / gl2.drawingBufferWidth;
      VIEW_SHAPE[1] = 2 / gl2.drawingBufferHeight;
      shader.bind();
      uniforms.view = view;
      uniforms.projection = projection;
      uniforms.screenSize = VIEW_SHAPE;
      uniforms.highlightId = points.highlightId;
      uniforms.highlightScale = points.highlightScale;
      uniforms.clipBounds = clipBounds;
      uniforms.pickGroup = points.pickId / 255;
      uniforms.pixelRatio = pixelRatio;
      for (var i = 0; i < 3; ++i) {
        if (!axesProject[i]) {
          continue;
        }
        uniforms.scale = points.projectScale[i];
        uniforms.opacity = points.projectOpacity[i];
        var pmodel = SCRATCH_MATRIX;
        for (var j = 0; j < 16; ++j) {
          pmodel[j] = 0;
        }
        for (var j = 0; j < 4; ++j) {
          pmodel[5 * j] = 1;
        }
        pmodel[5 * i] = 0;
        if (cubeAxis[i] < 0) {
          pmodel[12 + i] = bounds[0][i];
        } else {
          pmodel[12 + i] = bounds[1][i];
        }
        mat4mult(pmodel, model, pmodel);
        uniforms.model = pmodel;
        var u = (i + 1) % 3;
        var v = (i + 2) % 3;
        var du = zeroVec(U_VEC);
        var dv2 = zeroVec(V_VEC);
        du[u] = 1;
        dv2[v] = 1;
        var mdu = project(projection, view, model, augment(MU_VEC, du));
        var mdv = project(projection, view, model, augment(MV_VEC, dv2));
        if (Math.abs(mdu[1]) > Math.abs(mdv[1])) {
          var tmp = mdu;
          mdu = mdv;
          mdv = tmp;
          tmp = du;
          du = dv2;
          dv2 = tmp;
          var t = u;
          u = v;
          v = t;
        }
        if (mdu[0] < 0) {
          du[u] = -1;
        }
        if (mdv[1] > 0) {
          dv2[v] = -1;
        }
        var su = 0;
        var sv = 0;
        for (var j = 0; j < 4; ++j) {
          su += Math.pow(model[4 * u + j], 2);
          sv += Math.pow(model[4 * v + j], 2);
        }
        du[u] /= Math.sqrt(su);
        dv2[v] /= Math.sqrt(sv);
        uniforms.axes[0] = du;
        uniforms.axes[1] = dv2;
        uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8);
        uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8);
        points.vao.bind();
        points.vao.draw(gl2.TRIANGLES, points.vertexCount);
        if (points.lineWidth > 0) {
          gl2.lineWidth(points.lineWidth * pixelRatio);
          points.vao.draw(gl2.LINES, points.lineVertexCount, points.vertexCount);
        }
        points.vao.unbind();
      }
    }
    var NEG_INFINITY3 = [-1e8, -1e8, -1e8];
    var POS_INFINITY3 = [1e8, 1e8, 1e8];
    var CLIP_GROUP = [NEG_INFINITY3, POS_INFINITY3];
    function drawFull(shader, pshader, points, camera, pixelRatio, transparent, forceDraw) {
      var gl2 = points.gl;
      if (transparent === points.projectHasAlpha || forceDraw) {
        drawProject(pshader, points, camera, pixelRatio);
      }
      if (transparent === points.hasAlpha || forceDraw) {
        shader.bind();
        var uniforms = shader.uniforms;
        uniforms.model = camera.model || IDENTITY;
        uniforms.view = camera.view || IDENTITY;
        uniforms.projection = camera.projection || IDENTITY;
        VIEW_SHAPE[0] = 2 / gl2.drawingBufferWidth;
        VIEW_SHAPE[1] = 2 / gl2.drawingBufferHeight;
        uniforms.screenSize = VIEW_SHAPE;
        uniforms.highlightId = points.highlightId;
        uniforms.highlightScale = points.highlightScale;
        uniforms.fragClipBounds = CLIP_GROUP;
        uniforms.clipBounds = points.axes.bounds;
        uniforms.opacity = points.opacity;
        uniforms.pickGroup = points.pickId / 255;
        uniforms.pixelRatio = pixelRatio;
        points.vao.bind();
        points.vao.draw(gl2.TRIANGLES, points.vertexCount);
        if (points.lineWidth > 0) {
          gl2.lineWidth(points.lineWidth * pixelRatio);
          points.vao.draw(gl2.LINES, points.lineVertexCount, points.vertexCount);
        }
        points.vao.unbind();
      }
    }
    proto.draw = function(camera) {
      var shader = this.useOrtho ? this.orthoShader : this.shader;
      drawFull(shader, this.projectShader, this, camera, this.pixelRatio, false, false);
    };
    proto.drawTransparent = function(camera) {
      var shader = this.useOrtho ? this.orthoShader : this.shader;
      drawFull(shader, this.projectShader, this, camera, this.pixelRatio, true, false);
    };
    proto.drawPick = function(camera) {
      var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader;
      drawFull(shader, this.pickProjectShader, this, camera, 1, true, true);
    };
    proto.pick = function(selected) {
      if (!selected) {
        return null;
      }
      if (selected.id !== this.pickId) {
        return null;
      }
      var x = selected.value[2] + (selected.value[1] << 8) + (selected.value[0] << 16);
      if (x >= this.pointCount || x < 0) {
        return null;
      }
      var coord = this.points[x];
      var result = this._selectResult;
      result.index = x;
      for (var i = 0; i < 3; ++i) {
        result.position[i] = result.dataCoordinate[i] = coord[i];
      }
      return result;
    };
    proto.highlight = function(selection) {
      if (!selection) {
        this.highlightId = [1, 1, 1, 1];
      } else {
        var pointId = selection.index;
        var a0 = pointId & 255;
        var a1 = pointId >> 8 & 255;
        var a2 = pointId >> 16 & 255;
        this.highlightId = [a0 / 255, a1 / 255, a2 / 255, 0];
      }
    };
    function get_glyphData(glyphs, index, font, pixelRatio) {
      var str;
      if (isArrayOrTypedArray(glyphs)) {
        if (index < glyphs.length) {
          str = glyphs[index];
        } else {
          str = void 0;
        }
      } else {
        str = glyphs;
      }
      str = getSimpleString(str);
      var visible = true;
      if (isAllBlank(str)) {
        str = "\u25BC";
        visible = false;
      }
      if (!font) font = {};
      var family = font.family;
      if (isArrayOrTypedArray(family)) family = family[index];
      if (!family) family = "normal";
      var weight = font.weight;
      if (isArrayOrTypedArray(weight)) weight = weight[index];
      if (!weight) weight = "normal";
      var style = font.style;
      if (isArrayOrTypedArray(style)) style = style[index];
      if (!style) style = "normal";
      var variant = font.variant;
      if (isArrayOrTypedArray(variant)) variant = variant[index];
      if (!variant) variant = "normal";
      var glyph = getGlyph(str, {
        family,
        weight,
        style,
        variant
      }, pixelRatio);
      var glyph = getGlyph(str, font, pixelRatio);
      return {
        mesh: glyph[0],
        lines: glyph[1],
        bounds: glyph[2],
        visible
      };
    }
    proto.update = function(options) {
      options = options || {};
      if ("perspective" in options) {
        this.useOrtho = !options.perspective;
      }
      if ("orthographic" in options) {
        this.useOrtho = !!options.orthographic;
      }
      if ("lineWidth" in options) {
        this.lineWidth = options.lineWidth;
      }
      if ("project" in options) {
        if (isArrayOrTypedArray(options.project)) {
          this.axesProject = options.project;
        } else {
          var v = !!options.project;
          this.axesProject = [v, v, v];
        }
      }
      if ("projectScale" in options) {
        if (isArrayOrTypedArray(options.projectScale)) {
          this.projectScale = options.projectScale.slice();
        } else {
          var s = +options.projectScale;
          this.projectScale = [s, s, s];
        }
      }
      this.projectHasAlpha = false;
      if ("projectOpacity" in options) {
        if (isArrayOrTypedArray(options.projectOpacity)) {
          this.projectOpacity = options.projectOpacity.slice();
        } else {
          var s = +options.projectOpacity;
          this.projectOpacity = [s, s, s];
        }
        for (var i = 0; i < 3; ++i) {
          this.projectOpacity[i] = fixOpacity(this.projectOpacity[i]);
          if (this.projectOpacity[i] < 1) {
            this.projectHasAlpha = true;
          }
        }
      }
      this.hasAlpha = false;
      if ("opacity" in options) {
        this.opacity = fixOpacity(options.opacity);
        if (this.opacity < 1) {
          this.hasAlpha = true;
        }
      }
      this.dirty = true;
      var points = options.position;
      var font = {
        family: options.font || "normal",
        style: options.fontStyle || "normal",
        weight: options.fontWeight || "normal",
        variant: options.fontVariant || "normal"
      };
      var alignment = options.alignment || [0, 0];
      var alignmentX;
      var alignmentY;
      if (alignment.length === 2) {
        alignmentX = alignment[0];
        alignmentY = alignment[1];
      } else {
        alignmentX = [];
        alignmentY = [];
        for (var i = 0; i < alignment.length; ++i) {
          alignmentX[i] = alignment[i][0];
          alignmentY[i] = alignment[i][1];
        }
      }
      var lowerBound = [Infinity, Infinity, Infinity];
      var upperBound = [-Infinity, -Infinity, -Infinity];
      var glyphs = options.glyph;
      var colors = options.color;
      var sizes = options.size;
      var angles = options.angle;
      var lineColors = options.lineColor;
      var pickCounter = -1;
      var triVertexCount = 0;
      var lineVertexCount = 0;
      var numPoints = 0;
      if (points.length) {
        numPoints = points.length;
        count_loop:
          for (var i = 0; i < numPoints; ++i) {
            var x = points[i];
            for (var j = 0; j < 3; ++j) {
              if (isNaN(x[j]) || !isFinite(x[j])) {
                continue count_loop;
              }
            }
            var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);
            var glyphMesh = glyphData.mesh;
            var glyphLines = glyphData.lines;
            var glyphBounds = glyphData.bounds;
            triVertexCount += glyphMesh.cells.length * 3;
            lineVertexCount += glyphLines.edges.length * 2;
          }
      }
      var vertexCount = triVertexCount + lineVertexCount;
      var positionArray = pool.mallocFloat(3 * vertexCount);
      var colorArray = pool.mallocFloat(4 * vertexCount);
      var glyphArray = pool.mallocFloat(2 * vertexCount);
      var idArray = pool.mallocUint32(vertexCount);
      if (vertexCount > 0) {
        var triOffset = 0;
        var lineOffset = triVertexCount;
        var color = [0, 0, 0, 1];
        var lineColor = [0, 0, 0, 1];
        var isColorArray = isArrayOrTypedArray(colors) && isArrayOrTypedArray(colors[0]);
        var isLineColorArray = isArrayOrTypedArray(lineColors) && isArrayOrTypedArray(lineColors[0]);
        fill_loop:
          for (var i = 0; i < numPoints; ++i) {
            pickCounter += 1;
            var x = points[i];
            for (var j = 0; j < 3; ++j) {
              if (isNaN(x[j]) || !isFinite(x[j])) {
                continue fill_loop;
              }
              upperBound[j] = Math.max(upperBound[j], x[j]);
              lowerBound[j] = Math.min(lowerBound[j], x[j]);
            }
            var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);
            var glyphMesh = glyphData.mesh;
            var glyphLines = glyphData.lines;
            var glyphBounds = glyphData.bounds;
            var glyphVisible = glyphData.visible;
            if (!glyphVisible) color = [1, 1, 1, 0];
            else if (isArrayOrTypedArray(colors)) {
              var c;
              if (isColorArray) {
                if (i < colors.length) {
                  c = colors[i];
                } else {
                  c = [0, 0, 0, 0];
                }
              } else {
                c = colors;
              }
              if (c.length === 3) {
                for (var j = 0; j < 3; ++j) {
                  color[j] = c[j];
                }
                color[3] = 1;
              } else if (c.length === 4) {
                for (var j = 0; j < 4; ++j) {
                  color[j] = c[j];
                }
                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;
              }
            } else {
              color[0] = color[1] = color[2] = 0;
              color[3] = 1;
            }
            if (!glyphVisible) lineColor = [1, 1, 1, 0];
            else if (isArrayOrTypedArray(lineColors)) {
              var c;
              if (isLineColorArray) {
                if (i < lineColors.length) {
                  c = lineColors[i];
                } else {
                  c = [0, 0, 0, 0];
                }
              } else {
                c = lineColors;
              }
              if (c.length === 3) {
                for (var j = 0; j < 3; ++j) {
                  lineColor[j] = c[j];
                }
                lineColor[j] = 1;
              } else if (c.length === 4) {
                for (var j = 0; j < 4; ++j) {
                  lineColor[j] = c[j];
                }
                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;
              }
            } else {
              lineColor[0] = lineColor[1] = lineColor[2] = 0;
              lineColor[3] = 1;
            }
            var size = 0.5;
            if (!glyphVisible) size = 0;
            else if (isArrayOrTypedArray(sizes)) {
              if (i < sizes.length) {
                size = +sizes[i];
              } else {
                size = 12;
              }
            } else if (sizes) {
              size = +sizes;
            } else if (this.useOrtho) {
              size = 12;
            }
            var angle = 0;
            if (isArrayOrTypedArray(angles)) {
              if (i < angles.length) {
                angle = +angles[i];
              } else {
                angle = 0;
              }
            } else if (angles) {
              angle = +angles;
            }
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var x = points[i];
            for (var j = 0; j < 3; ++j) {
              upperBound[j] = Math.max(upperBound[j], x[j]);
              lowerBound[j] = Math.min(lowerBound[j], x[j]);
            }
            var textOffsetX = alignmentX;
            var textOffsetY = alignmentY;
            var textOffsetX = 0;
            if (isArrayOrTypedArray(alignmentX)) {
              if (i < alignmentX.length) {
                textOffsetX = alignmentX[i];
              } else {
                textOffsetX = 0;
              }
            } else if (alignmentX) {
              textOffsetX = alignmentX;
            }
            var textOffsetY = 0;
            if (isArrayOrTypedArray(alignmentY)) {
              if (i < alignmentY.length) {
                textOffsetY = alignmentY[i];
              } else {
                textOffsetY = 0;
              }
            } else if (alignmentY) {
              textOffsetY = alignmentY;
            }
            textOffsetX *= textOffsetX > 0 ? 1 - glyphBounds[0][0] : textOffsetX < 0 ? 1 + glyphBounds[1][0] : 1;
            textOffsetY *= textOffsetY > 0 ? 1 - glyphBounds[0][1] : textOffsetY < 0 ? 1 + glyphBounds[1][1] : 1;
            var textOffset = [textOffsetX, textOffsetY];
            var cells = glyphMesh.cells || [];
            var verts = glyphMesh.positions || [];
            for (var j = 0; j < cells.length; ++j) {
              var cell = cells[j];
              for (var k = 0; k < 3; ++k) {
                for (var l = 0; l < 3; ++l) {
                  positionArray[3 * triOffset + l] = x[l];
                }
                for (var l = 0; l < 4; ++l) {
                  colorArray[4 * triOffset + l] = color[l];
                }
                idArray[triOffset] = pickCounter;
                var p = verts[cell[k]];
                glyphArray[2 * triOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);
                glyphArray[2 * triOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);
                triOffset += 1;
              }
            }
            var cells = glyphLines.edges;
            var verts = glyphLines.positions;
            for (var j = 0; j < cells.length; ++j) {
              var cell = cells[j];
              for (var k = 0; k < 2; ++k) {
                for (var l = 0; l < 3; ++l) {
                  positionArray[3 * lineOffset + l] = x[l];
                }
                for (var l = 0; l < 4; ++l) {
                  colorArray[4 * lineOffset + l] = lineColor[l];
                }
                idArray[lineOffset] = pickCounter;
                var p = verts[cell[k]];
                glyphArray[2 * lineOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);
                glyphArray[2 * lineOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);
                lineOffset += 1;
              }
            }
          }
      }
      this.bounds = [lowerBound, upperBound];
      this.points = points;
      this.pointCount = points.length;
      this.vertexCount = triVertexCount;
      this.lineVertexCount = lineVertexCount;
      this.pointBuffer.update(positionArray);
      this.colorBuffer.update(colorArray);
      this.glyphBuffer.update(glyphArray);
      this.idBuffer.update(idArray);
      pool.free(positionArray);
      pool.free(colorArray);
      pool.free(glyphArray);
      pool.free(idArray);
    };
    proto.dispose = function() {
      this.shader.dispose();
      this.orthoShader.dispose();
      this.pickPerspectiveShader.dispose();
      this.pickOrthoShader.dispose();
      this.vao.dispose();
      this.pointBuffer.dispose();
      this.colorBuffer.dispose();
      this.glyphBuffer.dispose();
      this.idBuffer.dispose();
    };
    function createPointCloud(options) {
      var gl2 = options.gl;
      var shader = shaders.createPerspective(gl2);
      var orthoShader = shaders.createOrtho(gl2);
      var projectShader = shaders.createProject(gl2);
      var pickPerspectiveShader = shaders.createPickPerspective(gl2);
      var pickOrthoShader = shaders.createPickOrtho(gl2);
      var pickProjectShader = shaders.createPickProject(gl2);
      var pointBuffer = createBuffer(gl2);
      var colorBuffer = createBuffer(gl2);
      var glyphBuffer = createBuffer(gl2);
      var idBuffer = createBuffer(gl2);
      var vao = createVAO(gl2, [
        {
          buffer: pointBuffer,
          size: 3,
          type: gl2.FLOAT
        },
        {
          buffer: colorBuffer,
          size: 4,
          type: gl2.FLOAT
        },
        {
          buffer: glyphBuffer,
          size: 2,
          type: gl2.FLOAT
        },
        {
          buffer: idBuffer,
          size: 4,
          type: gl2.UNSIGNED_BYTE,
          normalized: true
        }
      ]);
      var pointCloud = new PointCloud(
        gl2,
        shader,
        orthoShader,
        projectShader,
        pointBuffer,
        colorBuffer,
        glyphBuffer,
        idBuffer,
        vao,
        pickPerspectiveShader,
        pickOrthoShader,
        pickProjectShader
      );
      pointCloud.update(options);
      return pointCloud;
    }
  }
});

// node_modules/gl-select-box/lib/shaders.js
var require_shaders10 = __commonJS({
  "node_modules/gl-select-box/lib/shaders.js"(exports2) {
    "use strict";
    var glslify = require_browser();
    exports2.boxVertex = glslify("./shaders/box-vertex.glsl");
    exports2.boxFragment = glslify("./shaders/box-fragment.glsl");
  }
});

// node_modules/gl-select-box/selectbox.js
var require_selectbox = __commonJS({
  "node_modules/gl-select-box/selectbox.js"(exports2, module2) {
    "use strict";
    var createShader = require_gl_shader();
    var createBuffer = require_buffer2();
    var SHADERS = require_shaders10();
    module2.exports = createSelectBox;
    function SelectBox(plot, boxBuffer, boxShader) {
      this.plot = plot;
      this.boxBuffer = boxBuffer;
      this.boxShader = boxShader;
      this.enabled = true;
      this.selectBox = [Infinity, Infinity, -Infinity, -Infinity];
      this.borderColor = [0, 0, 0, 1];
      this.innerFill = false;
      this.innerColor = [0, 0, 0, 0.25];
      this.outerFill = true;
      this.outerColor = [0, 0, 0, 0.5];
      this.borderWidth = 10;
    }
    var proto = SelectBox.prototype;
    proto.draw = function() {
      if (!this.enabled) {
        return;
      }
      var plot = this.plot;
      var selectBox = this.selectBox;
      var lineWidth = this.borderWidth;
      var innerFill = this.innerFill;
      var innerColor = this.innerColor;
      var outerFill = this.outerFill;
      var outerColor = this.outerColor;
      var borderColor = this.borderColor;
      var boxes = plot.box;
      var screenBox = plot.screenBox;
      var dataBox = plot.dataBox;
      var viewBox = plot.viewBox;
      var pixelRatio = plot.pixelRatio;
      var loX = (selectBox[0] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];
      var loY = (selectBox[1] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];
      var hiX = (selectBox[2] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];
      var hiY = (selectBox[3] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];
      loX = Math.max(loX, viewBox[0]);
      loY = Math.max(loY, viewBox[1]);
      hiX = Math.min(hiX, viewBox[2]);
      hiY = Math.min(hiY, viewBox[3]);
      if (hiX < loX || hiY < loY) {
        return;
      }
      boxes.bind();
      var screenWidth = screenBox[2] - screenBox[0];
      var screenHeight = screenBox[3] - screenBox[1];
      if (this.outerFill) {
        boxes.drawBox(0, 0, screenWidth, loY, outerColor);
        boxes.drawBox(0, loY, loX, hiY, outerColor);
        boxes.drawBox(0, hiY, screenWidth, screenHeight, outerColor);
        boxes.drawBox(hiX, loY, screenWidth, hiY, outerColor);
      }
      if (this.innerFill) {
        boxes.drawBox(loX, loY, hiX, hiY, innerColor);
      }
      if (lineWidth > 0) {
        var w = lineWidth * pixelRatio;
        boxes.drawBox(loX - w, loY - w, hiX + w, loY + w, borderColor);
        boxes.drawBox(loX - w, hiY - w, hiX + w, hiY + w, borderColor);
        boxes.drawBox(loX - w, loY - w, loX + w, hiY + w, borderColor);
        boxes.drawBox(hiX - w, loY - w, hiX + w, hiY + w, borderColor);
      }
    };
    proto.update = function(options) {
      options = options || {};
      this.innerFill = !!options.innerFill;
      this.outerFill = !!options.outerFill;
      this.innerColor = (options.innerColor || [0, 0, 0, 0.5]).slice();
      this.outerColor = (options.outerColor || [0, 0, 0, 0.5]).slice();
      this.borderColor = (options.borderColor || [0, 0, 0, 1]).slice();
      this.borderWidth = options.borderWidth || 0;
      this.selectBox = (options.selectBox || this.selectBox).slice();
    };
    proto.dispose = function() {
      this.boxBuffer.dispose();
      this.boxShader.dispose();
      this.plot.removeOverlay(this);
    };
    function createSelectBox(plot, options) {
      var gl2 = plot.gl;
      var buffer = createBuffer(gl2, [
        0,
        0,
        0,
        1,
        1,
        0,
        1,
        1
      ]);
      var shader = createShader(gl2, SHADERS.boxVertex, SHADERS.boxFragment);
      var selectBox = new SelectBox(plot, buffer, shader);
      selectBox.update(options);
      plot.addOverlay(selectBox);
      return selectBox;
    }
  }
});

// node_modules/gl-spikes2d/spikes.js
var require_spikes2 = __commonJS({
  "node_modules/gl-spikes2d/spikes.js"(exports2, module2) {
    "use strict";
    module2.exports = createSpikes2D;
    function GLSpikes2D(plot) {
      this.plot = plot;
      this.enable = [true, true, false, false];
      this.width = [1, 1, 1, 1];
      this.color = [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ];
      this.center = [Infinity, Infinity];
    }
    var proto = GLSpikes2D.prototype;
    proto.update = function(options) {
      options = options || {};
      this.enable = (options.enable || [true, true, false, false]).slice();
      this.width = (options.width || [1, 1, 1, 1]).slice();
      this.color = (options.color || [
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 1]
      ]).map(function(x) {
        return x.slice();
      });
      this.center = (options.center || [Infinity, Infinity]).slice();
      this.plot.setOverlayDirty();
    };
    proto.draw = function() {
      var spikeEnable = this.enable;
      var spikeWidth = this.width;
      var spikeColor = this.color;
      var spikeCenter = this.center;
      var plot = this.plot;
      var line = plot.line;
      var dataBox = plot.dataBox;
      var viewPixels = plot.viewBox;
      line.bind();
      if (dataBox[0] <= spikeCenter[0] && spikeCenter[0] <= dataBox[2] && dataBox[1] <= spikeCenter[1] && spikeCenter[1] <= dataBox[3]) {
        var centerX = viewPixels[0] + (spikeCenter[0] - dataBox[0]) / (dataBox[2] - dataBox[0]) * (viewPixels[2] - viewPixels[0]);
        var centerY = viewPixels[1] + (spikeCenter[1] - dataBox[1]) / (dataBox[3] - dataBox[1]) * (viewPixels[3] - viewPixels[1]);
        if (spikeEnable[0]) {
          line.drawLine(
            centerX,
            centerY,
            viewPixels[0],
            centerY,
            spikeWidth[0],
            spikeColor[0]
          );
        }
        if (spikeEnable[1]) {
          line.drawLine(
            centerX,
            centerY,
            centerX,
            viewPixels[1],
            spikeWidth[1],
            spikeColor[1]
          );
        }
        if (spikeEnable[2]) {
          line.drawLine(
            centerX,
            centerY,
            viewPixels[2],
            centerY,
            spikeWidth[2],
            spikeColor[2]
          );
        }
        if (spikeEnable[3]) {
          line.drawLine(
            centerX,
            centerY,
            centerX,
            viewPixels[3],
            spikeWidth[3],
            spikeColor[3]
          );
        }
      }
    };
    proto.dispose = function() {
      this.plot.removeOverlay(this);
    };
    function createSpikes2D(plot, options) {
      var spikes = new GLSpikes2D(plot);
      spikes.update(options);
      plot.addOverlay(spikes);
      return spikes;
    }
  }
});

// node_modules/gl-vec4/create.js
var require_create3 = __commonJS({
  "node_modules/gl-vec4/create.js"(exports2, module2) {
    module2.exports = create;
    function create() {
      var out = new Float32Array(4);
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      return out;
    }
  }
});

// node_modules/gl-vec4/clone.js
var require_clone3 = __commonJS({
  "node_modules/gl-vec4/clone.js"(exports2, module2) {
    module2.exports = clone;
    function clone(a) {
      var out = new Float32Array(4);
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/fromValues.js
var require_fromValues2 = __commonJS({
  "node_modules/gl-vec4/fromValues.js"(exports2, module2) {
    module2.exports = fromValues;
    function fromValues(x, y, z, w) {
      var out = new Float32Array(4);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      out[3] = w;
      return out;
    }
  }
});

// node_modules/gl-vec4/copy.js
var require_copy2 = __commonJS({
  "node_modules/gl-vec4/copy.js"(exports2, module2) {
    module2.exports = copy;
    function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/set.js
var require_set2 = __commonJS({
  "node_modules/gl-vec4/set.js"(exports2, module2) {
    module2.exports = set;
    function set(out, x, y, z, w) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      out[3] = w;
      return out;
    }
  }
});

// node_modules/gl-vec4/add.js
var require_add4 = __commonJS({
  "node_modules/gl-vec4/add.js"(exports2, module2) {
    module2.exports = add;
    function add(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      out[3] = a[3] + b[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/subtract.js
var require_subtract2 = __commonJS({
  "node_modules/gl-vec4/subtract.js"(exports2, module2) {
    module2.exports = subtract;
    function subtract(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      out[3] = a[3] - b[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/multiply.js
var require_multiply3 = __commonJS({
  "node_modules/gl-vec4/multiply.js"(exports2, module2) {
    module2.exports = multiply;
    function multiply(out, a, b) {
      out[0] = a[0] * b[0];
      out[1] = a[1] * b[1];
      out[2] = a[2] * b[2];
      out[3] = a[3] * b[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/divide.js
var require_divide2 = __commonJS({
  "node_modules/gl-vec4/divide.js"(exports2, module2) {
    module2.exports = divide;
    function divide(out, a, b) {
      out[0] = a[0] / b[0];
      out[1] = a[1] / b[1];
      out[2] = a[2] / b[2];
      out[3] = a[3] / b[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/min.js
var require_min2 = __commonJS({
  "node_modules/gl-vec4/min.js"(exports2, module2) {
    module2.exports = min;
    function min(out, a, b) {
      out[0] = Math.min(a[0], b[0]);
      out[1] = Math.min(a[1], b[1]);
      out[2] = Math.min(a[2], b[2]);
      out[3] = Math.min(a[3], b[3]);
      return out;
    }
  }
});

// node_modules/gl-vec4/max.js
var require_max2 = __commonJS({
  "node_modules/gl-vec4/max.js"(exports2, module2) {
    module2.exports = max;
    function max(out, a, b) {
      out[0] = Math.max(a[0], b[0]);
      out[1] = Math.max(a[1], b[1]);
      out[2] = Math.max(a[2], b[2]);
      out[3] = Math.max(a[3], b[3]);
      return out;
    }
  }
});

// node_modules/gl-vec4/scale.js
var require_scale3 = __commonJS({
  "node_modules/gl-vec4/scale.js"(exports2, module2) {
    module2.exports = scale;
    function scale(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      out[3] = a[3] * b;
      return out;
    }
  }
});

// node_modules/gl-vec4/scaleAndAdd.js
var require_scaleAndAdd2 = __commonJS({
  "node_modules/gl-vec4/scaleAndAdd.js"(exports2, module2) {
    module2.exports = scaleAndAdd;
    function scaleAndAdd(out, a, b, scale) {
      out[0] = a[0] + b[0] * scale;
      out[1] = a[1] + b[1] * scale;
      out[2] = a[2] + b[2] * scale;
      out[3] = a[3] + b[3] * scale;
      return out;
    }
  }
});

// node_modules/gl-vec4/distance.js
var require_distance2 = __commonJS({
  "node_modules/gl-vec4/distance.js"(exports2, module2) {
    module2.exports = distance;
    function distance(a, b) {
      var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
  }
});

// node_modules/gl-vec4/squaredDistance.js
var require_squaredDistance2 = __commonJS({
  "node_modules/gl-vec4/squaredDistance.js"(exports2, module2) {
    module2.exports = squaredDistance;
    function squaredDistance(a, b) {
      var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
      return x * x + y * y + z * z + w * w;
    }
  }
});

// node_modules/gl-vec4/length.js
var require_length2 = __commonJS({
  "node_modules/gl-vec4/length.js"(exports2, module2) {
    module2.exports = length;
    function length(a) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      return Math.sqrt(x * x + y * y + z * z + w * w);
    }
  }
});

// node_modules/gl-vec4/squaredLength.js
var require_squaredLength2 = __commonJS({
  "node_modules/gl-vec4/squaredLength.js"(exports2, module2) {
    module2.exports = squaredLength;
    function squaredLength(a) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      return x * x + y * y + z * z + w * w;
    }
  }
});

// node_modules/gl-vec4/negate.js
var require_negate2 = __commonJS({
  "node_modules/gl-vec4/negate.js"(exports2, module2) {
    module2.exports = negate;
    function negate(out, a) {
      out[0] = -a[0];
      out[1] = -a[1];
      out[2] = -a[2];
      out[3] = -a[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/inverse.js
var require_inverse2 = __commonJS({
  "node_modules/gl-vec4/inverse.js"(exports2, module2) {
    module2.exports = inverse;
    function inverse(out, a) {
      out[0] = 1 / a[0];
      out[1] = 1 / a[1];
      out[2] = 1 / a[2];
      out[3] = 1 / a[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/normalize.js
var require_normalize3 = __commonJS({
  "node_modules/gl-vec4/normalize.js"(exports2, module2) {
    module2.exports = normalize;
    function normalize(out, a) {
      var x = a[0], y = a[1], z = a[2], w = a[3];
      var len = x * x + y * y + z * z + w * w;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
      }
      return out;
    }
  }
});

// node_modules/gl-vec4/dot.js
var require_dot2 = __commonJS({
  "node_modules/gl-vec4/dot.js"(exports2, module2) {
    module2.exports = dot;
    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
  }
});

// node_modules/gl-vec4/lerp.js
var require_lerp3 = __commonJS({
  "node_modules/gl-vec4/lerp.js"(exports2, module2) {
    module2.exports = lerp;
    function lerp(out, a, b, t) {
      var ax = a[0], ay = a[1], az = a[2], aw = a[3];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      out[3] = aw + t * (b[3] - aw);
      return out;
    }
  }
});

// node_modules/gl-vec4/random.js
var require_random2 = __commonJS({
  "node_modules/gl-vec4/random.js"(exports2, module2) {
    var vecNormalize = require_normalize3();
    var vecScale = require_scale3();
    module2.exports = random;
    function random(out, scale) {
      scale = scale || 1;
      out[0] = Math.random();
      out[1] = Math.random();
      out[2] = Math.random();
      out[3] = Math.random();
      vecNormalize(out, out);
      vecScale(out, out, scale);
      return out;
    }
  }
});

// node_modules/gl-vec4/transformQuat.js
var require_transformQuat2 = __commonJS({
  "node_modules/gl-vec4/transformQuat.js"(exports2, module2) {
    module2.exports = transformQuat;
    function transformQuat(out, a, q) {
      var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
      out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      out[3] = a[3];
      return out;
    }
  }
});

// node_modules/gl-vec4/index.js
var require_gl_vec4 = __commonJS({
  "node_modules/gl-vec4/index.js"(exports2, module2) {
    module2.exports = {
      create: require_create3(),
      clone: require_clone3(),
      fromValues: require_fromValues2(),
      copy: require_copy2(),
      set: require_set2(),
      add: require_add4(),
      subtract: require_subtract2(),
      multiply: require_multiply3(),
      divide: require_divide2(),
      min: require_min2(),
      max: require_max2(),
      scale: require_scale3(),
      scaleAndAdd: require_scaleAndAdd2(),
      distance: require_distance2(),
      squaredDistance: require_squaredDistance2(),
      length: require_length2(),
      squaredLength: require_squaredLength2(),
      negate: require_negate2(),
      inverse: require_inverse2(),
      normalize: require_normalize3(),
      dot: require_dot2(),
      lerp: require_lerp3(),
      random: require_random2(),
      transformMat4: require_transformMat42(),
      transformQuat: require_transformQuat2()
    };
  }
});

// node_modules/gl-streamtube3d/lib/shaders.js
var require_shaders11 = __commonJS({
  "node_modules/gl-streamtube3d/lib/shaders.js"(exports2) {
    var glslify = require_browser();
    var triVertSrc = glslify("./triangle-vertex.glsl");
    var triFragSrc = glslify("./triangle-fragment.glsl");
    var pickVertSrc = glslify("./pick-vertex.glsl");
    var pickFragSrc = glslify("./pick-fragment.glsl");
    exports2.meshShader = {
      vertex: triVertSrc,
      fragment: triFragSrc,
      attributes: [
        { name: "position", type: "vec4" },
        { name: "color", type: "vec4" },
        { name: "uv", type: "vec2" },
        { name: "vector", type: "vec4" }
      ]
    };
    exports2.pickShader = {
      vertex: pickVertSrc,
      fragment: pickFragSrc,
      attributes: [
        { name: "position", type: "vec4" },
        { name: "id", type: "vec4" },
        { name: "vector", type: "vec4" }
      ]
    };
  }
});

// node_modules/gl-streamtube3d/streamtube.js
var require_streamtube = __commonJS({
  "node_modules/gl-streamtube3d/streamtube.js"(exports2, module2) {
    "use strict";
    var vec3 = require_gl_vec3();
    var vec4 = require_gl_vec4();
    var GRID_TYPES = ["xyz", "xzy", "yxz", "yzx", "zxy", "zyx"];
    var streamToTube = function(stream, maxDivergence, minDistance, maxNorm) {
      var points = stream.points;
      var velocities = stream.velocities;
      var divergences = stream.divergences;
      var verts = [];
      var faces = [];
      var vectors = [];
      var previousVerts = [];
      var currentVerts = [];
      var intensities = [];
      var previousIntensity = 0;
      var currentIntensity = 0;
      var currentVector = vec4.create();
      var previousVector = vec4.create();
      var facets = 8;
      for (var i = 0; i < points.length; i++) {
        var p = points[i];
        var fwd = velocities[i];
        var r = divergences[i];
        if (maxDivergence === 0) {
          r = minDistance * 0.05;
        }
        currentIntensity = vec3.length(fwd) / maxNorm;
        currentVector = vec4.create();
        vec3.copy(currentVector, fwd);
        currentVector[3] = r;
        for (var a = 0; a < facets; a++) {
          currentVerts[a] = [p[0], p[1], p[2], a];
        }
        if (previousVerts.length > 0) {
          for (var a = 0; a < facets; a++) {
            var a1 = (a + 1) % facets;
            verts.push(
              previousVerts[a],
              currentVerts[a],
              currentVerts[a1],
              currentVerts[a1],
              previousVerts[a1],
              previousVerts[a]
            );
            vectors.push(
              previousVector,
              currentVector,
              currentVector,
              currentVector,
              previousVector,
              previousVector
            );
            intensities.push(
              previousIntensity,
              currentIntensity,
              currentIntensity,
              currentIntensity,
              previousIntensity,
              previousIntensity
            );
            var len = verts.length;
            faces.push(
              [len - 6, len - 5, len - 4],
              [len - 3, len - 2, len - 1]
            );
          }
        }
        var tmp1 = previousVerts;
        previousVerts = currentVerts;
        currentVerts = tmp1;
        var tmp2 = previousVector;
        previousVector = currentVector;
        currentVector = tmp2;
        var tmp3 = previousIntensity;
        previousIntensity = currentIntensity;
        currentIntensity = tmp3;
      }
      return {
        positions: verts,
        cells: faces,
        vectors,
        vertexIntensity: intensities
      };
    };
    var createTubes = function(streams, colormap, maxDivergence, minDistance) {
      var maxNorm = 0;
      for (var i = 0; i < streams.length; i++) {
        var velocities = streams[i].velocities;
        for (var j = 0; j < velocities.length; j++) {
          maxNorm = Math.max(
            maxNorm,
            vec3.length(velocities[j])
          );
        }
      }
      var tubes = streams.map(function(s) {
        return streamToTube(s, maxDivergence, minDistance, maxNorm);
      });
      var positions = [];
      var cells = [];
      var vectors = [];
      var vertexIntensity = [];
      for (var i = 0; i < tubes.length; i++) {
        var tube = tubes[i];
        var offset = positions.length;
        positions = positions.concat(tube.positions);
        vectors = vectors.concat(tube.vectors);
        vertexIntensity = vertexIntensity.concat(tube.vertexIntensity);
        for (var j = 0; j < tube.cells.length; j++) {
          var cell = tube.cells[j];
          var newCell = [];
          cells.push(newCell);
          for (var k = 0; k < cell.length; k++) {
            newCell.push(cell[k] + offset);
          }
        }
      }
      return {
        positions,
        cells,
        vectors,
        vertexIntensity,
        colormap
      };
    };
    var findLastSmallerIndex = function(points, v) {
      var len = points.length;
      var i;
      for (i = 0; i < len; i++) {
        var p = points[i];
        if (p === v) return i;
        else if (p > v) return i - 1;
      }
      return i;
    };
    var clamp = function(v, min, max) {
      return v < min ? min : v > max ? max : v;
    };
    var sampleMeshgrid = function(point, vectorField, gridInfo) {
      var vectors = vectorField.vectors;
      var meshgrid = vectorField.meshgrid;
      var x = point[0];
      var y = point[1];
      var z = point[2];
      var w = meshgrid[0].length;
      var h = meshgrid[1].length;
      var d = meshgrid[2].length;
      var x0 = findLastSmallerIndex(meshgrid[0], x);
      var y0 = findLastSmallerIndex(meshgrid[1], y);
      var z0 = findLastSmallerIndex(meshgrid[2], z);
      var x1 = x0 + 1;
      var y1 = y0 + 1;
      var z1 = z0 + 1;
      x0 = clamp(x0, 0, w - 1);
      x1 = clamp(x1, 0, w - 1);
      y0 = clamp(y0, 0, h - 1);
      y1 = clamp(y1, 0, h - 1);
      z0 = clamp(z0, 0, d - 1);
      z1 = clamp(z1, 0, d - 1);
      if (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w - 1 || y1 > h - 1 || z1 > d - 1) {
        return vec3.create();
      }
      var mX0 = meshgrid[0][x0];
      var mX1 = meshgrid[0][x1];
      var mY0 = meshgrid[1][y0];
      var mY1 = meshgrid[1][y1];
      var mZ0 = meshgrid[2][z0];
      var mZ1 = meshgrid[2][z1];
      var xf = (x - mX0) / (mX1 - mX0);
      var yf = (y - mY0) / (mY1 - mY0);
      var zf = (z - mZ0) / (mZ1 - mZ0);
      if (!isFinite(xf)) xf = 0.5;
      if (!isFinite(yf)) yf = 0.5;
      if (!isFinite(zf)) zf = 0.5;
      var x0off;
      var x1off;
      var y0off;
      var y1off;
      var z0off;
      var z1off;
      if (gridInfo.reversedX) {
        x0 = w - 1 - x0;
        x1 = w - 1 - x1;
      }
      if (gridInfo.reversedY) {
        y0 = h - 1 - y0;
        y1 = h - 1 - y1;
      }
      if (gridInfo.reversedZ) {
        z0 = d - 1 - z0;
        z1 = d - 1 - z1;
      }
      switch (gridInfo.filled) {
        case 5:
          z0off = z0;
          z1off = z1;
          y0off = y0 * d;
          y1off = y1 * d;
          x0off = x0 * d * h;
          x1off = x1 * d * h;
          break;
        case 4:
          z0off = z0;
          z1off = z1;
          x0off = x0 * d;
          x1off = x1 * d;
          y0off = y0 * d * w;
          y1off = y1 * d * w;
          break;
        case 3:
          y0off = y0;
          y1off = y1;
          z0off = z0 * h;
          z1off = z1 * h;
          x0off = x0 * h * d;
          x1off = x1 * h * d;
          break;
        case 2:
          y0off = y0;
          y1off = y1;
          x0off = x0 * h;
          x1off = x1 * h;
          z0off = z0 * h * w;
          z1off = z1 * h * w;
          break;
        case 1:
          x0off = x0;
          x1off = x1;
          z0off = z0 * w;
          z1off = z1 * w;
          y0off = y0 * w * d;
          y1off = y1 * w * d;
          break;
        default:
          x0off = x0;
          x1off = x1;
          y0off = y0 * w;
          y1off = y1 * w;
          z0off = z0 * w * h;
          z1off = z1 * w * h;
          break;
      }
      var v000 = vectors[x0off + y0off + z0off];
      var v001 = vectors[x0off + y0off + z1off];
      var v010 = vectors[x0off + y1off + z0off];
      var v011 = vectors[x0off + y1off + z1off];
      var v100 = vectors[x1off + y0off + z0off];
      var v101 = vectors[x1off + y0off + z1off];
      var v110 = vectors[x1off + y1off + z0off];
      var v111 = vectors[x1off + y1off + z1off];
      var c00 = vec3.create();
      var c01 = vec3.create();
      var c10 = vec3.create();
      var c11 = vec3.create();
      vec3.lerp(c00, v000, v100, xf);
      vec3.lerp(c01, v001, v101, xf);
      vec3.lerp(c10, v010, v110, xf);
      vec3.lerp(c11, v011, v111, xf);
      var c0 = vec3.create();
      var c1 = vec3.create();
      vec3.lerp(c0, c00, c10, yf);
      vec3.lerp(c1, c01, c11, yf);
      var c = vec3.create();
      vec3.lerp(c, c0, c1, zf);
      return c;
    };
    var findMinSeparation = function(xs) {
      var minSeparation = Infinity;
      xs.sort(function(a, b) {
        return a - b;
      });
      var len = xs.length;
      for (var i = 1; i < len; i++) {
        var d = Math.abs(xs[i] - xs[i - 1]);
        if (d < minSeparation) {
          minSeparation = d;
        }
      }
      return minSeparation;
    };
    var calculateMinPositionDistance = function(positions) {
      var xs = [], ys = [], zs = [];
      var xi = {}, yi = {}, zi = {};
      var len = positions.length;
      for (var i = 0; i < len; i++) {
        var p = positions[i];
        var x = p[0], y = p[1], z = p[2];
        if (!xi[x]) {
          xs.push(x);
          xi[x] = true;
        }
        if (!yi[y]) {
          ys.push(y);
          yi[y] = true;
        }
        if (!zi[z]) {
          zs.push(z);
          zi[z] = true;
        }
      }
      var xSep = findMinSeparation(xs);
      var ySep = findMinSeparation(ys);
      var zSep = findMinSeparation(zs);
      var minSeparation = Math.min(xSep, ySep, zSep);
      return isFinite(minSeparation) ? minSeparation : 1;
    };
    module2.exports = function(vectorField, bounds) {
      var positions = vectorField.startingPositions;
      var maxLength = vectorField.maxLength || 1e3;
      var tubeSize = vectorField.tubeSize || 1;
      var absoluteTubeSize = vectorField.absoluteTubeSize;
      var gridFill = vectorField.gridFill || "+x+y+z";
      var gridInfo = {};
      if (gridFill.indexOf("-x") !== -1) {
        gridInfo.reversedX = true;
      }
      if (gridFill.indexOf("-y") !== -1) {
        gridInfo.reversedY = true;
      }
      if (gridFill.indexOf("-z") !== -1) {
        gridInfo.reversedZ = true;
      }
      gridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, "").replace(/\+/g, ""));
      var getVelocity = vectorField.getVelocity || function(p2) {
        return sampleMeshgrid(p2, vectorField, gridInfo);
      };
      var getDivergence = vectorField.getDivergence || function(p2, v0) {
        var dp = vec3.create();
        var e = 1e-4;
        vec3.add(dp, p2, [e, 0, 0]);
        var vx = getVelocity(dp);
        vec3.subtract(vx, vx, v0);
        vec3.scale(vx, vx, 1 / e);
        vec3.add(dp, p2, [0, e, 0]);
        var vy = getVelocity(dp);
        vec3.subtract(vy, vy, v0);
        vec3.scale(vy, vy, 1 / e);
        vec3.add(dp, p2, [0, 0, e]);
        var vz = getVelocity(dp);
        vec3.subtract(vz, vz, v0);
        vec3.scale(vz, vz, 1 / e);
        vec3.add(dp, vx, vy);
        vec3.add(dp, dp, vz);
        return dp;
      };
      var streams = [];
      var minX = bounds[0][0], minY = bounds[0][1], minZ = bounds[0][2];
      var maxX = bounds[1][0], maxY = bounds[1][1], maxZ = bounds[1][2];
      var inBounds = function(p2) {
        var x = p2[0];
        var y = p2[1];
        var z = p2[2];
        return !(x < minX || x > maxX || y < minY || y > maxY || z < minZ || z > maxZ);
      };
      var boundsSize = vec3.distance(bounds[0], bounds[1]);
      var maxStepSize = 10 * boundsSize / maxLength;
      var maxStepSizeSq = maxStepSize * maxStepSize;
      var minDistance = 1;
      var maxDivergence = 0;
      var len = positions.length;
      if (len > 1) {
        minDistance = calculateMinPositionDistance(positions);
      }
      for (var i = 0; i < len; i++) {
        var p = vec3.create();
        vec3.copy(p, positions[i]);
        var stream = [p];
        var velocities = [];
        var v = getVelocity(p);
        var op = p;
        velocities.push(v);
        var divergences = [];
        var dv = getDivergence(p, v);
        var dvLength = vec3.length(dv);
        if (isFinite(dvLength) && dvLength > maxDivergence) {
          maxDivergence = dvLength;
        }
        divergences.push(dvLength);
        streams.push({ points: stream, velocities, divergences });
        var j = 0;
        while (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {
          j++;
          var np = vec3.clone(v);
          var sqLen = vec3.squaredLength(np);
          if (sqLen === 0) {
            break;
          } else if (sqLen > maxStepSizeSq) {
            vec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));
          }
          vec3.add(np, np, p);
          v = getVelocity(np);
          if (vec3.squaredDistance(op, np) - maxStepSizeSq > -1e-4 * maxStepSizeSq) {
            stream.push(np);
            op = np;
            velocities.push(v);
            var dv = getDivergence(np, v);
            var dvLength = vec3.length(dv);
            if (isFinite(dvLength) && dvLength > maxDivergence) {
              maxDivergence = dvLength;
            }
            divergences.push(dvLength);
          }
          p = np;
        }
      }
      var tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);
      if (absoluteTubeSize) {
        tubes.tubeScale = absoluteTubeSize;
      } else {
        if (maxDivergence === 0) {
          maxDivergence = 1;
        }
        tubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;
      }
      return tubes;
    };
    var shaders = require_shaders11();
    var createMesh = require_cone().createMesh;
    module2.exports.createTubeMesh = function(gl2, params) {
      return createMesh(gl2, params, {
        shaders,
        traceType: "streamtube"
      });
    };
  }
});

// node_modules/ndarray-pack/doConvert.js
var require_doConvert = __commonJS({
  "node_modules/ndarray-pack/doConvert.js"(exports2, module2) {
    "use strict";
    function CwiseOp() {
      return function(SS, a0, t0, p0, Y0) {
        var s0 = SS[0], s1 = SS[1], s2 = SS[2], t0p0 = t0[0], t0p1 = t0[1], t0p2 = t0[2], index = [0, 0, 0];
        p0 |= 0;
        var i0 = 0, i1 = 0, i2 = 0, d0s0 = t0p2, d0s1 = t0p1 - s2 * t0p2, d0s2 = t0p0 - s1 * t0p1;
        for (i2 = 0; i2 < s0; ++i2) {
          for (i1 = 0; i1 < s1; ++i1) {
            for (i0 = 0; i0 < s2; ++i0) {
              {
                var _inline_1_v = Y0, _inline_1_i;
                for (_inline_1_i = 0; _inline_1_i < index.length - 1; ++_inline_1_i) {
                  _inline_1_v = _inline_1_v[index[_inline_1_i]];
                }
                a0[p0] = _inline_1_v[index[index.length - 1]];
              }
              p0 += d0s0;
              ++index[2];
            }
            p0 += d0s1;
            index[2] -= s2;
            ++index[1];
          }
          p0 += d0s2;
          index[1] -= s1;
          ++index[0];
        }
      };
    }
    function generateCWiseOp() {
      return CwiseOp();
    }
    var compile = generateCWiseOp;
    function thunk(compile2) {
      var CACHED = {};
      return function convert_cwise_thunk(array0, scalar1) {
        var t0 = array0.dtype, r0 = array0.order, type = [t0, r0.join()].join(), proc = CACHED[type];
        if (!proc) {
          CACHED[type] = proc = compile2([t0, r0]);
        }
        return proc(
          array0.shape.slice(0),
          array0.data,
          array0.stride,
          array0.offset | 0,
          scalar1
        );
      };
    }
    function createThunk(proc) {
      return thunk(compile.bind(void 0, proc));
    }
    function compileCwise(user_args) {
      return createThunk({
        funcName: user_args.funcName
      });
    }
    module2.exports = compileCwise({
      funcName: "convert"
    });
  }
});

// node_modules/ndarray-pack/convert.js
var require_convert = __commonJS({
  "node_modules/ndarray-pack/convert.js"(exports2, module2) {
    "use strict";
    var ndarray = require_ndarray();
    var do_convert = require_doConvert();
    module2.exports = function convert(arr, result) {
      var shape = [], c = arr, sz = 1;
      while (Array.isArray(c)) {
        shape.push(c.length);
        sz *= c.length;
        c = c[0];
      }
      if (shape.length === 0) {
        return ndarray();
      }
      if (!result) {
        result = ndarray(new Float64Array(sz), shape);
      }
      do_convert(result, arr);
      return result;
    };
  }
});

// node_modules/ndarray-gradient/fdg.js
var require_fdg = __commonJS({
  "node_modules/ndarray-gradient/fdg.js"(exports2, module2) {
    "use strict";
    var dup = require_dup();
    var CACHED_CWiseOp = {
      zero: function(SS, a0, t0, p0) {
        var s0 = SS[0], t0p0 = t0[0];
        p0 |= 0;
        var i0 = 0, d0s0 = t0p0;
        for (i0 = 0; i0 < s0; ++i0) {
          a0[p0] = 0;
          p0 += d0s0;
        }
      },
      fdTemplate1: function(SS, a0, t0, p0, a1, t1, p1) {
        var s0 = SS[0], t0p0 = t0[0], t1p0 = t1[0], q0 = -1 * t0p0, q1 = t0p0;
        p0 |= 0;
        p1 |= 0;
        var i0 = 0, d0s0 = t0p0, d1s0 = t1p0;
        for (i0 = 0; i0 < s0; ++i0) {
          a1[p1] = 0.5 * (a0[p0 + q0] - a0[p0 + q1]);
          p0 += d0s0;
          p1 += d1s0;
        }
      },
      fdTemplate2: function(SS, a0, t0, p0, a1, t1, p1, a2, t2, p2) {
        var s0 = SS[0], s1 = SS[1], t0p0 = t0[0], t0p1 = t0[1], t1p0 = t1[0], t1p1 = t1[1], t2p0 = t2[0], t2p1 = t2[1], q0 = -1 * t0p0, q1 = t0p0, q2 = -1 * t0p1, q3 = t0p1;
        p0 |= 0;
        p1 |= 0;
        p2 |= 0;
        var i0 = 0, i1 = 0, d0s0 = t0p1, d0s1 = t0p0 - s1 * t0p1, d1s0 = t1p1, d1s1 = t1p0 - s1 * t1p1, d2s0 = t2p1, d2s1 = t2p0 - s1 * t2p1;
        for (i1 = 0; i1 < s0; ++i1) {
          for (i0 = 0; i0 < s1; ++i0) {
            a1[p1] = 0.5 * (a0[p0 + q0] - a0[p0 + q1]);
            a2[p2] = 0.5 * (a0[p0 + q2] - a0[p0 + q3]);
            p0 += d0s0;
            p1 += d1s0;
            p2 += d2s0;
          }
          p0 += d0s1;
          p1 += d1s1;
          p2 += d2s1;
        }
      }
    };
    var CACHED_thunk = {
      cdiff: function(compile2) {
        var CACHED = {};
        return function cdiff_cwise_thunk(array0, array1, array2) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, t2 = array2.dtype, r2 = array2.order, type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1, t2, r2]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array2.data, array2.stride, array2.offset | 0);
        };
      },
      zero: function(compile2) {
        var CACHED = {};
        return function zero_cwise_thunk(array0) {
          var t0 = array0.dtype, r0 = array0.order, type = [t0, r0.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0);
        };
      },
      fdTemplate1: function(compile2) {
        var CACHED = {};
        return function fdTemplate1_cwise_thunk(array0, array1) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, type = [t0, r0.join(), t1, r1.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0);
        };
      },
      fdTemplate2: function(compile2) {
        var CACHED = {};
        return function fdTemplate2_cwise_thunk(array0, array1, array4) {
          var t0 = array0.dtype, r0 = array0.order, t1 = array1.dtype, r1 = array1.order, t4 = array4.dtype, r4 = array4.order, type = [t0, r0.join(), t1, r1.join(), t4, r4.join()].join(), proc = CACHED[type];
          if (!proc) {
            CACHED[type] = proc = compile2([t0, r0, t1, r1, t4, r4]);
          }
          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array4.data, array4.stride, array4.offset | 0);
        };
      }
    };
    function createThunk(proc) {
      var thunk = CACHED_thunk[proc.funcName];
      return thunk(compile.bind(void 0, proc));
    }
    function compile(proc) {
      return CACHED_CWiseOp[proc.funcName];
    }
    function cwiseCompiler(user_args) {
      return createThunk({
        funcName: user_args.funcName
      });
    }
    var TEMPLATE_CACHE = {};
    var GRADIENT_CACHE = {};
    var centralDiff = cwiseCompiler({
      funcName: "cdiff"
    });
    var zeroOut = cwiseCompiler({
      funcName: "zero"
    });
    function generateTemplate(d) {
      if (d in TEMPLATE_CACHE) {
        return TEMPLATE_CACHE[d];
      }
      return TEMPLATE_CACHE[d] = cwiseCompiler({
        funcName: "fdTemplate" + d
      });
    }
    function CACHED_link(diff, zero, grad1, grad2) {
      return function(dst, src) {
        var s = src.shape.slice();
        if (s[0] > 2 && s[1] > 2) {
          grad2(
            src.pick(-1, -1).lo(1, 1).hi(s[0] - 2, s[1] - 2),
            dst.pick(-1, -1, 0).lo(1, 1).hi(s[0] - 2, s[1] - 2),
            dst.pick(-1, -1, 1).lo(1, 1).hi(s[0] - 2, s[1] - 2)
          );
        }
        if (s[1] > 2) {
          grad1(
            src.pick(0, -1).lo(1).hi(s[1] - 2),
            dst.pick(0, -1, 1).lo(1).hi(s[1] - 2)
          );
          zero(
            dst.pick(0, -1, 0).lo(1).hi(s[1] - 2)
          );
        }
        if (s[1] > 2) {
          grad1(
            src.pick(s[0] - 1, -1).lo(1).hi(s[1] - 2),
            dst.pick(s[0] - 1, -1, 1).lo(1).hi(s[1] - 2)
          );
          zero(
            dst.pick(s[0] - 1, -1, 0).lo(1).hi(s[1] - 2)
          );
        }
        if (s[0] > 2) {
          grad1(
            src.pick(-1, 0).lo(1).hi(s[0] - 2),
            dst.pick(-1, 0, 0).lo(1).hi(s[0] - 2)
          );
          zero(
            dst.pick(-1, 0, 1).lo(1).hi(s[0] - 2)
          );
        }
        if (s[0] > 2) {
          grad1(
            src.pick(-1, s[1] - 1).lo(1).hi(s[0] - 2),
            dst.pick(-1, s[1] - 1, 0).lo(1).hi(s[0] - 2)
          );
          zero(
            dst.pick(-1, s[1] - 1, 1).lo(1).hi(s[0] - 2)
          );
        }
        dst.set(0, 0, 0, 0);
        dst.set(0, 0, 1, 0);
        dst.set(s[0] - 1, 0, 0, 0);
        dst.set(s[0] - 1, 0, 1, 0);
        dst.set(0, s[1] - 1, 0, 0);
        dst.set(0, s[1] - 1, 1, 0);
        dst.set(s[0] - 1, s[1] - 1, 0, 0);
        dst.set(s[0] - 1, s[1] - 1, 1, 0);
        return dst;
      };
    }
    function generateGradient(boundaryConditions) {
      var token = boundaryConditions.join();
      var proc = GRADIENT_CACHE[token];
      if (proc) {
        return proc;
      }
      var d = boundaryConditions.length;
      var linkArgs = [centralDiff, zeroOut];
      for (var i = 1; i <= d; ++i) {
        linkArgs.push(generateTemplate(i));
      }
      var link = CACHED_link;
      var proc = link.apply(void 0, linkArgs);
      GRADIENT_CACHE[token] = proc;
      return proc;
    }
    module2.exports = function gradient(out, inp, bc) {
      if (!Array.isArray(bc)) {
        if (typeof bc === "string") {
          bc = dup(inp.dimension, bc);
        } else {
          bc = dup(inp.dimension, "clamp");
        }
      }
      if (inp.size === 0) {
        return out;
      }
      if (inp.dimension === 0) {
        out.set(0);
        return out;
      }
      var cached = generateGradient(bc);
      return cached(out, inp);
    };
  }
});

// node_modules/gl-surface3d/lib/shaders.js
var require_shaders12 = __commonJS({
  "node_modules/gl-surface3d/lib/shaders.js"(exports2) {
    var createShader = require_gl_shader();
    var glslify = require_browser();
    var vertSrc = glslify("../shaders/vertex.glsl");
    var fragSrc = glslify("../shaders/fragment.glsl");
    var contourVertSrc = glslify("../shaders/contour-vertex.glsl");
    var pickSrc = glslify("../shaders/pick.glsl");
    exports2.createShader = function(gl2) {
      var shader = createShader(gl2, vertSrc, fragSrc, null, [
        { name: "uv", type: "vec4" },
        { name: "f", type: "vec3" },
        { name: "normal", type: "vec3" }
      ]);
      shader.attributes.uv.location = 0;
      shader.attributes.f.location = 1;
      shader.attributes.normal.location = 2;
      return shader;
    };
    exports2.createPickShader = function(gl2) {
      var shader = createShader(gl2, vertSrc, pickSrc, null, [
        { name: "uv", type: "vec4" },
        { name: "f", type: "vec3" },
        { name: "normal", type: "vec3" }
      ]);
      shader.attributes.uv.location = 0;
      shader.attributes.f.location = 1;
      shader.attributes.normal.location = 2;
      return shader;
    };
    exports2.createContourShader = function(gl2) {
      var shader = createShader(gl2, contourVertSrc, fragSrc, null, [
        { name: "uv", type: "vec4" },
        { name: "f", type: "float" }
      ]);
      shader.attributes.uv.location = 0;
      shader.attributes.f.location = 1;
      return shader;
    };
    exports2.createPickContourShader = function(gl2) {
      var shader = createShader(gl2, contourVertSrc, pickSrc, null, [
        { name: "uv", type: "vec4" },
        { name: "f", type: "float" }
      ]);
      shader.attributes.uv.location = 0;
      shader.attributes.f.location = 1;
      return shader;
    };
  }
});

// node_modules/gl-surface3d/surface.js
var require_surface = __commonJS({
  "node_modules/gl-surface3d/surface.js"(exports2, module2) {
    "use strict";
    module2.exports = createSurfacePlot;
    var bits = require_twiddle();
    var createBuffer = require_buffer2();
    var createVAO = require_vao();
    var createTexture = require_texture();
    var pool = require_pool();
    var colormap = require_colormap();
    var ops = require_ndarray_ops();
    var pack = require_convert();
    var ndarray = require_ndarray();
    var surfaceNets = require_surfacenets();
    var multiply = require_multiply2();
    var invert = require_invert();
    var bsearch = require_search_bounds();
    var gradient = require_fdg();
    var shaders = require_shaders12();
    var createShader = shaders.createShader;
    var createContourShader = shaders.createContourShader;
    var createPickShader = shaders.createPickShader;
    var createPickContourShader = shaders.createPickContourShader;
    var SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);
    var IDENTITY = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    var QUAD = [
      [0, 0],
      [0, 1],
      [1, 0],
      [1, 1],
      [1, 0],
      [0, 1]
    ];
    var PERMUTATIONS = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];
    (function() {
      for (var i = 0; i < 3; ++i) {
        var p = PERMUTATIONS[i];
        var u = (i + 1) % 3;
        var v = (i + 2) % 3;
        p[u + 0] = 1;
        p[v + 3] = 1;
        p[i + 6] = 1;
      }
    })();
    function SurfacePickResult(position, index, uv, level, dataCoordinate) {
      this.position = position;
      this.index = index;
      this.uv = uv;
      this.level = level;
      this.dataCoordinate = dataCoordinate;
    }
    var N_COLORS = 256;
    function SurfacePlot(gl2, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {
      this.gl = gl2;
      this.shape = shape;
      this.bounds = bounds;
      this.objectOffset = objectOffset;
      this.intensityBounds = [];
      this._shader = shader;
      this._pickShader = pickShader;
      this._coordinateBuffer = coordinates;
      this._vao = vao;
      this._colorMap = colorMap;
      this._contourShader = contourShader;
      this._contourPickShader = contourPickShader;
      this._contourBuffer = contourBuffer;
      this._contourVAO = contourVAO;
      this._contourOffsets = [[], [], []];
      this._contourCounts = [[], [], []];
      this._vertexCount = 0;
      this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);
      this._dynamicBuffer = dynamicBuffer;
      this._dynamicVAO = dynamicVAO;
      this._dynamicOffsets = [0, 0, 0];
      this._dynamicCounts = [0, 0, 0];
      this.contourWidth = [1, 1, 1];
      this.contourLevels = [[1], [1], [1]];
      this.contourTint = [0, 0, 0];
      this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];
      this.showContour = true;
      this.showSurface = true;
      this.enableHighlight = [true, true, true];
      this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.highlightTint = [1, 1, 1];
      this.highlightLevel = [-1, -1, -1];
      this.enableDynamic = [true, true, true];
      this.dynamicLevel = [NaN, NaN, NaN];
      this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];
      this.dynamicTint = [1, 1, 1];
      this.dynamicWidth = [1, 1, 1];
      this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      this.surfaceProject = [false, false, false];
      this.contourProject = [
        [false, false, false],
        [false, false, false],
        [false, false, false]
      ];
      this.colorBounds = [false, false];
      this._field = [
        ndarray(pool.mallocFloat(1024), [0, 0]),
        ndarray(pool.mallocFloat(1024), [0, 0]),
        ndarray(pool.mallocFloat(1024), [0, 0])
      ];
      this.pickId = 1;
      this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];
      this.snapToData = false;
      this.pixelRatio = 1;
      this.opacity = 1;
      this.lightPosition = [10, 1e4, 0];
      this.ambientLight = 0.8;
      this.diffuseLight = 0.8;
      this.specularLight = 2;
      this.roughness = 0.5;
      this.fresnel = 1.5;
      this.vertexColor = 0;
      this.dirty = true;
    }
    var proto = SurfacePlot.prototype;
    proto.genColormap = function(name2, opacityscale) {
      var hasAlpha = false;
      var x = pack([colormap({
        colormap: name2,
        nshades: N_COLORS,
        format: "rgba"
      }).map(function(c, i) {
        var a = opacityscale ? getOpacityFromScale(i / 255, opacityscale) : c[3];
        if (a < 1) hasAlpha = true;
        return [c[0], c[1], c[2], 255 * a];
      })]);
      ops.divseq(x, 255);
      this.hasAlphaScale = hasAlpha;
      return x;
    };
    proto.isTransparent = function() {
      return this.opacity < 1 || this.hasAlphaScale;
    };
    proto.isOpaque = function() {
      return !this.isTransparent();
    };
    proto.pickSlots = 1;
    proto.setPickBase = function(id) {
      this.pickId = id;
    };
    function getOpacityFromScale(ratio, opacityscale) {
      if (!opacityscale) return 1;
      if (!opacityscale.length) return 1;
      for (var i = 0; i < opacityscale.length; ++i) {
        if (opacityscale.length < 2) return 1;
        if (opacityscale[i][0] === ratio) return opacityscale[i][1];
        if (opacityscale[i][0] > ratio && i > 0) {
          var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);
          return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];
        }
      }
      return 1;
    }
    var ZERO_VEC = [0, 0, 0];
    var PROJECT_DATA = {
      showSurface: false,
      showContour: false,
      projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],
      clipBounds: [
        [[0, 0, 0], [0, 0, 0]],
        [[0, 0, 0], [0, 0, 0]],
        [[0, 0, 0], [0, 0, 0]]
      ]
    };
    function computeProjectionData(camera, obj) {
      var i, j, k;
      var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;
      var showSurface = obj.showSurface;
      var showContour = obj.showContour;
      for (i = 0; i < 3; ++i) {
        showSurface = showSurface || obj.surfaceProject[i];
        for (j = 0; j < 3; ++j) {
          showContour = showContour || obj.contourProject[i][j];
        }
      }
      for (i = 0; i < 3; ++i) {
        var axisSquish = PROJECT_DATA.projections[i];
        for (j = 0; j < 16; ++j) {
          axisSquish[j] = 0;
        }
        for (j = 0; j < 4; ++j) {
          axisSquish[5 * j] = 1;
        }
        axisSquish[5 * i] = 0;
        axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];
        multiply(axisSquish, camera.model, axisSquish);
        var nclipBounds = PROJECT_DATA.clipBounds[i];
        for (k = 0; k < 2; ++k) {
          for (j = 0; j < 3; ++j) {
            nclipBounds[k][j] = camera.clipBounds[k][j];
          }
        }
        nclipBounds[0][i] = -1e8;
        nclipBounds[1][i] = 1e8;
      }
      PROJECT_DATA.showSurface = showSurface;
      PROJECT_DATA.showContour = showContour;
      return PROJECT_DATA;
    }
    var UNIFORMS = {
      model: IDENTITY,
      view: IDENTITY,
      projection: IDENTITY,
      inverseModel: IDENTITY.slice(),
      lowerBound: [0, 0, 0],
      upperBound: [0, 0, 0],
      colorMap: 0,
      clipBounds: [[0, 0, 0], [0, 0, 0]],
      height: 0,
      contourTint: 0,
      contourColor: [0, 0, 0, 1],
      permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
      zOffset: -1e-4,
      objectOffset: [0, 0, 0],
      kambient: 1,
      kdiffuse: 1,
      kspecular: 1,
      lightPosition: [1e3, 1e3, 1e3],
      eyePosition: [0, 0, 0],
      roughness: 1,
      fresnel: 1,
      opacity: 1,
      vertexColor: 0
    };
    var MATRIX_INVERSE = IDENTITY.slice();
    var DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    function drawCore(params, transparent) {
      params = params || {};
      var gl2 = this.gl;
      gl2.disable(gl2.CULL_FACE);
      this._colorMap.bind(0);
      var uniforms = UNIFORMS;
      uniforms.model = params.model || IDENTITY;
      uniforms.view = params.view || IDENTITY;
      uniforms.projection = params.projection || IDENTITY;
      uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];
      uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];
      uniforms.objectOffset = this.objectOffset;
      uniforms.contourColor = this.contourColor[0];
      uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);
      for (var i = 0; i < 2; ++i) {
        var clipClamped = uniforms.clipBounds[i];
        for (var j = 0; j < 3; ++j) {
          clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);
        }
      }
      uniforms.kambient = this.ambientLight;
      uniforms.kdiffuse = this.diffuseLight;
      uniforms.kspecular = this.specularLight;
      uniforms.roughness = this.roughness;
      uniforms.fresnel = this.fresnel;
      uniforms.opacity = this.opacity;
      uniforms.height = 0;
      uniforms.permutation = DEFAULT_PERM;
      uniforms.vertexColor = this.vertexColor;
      var invCameraMatrix = MATRIX_INVERSE;
      multiply(invCameraMatrix, uniforms.view, uniforms.model);
      multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);
      invert(invCameraMatrix, invCameraMatrix);
      for (i = 0; i < 3; ++i) {
        uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];
      }
      var w = invCameraMatrix[15];
      for (i = 0; i < 3; ++i) {
        w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];
      }
      for (i = 0; i < 3; ++i) {
        var s = invCameraMatrix[12 + i];
        for (j = 0; j < 3; ++j) {
          s += invCameraMatrix[4 * j + i] * this.lightPosition[j];
        }
        uniforms.lightPosition[i] = s / w;
      }
      var projectData = computeProjectionData(uniforms, this);
      if (projectData.showSurface) {
        this._shader.bind();
        this._shader.uniforms = uniforms;
        this._vao.bind();
        if (this.showSurface && this._vertexCount) {
          this._vao.draw(gl2.TRIANGLES, this._vertexCount);
        }
        for (i = 0; i < 3; ++i) {
          if (!this.surfaceProject[i] || !this.vertexCount) {
            continue;
          }
          this._shader.uniforms.model = projectData.projections[i];
          this._shader.uniforms.clipBounds = projectData.clipBounds[i];
          this._vao.draw(gl2.TRIANGLES, this._vertexCount);
        }
        this._vao.unbind();
      }
      if (projectData.showContour) {
        var shader = this._contourShader;
        uniforms.kambient = 1;
        uniforms.kdiffuse = 0;
        uniforms.kspecular = 0;
        uniforms.opacity = 1;
        shader.bind();
        shader.uniforms = uniforms;
        var vao = this._contourVAO;
        vao.bind();
        for (i = 0; i < 3; ++i) {
          shader.uniforms.permutation = PERMUTATIONS[i];
          gl2.lineWidth(this.contourWidth[i] * this.pixelRatio);
          for (j = 0; j < this.contourLevels[i].length; ++j) {
            if (j === this.highlightLevel[i]) {
              shader.uniforms.contourColor = this.highlightColor[i];
              shader.uniforms.contourTint = this.highlightTint[i];
            } else if (j === 0 || j - 1 === this.highlightLevel[i]) {
              shader.uniforms.contourColor = this.contourColor[i];
              shader.uniforms.contourTint = this.contourTint[i];
            }
            if (!this._contourCounts[i][j]) {
              continue;
            }
            shader.uniforms.height = this.contourLevels[i][j];
            vao.draw(gl2.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);
          }
        }
        for (i = 0; i < 3; ++i) {
          shader.uniforms.model = projectData.projections[i];
          shader.uniforms.clipBounds = projectData.clipBounds[i];
          for (j = 0; j < 3; ++j) {
            if (!this.contourProject[i][j]) {
              continue;
            }
            shader.uniforms.permutation = PERMUTATIONS[j];
            gl2.lineWidth(this.contourWidth[j] * this.pixelRatio);
            for (var k = 0; k < this.contourLevels[j].length; ++k) {
              if (k === this.highlightLevel[j]) {
                shader.uniforms.contourColor = this.highlightColor[j];
                shader.uniforms.contourTint = this.highlightTint[j];
              } else if (k === 0 || k - 1 === this.highlightLevel[j]) {
                shader.uniforms.contourColor = this.contourColor[j];
                shader.uniforms.contourTint = this.contourTint[j];
              }
              if (!this._contourCounts[j][k]) {
                continue;
              }
              shader.uniforms.height = this.contourLevels[j][k];
              vao.draw(gl2.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);
            }
          }
        }
        vao.unbind();
        vao = this._dynamicVAO;
        vao.bind();
        for (i = 0; i < 3; ++i) {
          if (this._dynamicCounts[i] === 0) {
            continue;
          }
          shader.uniforms.model = uniforms.model;
          shader.uniforms.clipBounds = uniforms.clipBounds;
          shader.uniforms.permutation = PERMUTATIONS[i];
          gl2.lineWidth(this.dynamicWidth[i] * this.pixelRatio);
          shader.uniforms.contourColor = this.dynamicColor[i];
          shader.uniforms.contourTint = this.dynamicTint[i];
          shader.uniforms.height = this.dynamicLevel[i];
          vao.draw(gl2.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);
          for (j = 0; j < 3; ++j) {
            if (!this.contourProject[j][i]) {
              continue;
            }
            shader.uniforms.model = projectData.projections[j];
            shader.uniforms.clipBounds = projectData.clipBounds[j];
            vao.draw(gl2.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);
          }
        }
        vao.unbind();
      }
    }
    proto.draw = function(params) {
      return drawCore.call(this, params, false);
    };
    proto.drawTransparent = function(params) {
      return drawCore.call(this, params, true);
    };
    var PICK_UNIFORMS = {
      model: IDENTITY,
      view: IDENTITY,
      projection: IDENTITY,
      inverseModel: IDENTITY,
      clipBounds: [[0, 0, 0], [0, 0, 0]],
      height: 0,
      shape: [0, 0],
      pickId: 0,
      lowerBound: [0, 0, 0],
      upperBound: [0, 0, 0],
      zOffset: 0,
      objectOffset: [0, 0, 0],
      permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
      lightPosition: [0, 0, 0],
      eyePosition: [0, 0, 0]
    };
    proto.drawPick = function(params) {
      params = params || {};
      var gl2 = this.gl;
      gl2.disable(gl2.CULL_FACE);
      var uniforms = PICK_UNIFORMS;
      uniforms.model = params.model || IDENTITY;
      uniforms.view = params.view || IDENTITY;
      uniforms.projection = params.projection || IDENTITY;
      uniforms.shape = this._field[2].shape;
      uniforms.pickId = this.pickId / 255;
      uniforms.lowerBound = this.bounds[0];
      uniforms.upperBound = this.bounds[1];
      uniforms.objectOffset = this.objectOffset;
      uniforms.permutation = DEFAULT_PERM;
      for (var i = 0; i < 2; ++i) {
        var clipClamped = uniforms.clipBounds[i];
        for (var j = 0; j < 3; ++j) {
          clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);
        }
      }
      var projectData = computeProjectionData(uniforms, this);
      if (projectData.showSurface) {
        this._pickShader.bind();
        this._pickShader.uniforms = uniforms;
        this._vao.bind();
        this._vao.draw(gl2.TRIANGLES, this._vertexCount);
        for (i = 0; i < 3; ++i) {
          if (!this.surfaceProject[i]) {
            continue;
          }
          this._pickShader.uniforms.model = projectData.projections[i];
          this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];
          this._vao.draw(gl2.TRIANGLES, this._vertexCount);
        }
        this._vao.unbind();
      }
      if (projectData.showContour) {
        var shader = this._contourPickShader;
        shader.bind();
        shader.uniforms = uniforms;
        var vao = this._contourVAO;
        vao.bind();
        for (j = 0; j < 3; ++j) {
          gl2.lineWidth(this.contourWidth[j] * this.pixelRatio);
          shader.uniforms.permutation = PERMUTATIONS[j];
          for (i = 0; i < this.contourLevels[j].length; ++i) {
            if (this._contourCounts[j][i]) {
              shader.uniforms.height = this.contourLevels[j][i];
              vao.draw(gl2.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);
            }
          }
        }
        for (i = 0; i < 3; ++i) {
          shader.uniforms.model = projectData.projections[i];
          shader.uniforms.clipBounds = projectData.clipBounds[i];
          for (j = 0; j < 3; ++j) {
            if (!this.contourProject[i][j]) {
              continue;
            }
            shader.uniforms.permutation = PERMUTATIONS[j];
            gl2.lineWidth(this.contourWidth[j] * this.pixelRatio);
            for (var k = 0; k < this.contourLevels[j].length; ++k) {
              if (this._contourCounts[j][k]) {
                shader.uniforms.height = this.contourLevels[j][k];
                vao.draw(gl2.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);
              }
            }
          }
        }
        vao.unbind();
      }
    };
    proto.pick = function(selection) {
      if (!selection) {
        return null;
      }
      if (selection.id !== this.pickId) {
        return null;
      }
      var shape = this._field[2].shape;
      var result = this._pickResult;
      var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16) / 255;
      var ix = Math.floor(x);
      var fx = x - ix;
      var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16) / 255;
      var iy = Math.floor(y);
      var fy = y - iy;
      ix += 1;
      iy += 1;
      var pos = result.position;
      pos[0] = pos[1] = pos[2] = 0;
      for (var dx = 0; dx < 2; ++dx) {
        var s = dx ? fx : 1 - fx;
        for (var dy = 0; dy < 2; ++dy) {
          var t = dy ? fy : 1 - fy;
          var r = ix + dx;
          var c = iy + dy;
          var w = s * t;
          for (var i = 0; i < 3; ++i) {
            pos[i] += this._field[i].get(r, c) * w;
          }
        }
      }
      var levelIndex = this._pickResult.level;
      for (var j = 0; j < 3; ++j) {
        levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);
        if (levelIndex[j] < 0) {
          if (this.contourLevels[j].length > 0) {
            levelIndex[j] = 0;
          }
        } else if (levelIndex[j] < this.contourLevels[j].length - 1) {
          var a = this.contourLevels[j][levelIndex[j]];
          var b = this.contourLevels[j][levelIndex[j] + 1];
          if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {
            levelIndex[j] += 1;
          }
        }
      }
      result.index[0] = fx < 0.5 ? ix : ix + 1;
      result.index[1] = fy < 0.5 ? iy : iy + 1;
      result.uv[0] = x / shape[0];
      result.uv[1] = y / shape[1];
      for (i = 0; i < 3; ++i) {
        result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);
      }
      return result;
    };
    proto.padField = function(dstField, srcField) {
      var srcShape = srcField.shape.slice();
      var dstShape = dstField.shape.slice();
      ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField);
      ops.assign(
        dstField.lo(1).hi(srcShape[0], 1),
        srcField.hi(srcShape[0], 1)
      );
      ops.assign(
        dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1),
        srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1)
      );
      ops.assign(
        dstField.lo(0, 1).hi(1, srcShape[1]),
        srcField.hi(1)
      );
      ops.assign(
        dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]),
        srcField.lo(srcShape[0] - 1)
      );
      dstField.set(0, 0, srcField.get(0, 0));
      dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));
      dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));
      dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));
    };
    function handleArray(param, ctor) {
      if (Array.isArray(param)) {
        return [ctor(param[0]), ctor(param[1]), ctor(param[2])];
      }
      return [ctor(param), ctor(param), ctor(param)];
    }
    function toColor(x) {
      if (Array.isArray(x)) {
        if (x.length === 3) {
          return [x[0], x[1], x[2], 1];
        }
        return [x[0], x[1], x[2], x[3]];
      }
      return [0, 0, 0, 1];
    }
    function handleColor(param) {
      if (Array.isArray(param)) {
        if (Array.isArray(param)) {
          return [
            toColor(param[0]),
            toColor(param[1]),
            toColor(param[2])
          ];
        } else {
          var c = toColor(param);
          return [
            c.slice(),
            c.slice(),
            c.slice()
          ];
        }
      }
    }
    proto.update = function(params) {
      params = params || {};
      this.objectOffset = params.objectOffset || this.objectOffset;
      this.dirty = true;
      if ("contourWidth" in params) {
        this.contourWidth = handleArray(params.contourWidth, Number);
      }
      if ("showContour" in params) {
        this.showContour = handleArray(params.showContour, Boolean);
      }
      if ("showSurface" in params) {
        this.showSurface = !!params.showSurface;
      }
      if ("contourTint" in params) {
        this.contourTint = handleArray(params.contourTint, Boolean);
      }
      if ("contourColor" in params) {
        this.contourColor = handleColor(params.contourColor);
      }
      if ("contourProject" in params) {
        this.contourProject = handleArray(params.contourProject, function(x2) {
          return handleArray(x2, Boolean);
        });
      }
      if ("surfaceProject" in params) {
        this.surfaceProject = params.surfaceProject;
      }
      if ("dynamicColor" in params) {
        this.dynamicColor = handleColor(params.dynamicColor);
      }
      if ("dynamicTint" in params) {
        this.dynamicTint = handleArray(params.dynamicTint, Number);
      }
      if ("dynamicWidth" in params) {
        this.dynamicWidth = handleArray(params.dynamicWidth, Number);
      }
      if ("opacity" in params) {
        this.opacity = params.opacity;
      }
      if ("opacityscale" in params) {
        this.opacityscale = params.opacityscale;
      }
      if ("colorBounds" in params) {
        this.colorBounds = params.colorBounds;
      }
      if ("vertexColor" in params) {
        this.vertexColor = params.vertexColor ? 1 : 0;
      }
      if ("colormap" in params) {
        this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale));
      }
      var field = params.field || params.coords && params.coords[2] || null;
      var levelsChanged = false;
      if (!field) {
        if (this._field[2].shape[0] || this._field[2].shape[2]) {
          field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);
        } else {
          field = this._field[2].hi(0, 0);
        }
      }
      if ("field" in params || "coords" in params) {
        var fsize = (field.shape[0] + 2) * (field.shape[1] + 2);
        if (fsize > this._field[2].data.length) {
          pool.freeFloat(this._field[2].data);
          this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));
        }
        this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);
        this.padField(this._field[2], field);
        this.shape = field.shape.slice();
        var shape = this.shape;
        for (var i = 0; i < 2; ++i) {
          if (this._field[2].size > this._field[i].data.length) {
            pool.freeFloat(this._field[i].data);
            this._field[i].data = pool.mallocFloat(this._field[2].size);
          }
          this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);
        }
        if (params.coords) {
          var coords = params.coords;
          if (!Array.isArray(coords) || coords.length !== 3) {
            throw new Error("gl-surface: invalid coordinates for x/y");
          }
          for (i = 0; i < 2; ++i) {
            var coord = coords[i];
            for (j = 0; j < 2; ++j) {
              if (coord.shape[j] !== shape[j]) {
                throw new Error("gl-surface: coords have incorrect shape");
              }
            }
            this.padField(this._field[i], coord);
          }
        } else if (params.ticks) {
          var ticks = params.ticks;
          if (!Array.isArray(ticks) || ticks.length !== 2) {
            throw new Error("gl-surface: invalid ticks");
          }
          for (i = 0; i < 2; ++i) {
            var tick = ticks[i];
            if (Array.isArray(tick) || tick.length) {
              tick = ndarray(tick);
            }
            if (tick.shape[0] !== shape[i]) {
              throw new Error("gl-surface: invalid tick length");
            }
            var tick2 = ndarray(tick.data, shape);
            tick2.stride[i] = tick.stride[0];
            tick2.stride[i ^ 1] = 0;
            this.padField(this._field[i], tick2);
          }
        } else {
          for (i = 0; i < 2; ++i) {
            var offset = [0, 0];
            offset[i] = 1;
            this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);
          }
          this._field[0].set(0, 0, 0);
          for (var j = 0; j < shape[0]; ++j) {
            this._field[0].set(j + 1, 0, j);
          }
          this._field[0].set(shape[0] + 1, 0, shape[0] - 1);
          this._field[1].set(0, 0, 0);
          for (j = 0; j < shape[1]; ++j) {
            this._field[1].set(0, j + 1, j);
          }
          this._field[1].set(0, shape[1] + 1, shape[1] - 1);
        }
        var fields = this._field;
        var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);
        for (i = 0; i < 3; ++i) {
          gradient(dfields.pick(i), fields[i], "mirror");
        }
        var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);
        for (i = 0; i < shape[0] + 2; ++i) {
          for (j = 0; j < shape[1] + 2; ++j) {
            var dxdu = dfields.get(0, i, j, 0);
            var dxdv = dfields.get(0, i, j, 1);
            var dydu = dfields.get(1, i, j, 0);
            var dydv = dfields.get(1, i, j, 1);
            var dzdu = dfields.get(2, i, j, 0);
            var dzdv = dfields.get(2, i, j, 1);
            var nx = dydu * dzdv - dydv * dzdu;
            var ny = dzdu * dxdv - dzdv * dxdu;
            var nz = dxdu * dydv - dxdv * dydu;
            var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);
            if (nl < 1e-8) {
              nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));
              if (nl < 1e-8) {
                nz = 1;
                ny = nx = 0;
                nl = 1;
              } else {
                nl = 1 / nl;
              }
            } else {
              nl = 1 / Math.sqrt(nl);
            }
            normals.set(i, j, 0, nx * nl);
            normals.set(i, j, 1, ny * nl);
            normals.set(i, j, 2, nz * nl);
          }
        }
        pool.free(dfields.data);
        var lo = [Infinity, Infinity, Infinity];
        var hi = [-Infinity, -Infinity, -Infinity];
        var lo_intensity = Infinity;
        var hi_intensity = -Infinity;
        var count = (shape[0] - 1) * (shape[1] - 1) * 6;
        var tverts = pool.mallocFloat(bits.nextPow2(10 * count));
        var tptr = 0;
        var vertexCount = 0;
        for (i = 0; i < shape[0] - 1; ++i) {
          j_loop:
            for (j = 0; j < shape[1] - 1; ++j) {
              for (var dx = 0; dx < 2; ++dx) {
                for (var dy = 0; dy < 2; ++dy) {
                  for (var k = 0; k < 3; ++k) {
                    var f = this._field[k].get(1 + i + dx, 1 + j + dy);
                    if (isNaN(f) || !isFinite(f)) {
                      continue j_loop;
                    }
                  }
                }
              }
              for (k = 0; k < 6; ++k) {
                var r = i + QUAD[k][0];
                var c = j + QUAD[k][1];
                var tx = this._field[0].get(r + 1, c + 1);
                var ty = this._field[1].get(r + 1, c + 1);
                f = this._field[2].get(r + 1, c + 1);
                nx = normals.get(r + 1, c + 1, 0);
                ny = normals.get(r + 1, c + 1, 1);
                nz = normals.get(r + 1, c + 1, 2);
                if (params.intensity) {
                  vf = params.intensity.get(r, c);
                }
                var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];
                tverts[tptr++] = r;
                tverts[tptr++] = c;
                tverts[tptr++] = tx;
                tverts[tptr++] = ty;
                tverts[tptr++] = f;
                tverts[tptr++] = 0;
                tverts[tptr++] = vf;
                tverts[tptr++] = nx;
                tverts[tptr++] = ny;
                tverts[tptr++] = nz;
                lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);
                lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);
                lo[2] = Math.min(lo[2], f + this.objectOffset[2]);
                lo_intensity = Math.min(lo_intensity, vf);
                hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);
                hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);
                hi[2] = Math.max(hi[2], f + this.objectOffset[2]);
                hi_intensity = Math.max(hi_intensity, vf);
                vertexCount += 1;
              }
            }
        }
        if (params.intensityBounds) {
          lo_intensity = +params.intensityBounds[0];
          hi_intensity = +params.intensityBounds[1];
        }
        for (i = 6; i < tptr; i += 10) {
          tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);
        }
        this._vertexCount = vertexCount;
        this._coordinateBuffer.update(tverts.subarray(0, tptr));
        pool.freeFloat(tverts);
        pool.free(normals.data);
        this.bounds = [lo, hi];
        this.intensity = params.intensity || this._field[2];
        if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {
          levelsChanged = true;
        }
        this.intensityBounds = [lo_intensity, hi_intensity];
      }
      if ("levels" in params) {
        var levels = params.levels;
        if (!Array.isArray(levels[0])) {
          levels = [[], [], levels];
        } else {
          levels = levels.slice();
        }
        for (i = 0; i < 3; ++i) {
          levels[i] = levels[i].slice();
          levels[i].sort(function(a, b) {
            return a - b;
          });
        }
        for (i = 0; i < 3; ++i) {
          for (j = 0; j < levels[i].length; ++j) {
            levels[i][j] -= this.objectOffset[i];
          }
        }
        change_test:
          for (i = 0; i < 3; ++i) {
            if (levels[i].length !== this.contourLevels[i].length) {
              levelsChanged = true;
              break;
            }
            for (j = 0; j < levels[i].length; ++j) {
              if (levels[i][j] !== this.contourLevels[i][j]) {
                levelsChanged = true;
                break change_test;
              }
            }
          }
        this.contourLevels = levels;
      }
      if (levelsChanged) {
        fields = this._field;
        shape = this.shape;
        var contourVerts = [];
        for (var dim = 0; dim < 3; ++dim) {
          var contourLevel = this.contourLevels[dim];
          var levelOffsets = [];
          var levelCounts = [];
          var parts = [0, 0, 0];
          for (i = 0; i < contourLevel.length; ++i) {
            var graph = surfaceNets(this._field[dim], contourLevel[i]);
            levelOffsets.push(contourVerts.length / 5 | 0);
            vertexCount = 0;
            edge_loop:
              for (j = 0; j < graph.cells.length; ++j) {
                var e = graph.cells[j];
                for (k = 0; k < 2; ++k) {
                  var p = graph.positions[e[k]];
                  var x = p[0];
                  var ix = Math.floor(x) | 0;
                  var fx = x - ix;
                  var y = p[1];
                  var iy = Math.floor(y) | 0;
                  var fy = y - iy;
                  var hole = false;
                  axis_loop:
                    for (var axis = 0; axis < 3; ++axis) {
                      parts[axis] = 0;
                      var iu = (dim + axis + 1) % 3;
                      for (dx = 0; dx < 2; ++dx) {
                        var s = dx ? fx : 1 - fx;
                        r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;
                        for (dy = 0; dy < 2; ++dy) {
                          var t = dy ? fy : 1 - fy;
                          c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;
                          if (axis < 2) {
                            f = this._field[iu].get(r, c);
                          } else {
                            f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);
                          }
                          if (!isFinite(f) || isNaN(f)) {
                            hole = true;
                            break axis_loop;
                          }
                          var w = s * t;
                          parts[axis] += w * f;
                        }
                      }
                    }
                  if (!hole) {
                    contourVerts.push(
                      parts[0],
                      parts[1],
                      p[0],
                      p[1],
                      parts[2]
                    );
                    vertexCount += 1;
                  } else {
                    if (k > 0) {
                      for (var l = 0; l < 5; ++l) {
                        contourVerts.pop();
                      }
                      vertexCount -= 1;
                    }
                    continue edge_loop;
                  }
                }
              }
            levelCounts.push(vertexCount);
          }
          this._contourOffsets[dim] = levelOffsets;
          this._contourCounts[dim] = levelCounts;
        }
        var floatBuffer = pool.mallocFloat(contourVerts.length);
        for (i = 0; i < contourVerts.length; ++i) {
          floatBuffer[i] = contourVerts[i];
        }
        this._contourBuffer.update(floatBuffer);
        pool.freeFloat(floatBuffer);
      }
    };
    proto.dispose = function() {
      this._shader.dispose();
      this._vao.dispose();
      this._coordinateBuffer.dispose();
      this._colorMap.dispose();
      this._contourBuffer.dispose();
      this._contourVAO.dispose();
      this._contourShader.dispose();
      this._contourPickShader.dispose();
      this._dynamicBuffer.dispose();
      this._dynamicVAO.dispose();
      for (var i = 0; i < 3; ++i) {
        pool.freeFloat(this._field[i].data);
      }
    };
    proto.highlight = function(selection) {
      var i;
      if (!selection) {
        this._dynamicCounts = [0, 0, 0];
        this.dyanamicLevel = [NaN, NaN, NaN];
        this.highlightLevel = [-1, -1, -1];
        return;
      }
      for (i = 0; i < 3; ++i) {
        if (this.enableHighlight[i]) {
          this.highlightLevel[i] = selection.level[i];
        } else {
          this.highlightLevel[i] = -1;
        }
      }
      var levels;
      if (this.snapToData) {
        levels = selection.dataCoordinate;
      } else {
        levels = selection.position;
      }
      for (i = 0; i < 3; ++i) {
        levels[i] -= this.objectOffset[i];
      }
      if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {
        return;
      }
      var vertexCount = 0;
      var shape = this.shape;
      var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);
      for (var d = 0; d < 3; ++d) {
        if (!this.enableDynamic[d]) {
          this.dynamicLevel[d] = NaN;
          this._dynamicCounts[d] = 0;
          continue;
        }
        this.dynamicLevel[d] = levels[d];
        var u = (d + 1) % 3;
        var v = (d + 2) % 3;
        var f = this._field[d];
        var g = this._field[u];
        var h = this._field[v];
        var graph = surfaceNets(f, levels[d]);
        var edges = graph.cells;
        var positions = graph.positions;
        this._dynamicOffsets[d] = vertexCount;
        for (i = 0; i < edges.length; ++i) {
          var e = edges[i];
          for (var j = 0; j < 2; ++j) {
            var p = positions[e[j]];
            var x = +p[0];
            var ix = x | 0;
            var jx = Math.min(ix + 1, shape[0]) | 0;
            var fx = x - ix;
            var hx = 1 - fx;
            var y = +p[1];
            var iy = y | 0;
            var jy = Math.min(iy + 1, shape[1]) | 0;
            var fy = y - iy;
            var hy = 1 - fy;
            var w00 = hx * hy;
            var w01 = hx * fy;
            var w10 = fx * hy;
            var w11 = fx * fy;
            var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);
            var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);
            if (isNaN(cu) || isNaN(cv)) {
              if (j) {
                vertexCount -= 1;
              }
              break;
            }
            scratchBuffer[2 * vertexCount + 0] = cu;
            scratchBuffer[2 * vertexCount + 1] = cv;
            vertexCount += 1;
          }
        }
        this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];
      }
      this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));
      pool.freeFloat(scratchBuffer);
    };
    function createSurfacePlot(params) {
      var gl2 = params.gl;
      var shader = createShader(gl2);
      var pickShader = createPickShader(gl2);
      var contourShader = createContourShader(gl2);
      var contourPickShader = createPickContourShader(gl2);
      var coordinateBuffer = createBuffer(gl2);
      var vao = createVAO(gl2, [
        {
          buffer: coordinateBuffer,
          size: 4,
          stride: SURFACE_VERTEX_SIZE,
          offset: 0
        },
        {
          buffer: coordinateBuffer,
          size: 3,
          stride: SURFACE_VERTEX_SIZE,
          offset: 16
        },
        {
          buffer: coordinateBuffer,
          size: 3,
          stride: SURFACE_VERTEX_SIZE,
          offset: 28
        }
      ]);
      var contourBuffer = createBuffer(gl2);
      var contourVAO = createVAO(gl2, [
        {
          buffer: contourBuffer,
          size: 4,
          stride: 20,
          offset: 0
        },
        {
          buffer: contourBuffer,
          size: 1,
          stride: 20,
          offset: 16
        }
      ]);
      var dynamicBuffer = createBuffer(gl2);
      var dynamicVAO = createVAO(gl2, [
        {
          buffer: dynamicBuffer,
          size: 2,
          type: gl2.FLOAT
        }
      ]);
      var cmap = createTexture(gl2, 1, N_COLORS, gl2.RGBA, gl2.UNSIGNED_BYTE);
      cmap.minFilter = gl2.LINEAR;
      cmap.magFilter = gl2.LINEAR;
      var surface = new SurfacePlot(
        gl2,
        [0, 0],
        // shape
        [[0, 0, 0], [0, 0, 0]],
        // bounds
        shader,
        pickShader,
        coordinateBuffer,
        vao,
        cmap,
        contourShader,
        contourPickShader,
        contourBuffer,
        contourVAO,
        dynamicBuffer,
        dynamicVAO,
        [0, 0, 0]
        // objectOffset
      );
      var nparams = {
        levels: [[], [], []]
      };
      for (var id in params) {
        nparams[id] = params[id];
      }
      nparams.colormap = nparams.colormap || "jet";
      surface.update(nparams);
      return surface;
    }
  }
});

// node_modules/ndarray-linear-interpolate/interp.js
var require_interp = __commonJS({
  "node_modules/ndarray-linear-interpolate/interp.js"(exports2, module2) {
    "use strict";
    function interp1d(arr, x) {
      var ix = Math.floor(x), fx = x - ix, s0 = 0 <= ix && ix < arr.shape[0], s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0], w0 = s0 ? +arr.get(ix) : 0, w1 = s1 ? +arr.get(ix + 1) : 0;
      return (1 - fx) * w0 + fx * w1;
    }
    function interp2d(arr, x, y) {
      var ix = Math.floor(x), fx = x - ix, s0 = 0 <= ix && ix < arr.shape[0], s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0], iy = Math.floor(y), fy = y - iy, t0 = 0 <= iy && iy < arr.shape[1], t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1], w00 = s0 && t0 ? arr.get(ix, iy) : 0, w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0, w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0, w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0;
      return (1 - fy) * ((1 - fx) * w00 + fx * w10) + fy * ((1 - fx) * w01 + fx * w11);
    }
    function interp3d(arr, x, y, z) {
      var ix = Math.floor(x), fx = x - ix, s0 = 0 <= ix && ix < arr.shape[0], s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0], iy = Math.floor(y), fy = y - iy, t0 = 0 <= iy && iy < arr.shape[1], t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1], iz = Math.floor(z), fz = z - iz, u0 = 0 <= iz && iz < arr.shape[2], u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2], w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0, w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0, w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0, w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0, w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0, w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0, w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0, w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0;
      return (1 - fz) * ((1 - fy) * ((1 - fx) * w000 + fx * w100) + fy * ((1 - fx) * w010 + fx * w110)) + fz * ((1 - fy) * ((1 - fx) * w001 + fx * w101) + fy * ((1 - fx) * w011 + fx * w111));
    }
    function interpNd(arr) {
      var d = arr.shape.length | 0, ix = new Array(d), fx = new Array(d), s0 = new Array(d), s1 = new Array(d), i, t;
      for (i = 0; i < d; ++i) {
        t = +arguments[i + 1];
        ix[i] = Math.floor(t);
        fx[i] = t - ix[i];
        s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];
        s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];
      }
      var r = 0, j, w, idx;
      i_loop:
        for (i = 0; i < 1 << d; ++i) {
          w = 1;
          idx = arr.offset;
          for (j = 0; j < d; ++j) {
            if (i & 1 << j) {
              if (!s1[j]) {
                continue i_loop;
              }
              w *= fx[j];
              idx += arr.stride[j] * (ix[j] + 1);
            } else {
              if (!s0[j]) {
                continue i_loop;
              }
              w *= 1 - fx[j];
              idx += arr.stride[j] * ix[j];
            }
          }
          r += w * arr.data[idx];
        }
      return r;
    }
    function interpolate(arr, x, y, z) {
      switch (arr.shape.length) {
        case 0:
          return 0;
        case 1:
          return interp1d(arr, x);
        case 2:
          return interp2d(arr, x, y);
        case 3:
          return interp3d(arr, x, y, z);
        default:
          return interpNd.apply(void 0, arguments);
      }
    }
    module2.exports = interpolate;
    module2.exports.d1 = interp1d;
    module2.exports.d2 = interp2d;
    module2.exports.d3 = interp3d;
  }
});

// main.js
module.exports = {
  alpha_shape: require_alpha2(),
  convex_hull: require_ch(),
  delaunay_triangulate: require_triangulate(),
  gl_cone3d: require_cone(),
  gl_error3d: require_errorbars(),
  gl_heatmap2d: require_heatmap(),
  gl_line3d: require_lines(),
  gl_mesh3d: require_mesh(),
  gl_plot2d: require_plot(),
  gl_plot3d: require_scene(),
  gl_pointcloud2d: require_pointcloud2d(),
  gl_scatter3d: require_pointcloud(),
  gl_select_box: require_selectbox(),
  gl_spikes2d: require_spikes2(),
  gl_streamtube3d: require_streamtube(),
  gl_surface3d: require_surface(),
  ndarray: require_ndarray(),
  ndarray_linear_interpolate: require_interp()
};
/*! Bundled license information:

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

pad-left/index.js:
  (*!
   * pad-left <https://github.com/jonschlinkert/pad-left>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT license.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
